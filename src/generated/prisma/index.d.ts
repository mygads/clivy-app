
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model WhatsAppSession
 * 
 */
export type WhatsAppSession = $Result.DefaultSelection<Prisma.$WhatsAppSessionPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TransactionWhatsappService
 * 
 */
export type TransactionWhatsappService = $Result.DefaultSelection<Prisma.$TransactionWhatsappServicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model WhatsappApiPackage
 * 
 */
export type WhatsappApiPackage = $Result.DefaultSelection<Prisma.$WhatsappApiPackagePayload>
/**
 * Model ServicesWhatsappCustomers
 * 
 */
export type ServicesWhatsappCustomers = $Result.DefaultSelection<Prisma.$ServicesWhatsappCustomersPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model Voucher
 * 
 */
export type Voucher = $Result.DefaultSelection<Prisma.$VoucherPayload>
/**
 * Model VoucherUsage
 * 
 */
export type VoucherUsage = $Result.DefaultSelection<Prisma.$VoucherUsagePayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model BankDetail
 * 
 */
export type BankDetail = $Result.DefaultSelection<Prisma.$BankDetailPayload>
/**
 * Model WhatsAppCampaign
 * 
 */
export type WhatsAppCampaign = $Result.DefaultSelection<Prisma.$WhatsAppCampaignPayload>
/**
 * Model WhatsAppBulkCampaign
 * 
 */
export type WhatsAppBulkCampaign = $Result.DefaultSelection<Prisma.$WhatsAppBulkCampaignPayload>
/**
 * Model WhatsAppBulkCampaignItem
 * 
 */
export type WhatsAppBulkCampaignItem = $Result.DefaultSelection<Prisma.$WhatsAppBulkCampaignItemPayload>
/**
 * Model WhatsAppContact
 * 
 */
export type WhatsAppContact = $Result.DefaultSelection<Prisma.$WhatsAppContactPayload>
/**
 * Model WhatsAppMessageStats
 * 
 */
export type WhatsAppMessageStats = $Result.DefaultSelection<Prisma.$WhatsAppMessageStatsPayload>
/**
 * Model WhatsAppAIBot
 * 
 */
export type WhatsAppAIBot = $Result.DefaultSelection<Prisma.$WhatsAppAIBotPayload>
/**
 * Model AIDocument
 * 
 */
export type AIDocument = $Result.DefaultSelection<Prisma.$AIDocumentPayload>
/**
 * Model AIUsageLog
 * 
 */
export type AIUsageLog = $Result.DefaultSelection<Prisma.$AIUsageLogPayload>
/**
 * Model AIBotSessionBinding
 * 
 */
export type AIBotSessionBinding = $Result.DefaultSelection<Prisma.$AIBotSessionBindingPayload>
/**
 * Model BotKnowledgeBinding
 * 
 */
export type BotKnowledgeBinding = $Result.DefaultSelection<Prisma.$BotKnowledgeBindingPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppSession`: Exposes CRUD operations for the **WhatsAppSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppSessions
    * const whatsAppSessions = await prisma.whatsAppSession.findMany()
    * ```
    */
  get whatsAppSession(): Prisma.WhatsAppSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionWhatsappService`: Exposes CRUD operations for the **TransactionWhatsappService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionWhatsappServices
    * const transactionWhatsappServices = await prisma.transactionWhatsappService.findMany()
    * ```
    */
  get transactionWhatsappService(): Prisma.TransactionWhatsappServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsappApiPackage`: Exposes CRUD operations for the **WhatsappApiPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsappApiPackages
    * const whatsappApiPackages = await prisma.whatsappApiPackage.findMany()
    * ```
    */
  get whatsappApiPackage(): Prisma.WhatsappApiPackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicesWhatsappCustomers`: Exposes CRUD operations for the **ServicesWhatsappCustomers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicesWhatsappCustomers
    * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findMany()
    * ```
    */
  get servicesWhatsappCustomers(): Prisma.ServicesWhatsappCustomersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucher`: Exposes CRUD operations for the **Voucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vouchers
    * const vouchers = await prisma.voucher.findMany()
    * ```
    */
  get voucher(): Prisma.VoucherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucherUsage`: Exposes CRUD operations for the **VoucherUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoucherUsages
    * const voucherUsages = await prisma.voucherUsage.findMany()
    * ```
    */
  get voucherUsage(): Prisma.VoucherUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankDetail`: Exposes CRUD operations for the **BankDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankDetails
    * const bankDetails = await prisma.bankDetail.findMany()
    * ```
    */
  get bankDetail(): Prisma.BankDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppCampaign`: Exposes CRUD operations for the **WhatsAppCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppCampaigns
    * const whatsAppCampaigns = await prisma.whatsAppCampaign.findMany()
    * ```
    */
  get whatsAppCampaign(): Prisma.WhatsAppCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppBulkCampaign`: Exposes CRUD operations for the **WhatsAppBulkCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppBulkCampaigns
    * const whatsAppBulkCampaigns = await prisma.whatsAppBulkCampaign.findMany()
    * ```
    */
  get whatsAppBulkCampaign(): Prisma.WhatsAppBulkCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppBulkCampaignItem`: Exposes CRUD operations for the **WhatsAppBulkCampaignItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppBulkCampaignItems
    * const whatsAppBulkCampaignItems = await prisma.whatsAppBulkCampaignItem.findMany()
    * ```
    */
  get whatsAppBulkCampaignItem(): Prisma.WhatsAppBulkCampaignItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppContact`: Exposes CRUD operations for the **WhatsAppContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppContacts
    * const whatsAppContacts = await prisma.whatsAppContact.findMany()
    * ```
    */
  get whatsAppContact(): Prisma.WhatsAppContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppMessageStats`: Exposes CRUD operations for the **WhatsAppMessageStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppMessageStats
    * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findMany()
    * ```
    */
  get whatsAppMessageStats(): Prisma.WhatsAppMessageStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppAIBot`: Exposes CRUD operations for the **WhatsAppAIBot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppAIBots
    * const whatsAppAIBots = await prisma.whatsAppAIBot.findMany()
    * ```
    */
  get whatsAppAIBot(): Prisma.WhatsAppAIBotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIDocument`: Exposes CRUD operations for the **AIDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIDocuments
    * const aIDocuments = await prisma.aIDocument.findMany()
    * ```
    */
  get aIDocument(): Prisma.AIDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIUsageLog`: Exposes CRUD operations for the **AIUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIUsageLogs
    * const aIUsageLogs = await prisma.aIUsageLog.findMany()
    * ```
    */
  get aIUsageLog(): Prisma.AIUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIBotSessionBinding`: Exposes CRUD operations for the **AIBotSessionBinding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIBotSessionBindings
    * const aIBotSessionBindings = await prisma.aIBotSessionBinding.findMany()
    * ```
    */
  get aIBotSessionBinding(): Prisma.AIBotSessionBindingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.botKnowledgeBinding`: Exposes CRUD operations for the **BotKnowledgeBinding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotKnowledgeBindings
    * const botKnowledgeBindings = await prisma.botKnowledgeBinding.findMany()
    * ```
    */
  get botKnowledgeBinding(): Prisma.BotKnowledgeBindingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    WhatsAppSession: 'WhatsAppSession',
    Transaction: 'Transaction',
    TransactionWhatsappService: 'TransactionWhatsappService',
    Payment: 'Payment',
    WhatsappApiPackage: 'WhatsappApiPackage',
    ServicesWhatsappCustomers: 'ServicesWhatsappCustomers',
    UserSession: 'UserSession',
    Voucher: 'Voucher',
    VoucherUsage: 'VoucherUsage',
    PaymentMethod: 'PaymentMethod',
    BankDetail: 'BankDetail',
    WhatsAppCampaign: 'WhatsAppCampaign',
    WhatsAppBulkCampaign: 'WhatsAppBulkCampaign',
    WhatsAppBulkCampaignItem: 'WhatsAppBulkCampaignItem',
    WhatsAppContact: 'WhatsAppContact',
    WhatsAppMessageStats: 'WhatsAppMessageStats',
    WhatsAppAIBot: 'WhatsAppAIBot',
    AIDocument: 'AIDocument',
    AIUsageLog: 'AIUsageLog',
    AIBotSessionBinding: 'AIBotSessionBinding',
    BotKnowledgeBinding: 'BotKnowledgeBinding'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "whatsAppSession" | "transaction" | "transactionWhatsappService" | "payment" | "whatsappApiPackage" | "servicesWhatsappCustomers" | "userSession" | "voucher" | "voucherUsage" | "paymentMethod" | "bankDetail" | "whatsAppCampaign" | "whatsAppBulkCampaign" | "whatsAppBulkCampaignItem" | "whatsAppContact" | "whatsAppMessageStats" | "whatsAppAIBot" | "aIDocument" | "aIUsageLog" | "aIBotSessionBinding" | "botKnowledgeBinding"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppSession: {
        payload: Prisma.$WhatsAppSessionPayload<ExtArgs>
        fields: Prisma.WhatsAppSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          findMany: {
            args: Prisma.WhatsAppSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>[]
          }
          create: {
            args: Prisma.WhatsAppSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          createMany: {
            args: Prisma.WhatsAppSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          update: {
            args: Prisma.WhatsAppSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppSession>
          }
          groupBy: {
            args: Prisma.WhatsAppSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppSessionCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppSessionCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TransactionWhatsappService: {
        payload: Prisma.$TransactionWhatsappServicePayload<ExtArgs>
        fields: Prisma.TransactionWhatsappServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionWhatsappServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionWhatsappServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          findFirst: {
            args: Prisma.TransactionWhatsappServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionWhatsappServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          findMany: {
            args: Prisma.TransactionWhatsappServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>[]
          }
          create: {
            args: Prisma.TransactionWhatsappServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          createMany: {
            args: Prisma.TransactionWhatsappServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionWhatsappServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>[]
          }
          delete: {
            args: Prisma.TransactionWhatsappServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          update: {
            args: Prisma.TransactionWhatsappServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          deleteMany: {
            args: Prisma.TransactionWhatsappServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionWhatsappServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionWhatsappServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>[]
          }
          upsert: {
            args: Prisma.TransactionWhatsappServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          aggregate: {
            args: Prisma.TransactionWhatsappServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionWhatsappService>
          }
          groupBy: {
            args: Prisma.TransactionWhatsappServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionWhatsappServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionWhatsappServiceCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionWhatsappServiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      WhatsappApiPackage: {
        payload: Prisma.$WhatsappApiPackagePayload<ExtArgs>
        fields: Prisma.WhatsappApiPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsappApiPackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsappApiPackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          findFirst: {
            args: Prisma.WhatsappApiPackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsappApiPackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          findMany: {
            args: Prisma.WhatsappApiPackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>[]
          }
          create: {
            args: Prisma.WhatsappApiPackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          createMany: {
            args: Prisma.WhatsappApiPackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsappApiPackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>[]
          }
          delete: {
            args: Prisma.WhatsappApiPackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          update: {
            args: Prisma.WhatsappApiPackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          deleteMany: {
            args: Prisma.WhatsappApiPackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsappApiPackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsappApiPackageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>[]
          }
          upsert: {
            args: Prisma.WhatsappApiPackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          aggregate: {
            args: Prisma.WhatsappApiPackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsappApiPackage>
          }
          groupBy: {
            args: Prisma.WhatsappApiPackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsappApiPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsappApiPackageCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsappApiPackageCountAggregateOutputType> | number
          }
        }
      }
      ServicesWhatsappCustomers: {
        payload: Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>
        fields: Prisma.ServicesWhatsappCustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicesWhatsappCustomersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicesWhatsappCustomersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          findFirst: {
            args: Prisma.ServicesWhatsappCustomersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicesWhatsappCustomersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          findMany: {
            args: Prisma.ServicesWhatsappCustomersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>[]
          }
          create: {
            args: Prisma.ServicesWhatsappCustomersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          createMany: {
            args: Prisma.ServicesWhatsappCustomersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicesWhatsappCustomersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>[]
          }
          delete: {
            args: Prisma.ServicesWhatsappCustomersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          update: {
            args: Prisma.ServicesWhatsappCustomersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          deleteMany: {
            args: Prisma.ServicesWhatsappCustomersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicesWhatsappCustomersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicesWhatsappCustomersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>[]
          }
          upsert: {
            args: Prisma.ServicesWhatsappCustomersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          aggregate: {
            args: Prisma.ServicesWhatsappCustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicesWhatsappCustomers>
          }
          groupBy: {
            args: Prisma.ServicesWhatsappCustomersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicesWhatsappCustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicesWhatsappCustomersCountArgs<ExtArgs>
            result: $Utils.Optional<ServicesWhatsappCustomersCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      Voucher: {
        payload: Prisma.$VoucherPayload<ExtArgs>
        fields: Prisma.VoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findFirst: {
            args: Prisma.VoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findMany: {
            args: Prisma.VoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          create: {
            args: Prisma.VoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          createMany: {
            args: Prisma.VoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          delete: {
            args: Prisma.VoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          update: {
            args: Prisma.VoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          deleteMany: {
            args: Prisma.VoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          upsert: {
            args: Prisma.VoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          aggregate: {
            args: Prisma.VoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucher>
          }
          groupBy: {
            args: Prisma.VoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherCountAggregateOutputType> | number
          }
        }
      }
      VoucherUsage: {
        payload: Prisma.$VoucherUsagePayload<ExtArgs>
        fields: Prisma.VoucherUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          findFirst: {
            args: Prisma.VoucherUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          findMany: {
            args: Prisma.VoucherUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>[]
          }
          create: {
            args: Prisma.VoucherUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          createMany: {
            args: Prisma.VoucherUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>[]
          }
          delete: {
            args: Prisma.VoucherUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          update: {
            args: Prisma.VoucherUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          deleteMany: {
            args: Prisma.VoucherUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>[]
          }
          upsert: {
            args: Prisma.VoucherUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          aggregate: {
            args: Prisma.VoucherUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucherUsage>
          }
          groupBy: {
            args: Prisma.VoucherUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherUsageCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherUsageCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      BankDetail: {
        payload: Prisma.$BankDetailPayload<ExtArgs>
        fields: Prisma.BankDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          findFirst: {
            args: Prisma.BankDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          findMany: {
            args: Prisma.BankDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          create: {
            args: Prisma.BankDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          createMany: {
            args: Prisma.BankDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          delete: {
            args: Prisma.BankDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          update: {
            args: Prisma.BankDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          deleteMany: {
            args: Prisma.BankDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          upsert: {
            args: Prisma.BankDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          aggregate: {
            args: Prisma.BankDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankDetail>
          }
          groupBy: {
            args: Prisma.BankDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankDetailCountArgs<ExtArgs>
            result: $Utils.Optional<BankDetailCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppCampaign: {
        payload: Prisma.$WhatsAppCampaignPayload<ExtArgs>
        fields: Prisma.WhatsAppCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          findMany: {
            args: Prisma.WhatsAppCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>[]
          }
          create: {
            args: Prisma.WhatsAppCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          createMany: {
            args: Prisma.WhatsAppCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          update: {
            args: Prisma.WhatsAppCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCampaignPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppCampaign>
          }
          groupBy: {
            args: Prisma.WhatsAppCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppCampaignCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppBulkCampaign: {
        payload: Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>
        fields: Prisma.WhatsAppBulkCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppBulkCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppBulkCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppBulkCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppBulkCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload>
          }
          findMany: {
            args: Prisma.WhatsAppBulkCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload>[]
          }
          create: {
            args: Prisma.WhatsAppBulkCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload>
          }
          createMany: {
            args: Prisma.WhatsAppBulkCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppBulkCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppBulkCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload>
          }
          update: {
            args: Prisma.WhatsAppBulkCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppBulkCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppBulkCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppBulkCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppBulkCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppBulkCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppBulkCampaign>
          }
          groupBy: {
            args: Prisma.WhatsAppBulkCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppBulkCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppBulkCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppBulkCampaignCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppBulkCampaignItem: {
        payload: Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>
        fields: Prisma.WhatsAppBulkCampaignItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppBulkCampaignItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppBulkCampaignItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppBulkCampaignItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppBulkCampaignItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload>
          }
          findMany: {
            args: Prisma.WhatsAppBulkCampaignItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload>[]
          }
          create: {
            args: Prisma.WhatsAppBulkCampaignItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload>
          }
          createMany: {
            args: Prisma.WhatsAppBulkCampaignItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppBulkCampaignItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppBulkCampaignItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload>
          }
          update: {
            args: Prisma.WhatsAppBulkCampaignItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppBulkCampaignItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppBulkCampaignItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppBulkCampaignItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppBulkCampaignItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppBulkCampaignItemPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppBulkCampaignItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppBulkCampaignItem>
          }
          groupBy: {
            args: Prisma.WhatsAppBulkCampaignItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppBulkCampaignItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppBulkCampaignItemCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppBulkCampaignItemCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppContact: {
        payload: Prisma.$WhatsAppContactPayload<ExtArgs>
        fields: Prisma.WhatsAppContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          findMany: {
            args: Prisma.WhatsAppContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>[]
          }
          create: {
            args: Prisma.WhatsAppContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          createMany: {
            args: Prisma.WhatsAppContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          update: {
            args: Prisma.WhatsAppContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppContact>
          }
          groupBy: {
            args: Prisma.WhatsAppContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppContactCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppContactCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppMessageStats: {
        payload: Prisma.$WhatsAppMessageStatsPayload<ExtArgs>
        fields: Prisma.WhatsAppMessageStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppMessageStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppMessageStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppMessageStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppMessageStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          findMany: {
            args: Prisma.WhatsAppMessageStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>[]
          }
          create: {
            args: Prisma.WhatsAppMessageStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          createMany: {
            args: Prisma.WhatsAppMessageStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppMessageStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppMessageStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          update: {
            args: Prisma.WhatsAppMessageStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppMessageStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppMessageStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppMessageStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppMessageStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppMessageStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppMessageStats>
          }
          groupBy: {
            args: Prisma.WhatsAppMessageStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppMessageStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppMessageStatsCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppMessageStatsCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppAIBot: {
        payload: Prisma.$WhatsAppAIBotPayload<ExtArgs>
        fields: Prisma.WhatsAppAIBotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppAIBotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppAIBotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppAIBotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppAIBotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload>
          }
          findMany: {
            args: Prisma.WhatsAppAIBotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload>[]
          }
          create: {
            args: Prisma.WhatsAppAIBotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload>
          }
          createMany: {
            args: Prisma.WhatsAppAIBotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppAIBotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppAIBotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload>
          }
          update: {
            args: Prisma.WhatsAppAIBotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppAIBotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppAIBotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppAIBotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppAIBotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppAIBotPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppAIBotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppAIBot>
          }
          groupBy: {
            args: Prisma.WhatsAppAIBotGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppAIBotGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppAIBotCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppAIBotCountAggregateOutputType> | number
          }
        }
      }
      AIDocument: {
        payload: Prisma.$AIDocumentPayload<ExtArgs>
        fields: Prisma.AIDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload>
          }
          findFirst: {
            args: Prisma.AIDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload>
          }
          findMany: {
            args: Prisma.AIDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload>[]
          }
          create: {
            args: Prisma.AIDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload>
          }
          createMany: {
            args: Prisma.AIDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload>[]
          }
          delete: {
            args: Prisma.AIDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload>
          }
          update: {
            args: Prisma.AIDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload>
          }
          deleteMany: {
            args: Prisma.AIDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload>[]
          }
          upsert: {
            args: Prisma.AIDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDocumentPayload>
          }
          aggregate: {
            args: Prisma.AIDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIDocument>
          }
          groupBy: {
            args: Prisma.AIDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<AIDocumentCountAggregateOutputType> | number
          }
        }
      }
      AIUsageLog: {
        payload: Prisma.$AIUsageLogPayload<ExtArgs>
        fields: Prisma.AIUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          findFirst: {
            args: Prisma.AIUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          findMany: {
            args: Prisma.AIUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          create: {
            args: Prisma.AIUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          createMany: {
            args: Prisma.AIUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          delete: {
            args: Prisma.AIUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          update: {
            args: Prisma.AIUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.AIUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.AIUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          aggregate: {
            args: Prisma.AIUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIUsageLog>
          }
          groupBy: {
            args: Prisma.AIUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<AIUsageLogCountAggregateOutputType> | number
          }
        }
      }
      AIBotSessionBinding: {
        payload: Prisma.$AIBotSessionBindingPayload<ExtArgs>
        fields: Prisma.AIBotSessionBindingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIBotSessionBindingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIBotSessionBindingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload>
          }
          findFirst: {
            args: Prisma.AIBotSessionBindingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIBotSessionBindingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload>
          }
          findMany: {
            args: Prisma.AIBotSessionBindingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload>[]
          }
          create: {
            args: Prisma.AIBotSessionBindingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload>
          }
          createMany: {
            args: Prisma.AIBotSessionBindingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIBotSessionBindingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload>[]
          }
          delete: {
            args: Prisma.AIBotSessionBindingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload>
          }
          update: {
            args: Prisma.AIBotSessionBindingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload>
          }
          deleteMany: {
            args: Prisma.AIBotSessionBindingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIBotSessionBindingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIBotSessionBindingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload>[]
          }
          upsert: {
            args: Prisma.AIBotSessionBindingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIBotSessionBindingPayload>
          }
          aggregate: {
            args: Prisma.AIBotSessionBindingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIBotSessionBinding>
          }
          groupBy: {
            args: Prisma.AIBotSessionBindingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIBotSessionBindingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIBotSessionBindingCountArgs<ExtArgs>
            result: $Utils.Optional<AIBotSessionBindingCountAggregateOutputType> | number
          }
        }
      }
      BotKnowledgeBinding: {
        payload: Prisma.$BotKnowledgeBindingPayload<ExtArgs>
        fields: Prisma.BotKnowledgeBindingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotKnowledgeBindingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotKnowledgeBindingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload>
          }
          findFirst: {
            args: Prisma.BotKnowledgeBindingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotKnowledgeBindingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload>
          }
          findMany: {
            args: Prisma.BotKnowledgeBindingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload>[]
          }
          create: {
            args: Prisma.BotKnowledgeBindingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload>
          }
          createMany: {
            args: Prisma.BotKnowledgeBindingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotKnowledgeBindingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload>[]
          }
          delete: {
            args: Prisma.BotKnowledgeBindingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload>
          }
          update: {
            args: Prisma.BotKnowledgeBindingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload>
          }
          deleteMany: {
            args: Prisma.BotKnowledgeBindingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotKnowledgeBindingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotKnowledgeBindingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload>[]
          }
          upsert: {
            args: Prisma.BotKnowledgeBindingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotKnowledgeBindingPayload>
          }
          aggregate: {
            args: Prisma.BotKnowledgeBindingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBotKnowledgeBinding>
          }
          groupBy: {
            args: Prisma.BotKnowledgeBindingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotKnowledgeBindingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotKnowledgeBindingCountArgs<ExtArgs>
            result: $Utils.Optional<BotKnowledgeBindingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    whatsAppSession?: WhatsAppSessionOmit
    transaction?: TransactionOmit
    transactionWhatsappService?: TransactionWhatsappServiceOmit
    payment?: PaymentOmit
    whatsappApiPackage?: WhatsappApiPackageOmit
    servicesWhatsappCustomers?: ServicesWhatsappCustomersOmit
    userSession?: UserSessionOmit
    voucher?: VoucherOmit
    voucherUsage?: VoucherUsageOmit
    paymentMethod?: PaymentMethodOmit
    bankDetail?: BankDetailOmit
    whatsAppCampaign?: WhatsAppCampaignOmit
    whatsAppBulkCampaign?: WhatsAppBulkCampaignOmit
    whatsAppBulkCampaignItem?: WhatsAppBulkCampaignItemOmit
    whatsAppContact?: WhatsAppContactOmit
    whatsAppMessageStats?: WhatsAppMessageStatsOmit
    whatsAppAIBot?: WhatsAppAIBotOmit
    aIDocument?: AIDocumentOmit
    aIUsageLog?: AIUsageLogOmit
    aIBotSessionBinding?: AIBotSessionBindingOmit
    botKnowledgeBinding?: BotKnowledgeBindingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    whatsappCustomers: number
    transactions: number
    userSessions: number
    voucherUsage: number
    WhatsAppBulkCampaigns: number
    WhatsAppCampaigns: number
    WhatsAppContact: number
    whatsAppSessions: number
    whatsAppMessageStats: number
    whatsAppAIBots: number
    aiDocuments: number
    aiUsageLogs: number
    aiBotSessionBindings: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsappCustomers?: boolean | UserCountOutputTypeCountWhatsappCustomersArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    userSessions?: boolean | UserCountOutputTypeCountUserSessionsArgs
    voucherUsage?: boolean | UserCountOutputTypeCountVoucherUsageArgs
    WhatsAppBulkCampaigns?: boolean | UserCountOutputTypeCountWhatsAppBulkCampaignsArgs
    WhatsAppCampaigns?: boolean | UserCountOutputTypeCountWhatsAppCampaignsArgs
    WhatsAppContact?: boolean | UserCountOutputTypeCountWhatsAppContactArgs
    whatsAppSessions?: boolean | UserCountOutputTypeCountWhatsAppSessionsArgs
    whatsAppMessageStats?: boolean | UserCountOutputTypeCountWhatsAppMessageStatsArgs
    whatsAppAIBots?: boolean | UserCountOutputTypeCountWhatsAppAIBotsArgs
    aiDocuments?: boolean | UserCountOutputTypeCountAiDocumentsArgs
    aiUsageLogs?: boolean | UserCountOutputTypeCountAiUsageLogsArgs
    aiBotSessionBindings?: boolean | UserCountOutputTypeCountAiBotSessionBindingsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsappCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhatsappCustomersWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVoucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsAppBulkCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppBulkCampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsAppCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppCampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsAppContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsAppSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsAppMessageStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageStatsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsAppAIBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppAIBotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiBotSessionBindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIBotSessionBindingWhereInput
  }


  /**
   * Count Type WhatsAppSessionCountOutputType
   */

  export type WhatsAppSessionCountOutputType = {
    whatsAppMessageStats: number
    aiBotSessionBindings: number
  }

  export type WhatsAppSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsAppMessageStats?: boolean | WhatsAppSessionCountOutputTypeCountWhatsAppMessageStatsArgs
    aiBotSessionBindings?: boolean | WhatsAppSessionCountOutputTypeCountAiBotSessionBindingsArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppSessionCountOutputType without action
   */
  export type WhatsAppSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSessionCountOutputType
     */
    select?: WhatsAppSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppSessionCountOutputType without action
   */
  export type WhatsAppSessionCountOutputTypeCountWhatsAppMessageStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageStatsWhereInput
  }

  /**
   * WhatsAppSessionCountOutputType without action
   */
  export type WhatsAppSessionCountOutputTypeCountAiBotSessionBindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIBotSessionBindingWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    voucherUsage: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voucherUsage?: boolean | TransactionCountOutputTypeCountVoucherUsageArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountVoucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
  }


  /**
   * Count Type WhatsappApiPackageCountOutputType
   */

  export type WhatsappApiPackageCountOutputType = {
    whatsappCustomers: number
    whatsappTransactions: number
  }

  export type WhatsappApiPackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsappCustomers?: boolean | WhatsappApiPackageCountOutputTypeCountWhatsappCustomersArgs
    whatsappTransactions?: boolean | WhatsappApiPackageCountOutputTypeCountWhatsappTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WhatsappApiPackageCountOutputType without action
   */
  export type WhatsappApiPackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackageCountOutputType
     */
    select?: WhatsappApiPackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsappApiPackageCountOutputType without action
   */
  export type WhatsappApiPackageCountOutputTypeCountWhatsappCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhatsappCustomersWhereInput
  }

  /**
   * WhatsappApiPackageCountOutputType without action
   */
  export type WhatsappApiPackageCountOutputTypeCountWhatsappTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhatsappServiceWhereInput
  }


  /**
   * Count Type VoucherCountOutputType
   */

  export type VoucherCountOutputType = {
    transactions: number
    voucherUsage: number
  }

  export type VoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | VoucherCountOutputTypeCountTransactionsArgs
    voucherUsage?: boolean | VoucherCountOutputTypeCountVoucherUsageArgs
  }

  // Custom InputTypes
  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherCountOutputType
     */
    select?: VoucherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountVoucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
  }


  /**
   * Count Type BankDetailCountOutputType
   */

  export type BankDetailCountOutputType = {
    paymentMethods: number
  }

  export type BankDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentMethods?: boolean | BankDetailCountOutputTypeCountPaymentMethodsArgs
  }

  // Custom InputTypes
  /**
   * BankDetailCountOutputType without action
   */
  export type BankDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetailCountOutputType
     */
    select?: BankDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BankDetailCountOutputType without action
   */
  export type BankDetailCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
  }


  /**
   * Count Type WhatsAppCampaignCountOutputType
   */

  export type WhatsAppCampaignCountOutputType = {
    WhatsAppBulkCampaigns: number
  }

  export type WhatsAppCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatsAppBulkCampaigns?: boolean | WhatsAppCampaignCountOutputTypeCountWhatsAppBulkCampaignsArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppCampaignCountOutputType without action
   */
  export type WhatsAppCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaignCountOutputType
     */
    select?: WhatsAppCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppCampaignCountOutputType without action
   */
  export type WhatsAppCampaignCountOutputTypeCountWhatsAppBulkCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppBulkCampaignWhereInput
  }


  /**
   * Count Type WhatsAppBulkCampaignCountOutputType
   */

  export type WhatsAppBulkCampaignCountOutputType = {
    WhatsAppBulkCampaignItems: number
  }

  export type WhatsAppBulkCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatsAppBulkCampaignItems?: boolean | WhatsAppBulkCampaignCountOutputTypeCountWhatsAppBulkCampaignItemsArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppBulkCampaignCountOutputType without action
   */
  export type WhatsAppBulkCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignCountOutputType
     */
    select?: WhatsAppBulkCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppBulkCampaignCountOutputType without action
   */
  export type WhatsAppBulkCampaignCountOutputTypeCountWhatsAppBulkCampaignItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppBulkCampaignItemWhereInput
  }


  /**
   * Count Type WhatsAppAIBotCountOutputType
   */

  export type WhatsAppAIBotCountOutputType = {
    aiBotSessionBindings: number
    botKnowledgeBindings: number
  }

  export type WhatsAppAIBotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiBotSessionBindings?: boolean | WhatsAppAIBotCountOutputTypeCountAiBotSessionBindingsArgs
    botKnowledgeBindings?: boolean | WhatsAppAIBotCountOutputTypeCountBotKnowledgeBindingsArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppAIBotCountOutputType without action
   */
  export type WhatsAppAIBotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBotCountOutputType
     */
    select?: WhatsAppAIBotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppAIBotCountOutputType without action
   */
  export type WhatsAppAIBotCountOutputTypeCountAiBotSessionBindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIBotSessionBindingWhereInput
  }

  /**
   * WhatsAppAIBotCountOutputType without action
   */
  export type WhatsAppAIBotCountOutputTypeCountBotKnowledgeBindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotKnowledgeBindingWhereInput
  }


  /**
   * Count Type AIDocumentCountOutputType
   */

  export type AIDocumentCountOutputType = {
    botKnowledgeBindings: number
  }

  export type AIDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    botKnowledgeBindings?: boolean | AIDocumentCountOutputTypeCountBotKnowledgeBindingsArgs
  }

  // Custom InputTypes
  /**
   * AIDocumentCountOutputType without action
   */
  export type AIDocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocumentCountOutputType
     */
    select?: AIDocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIDocumentCountOutputType without action
   */
  export type AIDocumentCountOutputTypeCountBotKnowledgeBindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotKnowledgeBindingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    otp: string | null
    otpExpires: Date | null
    otpVerificationDeadline: Date | null
    emailVerified: Date | null
    phoneVerified: Date | null
    image: string | null
    emailVerificationToken: string | null
    emailVerificationTokenExpires: Date | null
    role: string | null
    apiKey: string | null
    updatedAt: Date | null
    emailOtp: string | null
    emailOtpExpires: Date | null
    resetPasswordOtp: string | null
    resetPasswordOtpExpires: Date | null
    resetPasswordLastRequestAt: Date | null
    ssoOtp: string | null
    ssoOtpExpires: Date | null
    ssoLastRequestAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    otp: string | null
    otpExpires: Date | null
    otpVerificationDeadline: Date | null
    emailVerified: Date | null
    phoneVerified: Date | null
    image: string | null
    emailVerificationToken: string | null
    emailVerificationTokenExpires: Date | null
    role: string | null
    apiKey: string | null
    updatedAt: Date | null
    emailOtp: string | null
    emailOtpExpires: Date | null
    resetPasswordOtp: string | null
    resetPasswordOtpExpires: Date | null
    resetPasswordLastRequestAt: Date | null
    ssoOtp: string | null
    ssoOtpExpires: Date | null
    ssoLastRequestAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    password: number
    otp: number
    otpExpires: number
    otpVerificationDeadline: number
    emailVerified: number
    phoneVerified: number
    image: number
    emailVerificationToken: number
    emailVerificationTokenExpires: number
    role: number
    apiKey: number
    updatedAt: number
    emailOtp: number
    emailOtpExpires: number
    resetPasswordOtp: number
    resetPasswordOtpExpires: number
    resetPasswordLastRequestAt: number
    ssoOtp: number
    ssoOtpExpires: number
    ssoLastRequestAt: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    otp?: true
    otpExpires?: true
    otpVerificationDeadline?: true
    emailVerified?: true
    phoneVerified?: true
    image?: true
    emailVerificationToken?: true
    emailVerificationTokenExpires?: true
    role?: true
    apiKey?: true
    updatedAt?: true
    emailOtp?: true
    emailOtpExpires?: true
    resetPasswordOtp?: true
    resetPasswordOtpExpires?: true
    resetPasswordLastRequestAt?: true
    ssoOtp?: true
    ssoOtpExpires?: true
    ssoLastRequestAt?: true
    isActive?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    otp?: true
    otpExpires?: true
    otpVerificationDeadline?: true
    emailVerified?: true
    phoneVerified?: true
    image?: true
    emailVerificationToken?: true
    emailVerificationTokenExpires?: true
    role?: true
    apiKey?: true
    updatedAt?: true
    emailOtp?: true
    emailOtpExpires?: true
    resetPasswordOtp?: true
    resetPasswordOtpExpires?: true
    resetPasswordLastRequestAt?: true
    ssoOtp?: true
    ssoOtpExpires?: true
    ssoLastRequestAt?: true
    isActive?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    otp?: true
    otpExpires?: true
    otpVerificationDeadline?: true
    emailVerified?: true
    phoneVerified?: true
    image?: true
    emailVerificationToken?: true
    emailVerificationTokenExpires?: true
    role?: true
    apiKey?: true
    updatedAt?: true
    emailOtp?: true
    emailOtpExpires?: true
    resetPasswordOtp?: true
    resetPasswordOtpExpires?: true
    resetPasswordLastRequestAt?: true
    ssoOtp?: true
    ssoOtpExpires?: true
    ssoLastRequestAt?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    otp: string | null
    otpExpires: Date | null
    otpVerificationDeadline: Date | null
    emailVerified: Date | null
    phoneVerified: Date | null
    image: string | null
    emailVerificationToken: string | null
    emailVerificationTokenExpires: Date | null
    role: string
    apiKey: string | null
    updatedAt: Date | null
    emailOtp: string | null
    emailOtpExpires: Date | null
    resetPasswordOtp: string | null
    resetPasswordOtpExpires: Date | null
    resetPasswordLastRequestAt: Date | null
    ssoOtp: string | null
    ssoOtpExpires: Date | null
    ssoLastRequestAt: Date | null
    isActive: boolean
    createdAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    otp?: boolean
    otpExpires?: boolean
    otpVerificationDeadline?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    image?: boolean
    emailVerificationToken?: boolean
    emailVerificationTokenExpires?: boolean
    role?: boolean
    apiKey?: boolean
    updatedAt?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
    resetPasswordOtp?: boolean
    resetPasswordOtpExpires?: boolean
    resetPasswordLastRequestAt?: boolean
    ssoOtp?: boolean
    ssoOtpExpires?: boolean
    ssoLastRequestAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    whatsappCustomers?: boolean | User$whatsappCustomersArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    userSessions?: boolean | User$userSessionsArgs<ExtArgs>
    voucherUsage?: boolean | User$voucherUsageArgs<ExtArgs>
    WhatsAppBulkCampaigns?: boolean | User$WhatsAppBulkCampaignsArgs<ExtArgs>
    WhatsAppCampaigns?: boolean | User$WhatsAppCampaignsArgs<ExtArgs>
    WhatsAppContact?: boolean | User$WhatsAppContactArgs<ExtArgs>
    whatsAppSessions?: boolean | User$whatsAppSessionsArgs<ExtArgs>
    whatsAppMessageStats?: boolean | User$whatsAppMessageStatsArgs<ExtArgs>
    whatsAppAIBots?: boolean | User$whatsAppAIBotsArgs<ExtArgs>
    aiDocuments?: boolean | User$aiDocumentsArgs<ExtArgs>
    aiUsageLogs?: boolean | User$aiUsageLogsArgs<ExtArgs>
    aiBotSessionBindings?: boolean | User$aiBotSessionBindingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    otp?: boolean
    otpExpires?: boolean
    otpVerificationDeadline?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    image?: boolean
    emailVerificationToken?: boolean
    emailVerificationTokenExpires?: boolean
    role?: boolean
    apiKey?: boolean
    updatedAt?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
    resetPasswordOtp?: boolean
    resetPasswordOtpExpires?: boolean
    resetPasswordLastRequestAt?: boolean
    ssoOtp?: boolean
    ssoOtpExpires?: boolean
    ssoLastRequestAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    otp?: boolean
    otpExpires?: boolean
    otpVerificationDeadline?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    image?: boolean
    emailVerificationToken?: boolean
    emailVerificationTokenExpires?: boolean
    role?: boolean
    apiKey?: boolean
    updatedAt?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
    resetPasswordOtp?: boolean
    resetPasswordOtpExpires?: boolean
    resetPasswordLastRequestAt?: boolean
    ssoOtp?: boolean
    ssoOtpExpires?: boolean
    ssoLastRequestAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    otp?: boolean
    otpExpires?: boolean
    otpVerificationDeadline?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    image?: boolean
    emailVerificationToken?: boolean
    emailVerificationTokenExpires?: boolean
    role?: boolean
    apiKey?: boolean
    updatedAt?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
    resetPasswordOtp?: boolean
    resetPasswordOtpExpires?: boolean
    resetPasswordLastRequestAt?: boolean
    ssoOtp?: boolean
    ssoOtpExpires?: boolean
    ssoLastRequestAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "password" | "otp" | "otpExpires" | "otpVerificationDeadline" | "emailVerified" | "phoneVerified" | "image" | "emailVerificationToken" | "emailVerificationTokenExpires" | "role" | "apiKey" | "updatedAt" | "emailOtp" | "emailOtpExpires" | "resetPasswordOtp" | "resetPasswordOtpExpires" | "resetPasswordLastRequestAt" | "ssoOtp" | "ssoOtpExpires" | "ssoLastRequestAt" | "isActive" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsappCustomers?: boolean | User$whatsappCustomersArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    userSessions?: boolean | User$userSessionsArgs<ExtArgs>
    voucherUsage?: boolean | User$voucherUsageArgs<ExtArgs>
    WhatsAppBulkCampaigns?: boolean | User$WhatsAppBulkCampaignsArgs<ExtArgs>
    WhatsAppCampaigns?: boolean | User$WhatsAppCampaignsArgs<ExtArgs>
    WhatsAppContact?: boolean | User$WhatsAppContactArgs<ExtArgs>
    whatsAppSessions?: boolean | User$whatsAppSessionsArgs<ExtArgs>
    whatsAppMessageStats?: boolean | User$whatsAppMessageStatsArgs<ExtArgs>
    whatsAppAIBots?: boolean | User$whatsAppAIBotsArgs<ExtArgs>
    aiDocuments?: boolean | User$aiDocumentsArgs<ExtArgs>
    aiUsageLogs?: boolean | User$aiUsageLogsArgs<ExtArgs>
    aiBotSessionBindings?: boolean | User$aiBotSessionBindingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      whatsappCustomers: Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      userSessions: Prisma.$UserSessionPayload<ExtArgs>[]
      voucherUsage: Prisma.$VoucherUsagePayload<ExtArgs>[]
      WhatsAppBulkCampaigns: Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>[]
      WhatsAppCampaigns: Prisma.$WhatsAppCampaignPayload<ExtArgs>[]
      WhatsAppContact: Prisma.$WhatsAppContactPayload<ExtArgs>[]
      whatsAppSessions: Prisma.$WhatsAppSessionPayload<ExtArgs>[]
      whatsAppMessageStats: Prisma.$WhatsAppMessageStatsPayload<ExtArgs>[]
      whatsAppAIBots: Prisma.$WhatsAppAIBotPayload<ExtArgs>[]
      aiDocuments: Prisma.$AIDocumentPayload<ExtArgs>[]
      aiUsageLogs: Prisma.$AIUsageLogPayload<ExtArgs>[]
      aiBotSessionBindings: Prisma.$AIBotSessionBindingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      phone: string | null
      password: string | null
      otp: string | null
      otpExpires: Date | null
      otpVerificationDeadline: Date | null
      emailVerified: Date | null
      phoneVerified: Date | null
      image: string | null
      emailVerificationToken: string | null
      emailVerificationTokenExpires: Date | null
      role: string
      apiKey: string | null
      updatedAt: Date | null
      emailOtp: string | null
      emailOtpExpires: Date | null
      resetPasswordOtp: string | null
      resetPasswordOtpExpires: Date | null
      resetPasswordLastRequestAt: Date | null
      ssoOtp: string | null
      ssoOtpExpires: Date | null
      ssoLastRequestAt: Date | null
      isActive: boolean
      createdAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsappCustomers<T extends User$whatsappCustomersArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsappCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSessions<T extends User$userSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voucherUsage<T extends User$voucherUsageArgs<ExtArgs> = {}>(args?: Subset<T, User$voucherUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WhatsAppBulkCampaigns<T extends User$WhatsAppBulkCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$WhatsAppBulkCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WhatsAppCampaigns<T extends User$WhatsAppCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$WhatsAppCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WhatsAppContact<T extends User$WhatsAppContactArgs<ExtArgs> = {}>(args?: Subset<T, User$WhatsAppContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsAppSessions<T extends User$whatsAppSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsAppSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsAppMessageStats<T extends User$whatsAppMessageStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsAppMessageStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsAppAIBots<T extends User$whatsAppAIBotsArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsAppAIBotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiDocuments<T extends User$aiDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiUsageLogs<T extends User$aiUsageLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiUsageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiBotSessionBindings<T extends User$aiBotSessionBindingsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiBotSessionBindingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly otp: FieldRef<"User", 'String'>
    readonly otpExpires: FieldRef<"User", 'DateTime'>
    readonly otpVerificationDeadline: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly phoneVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly emailVerificationToken: FieldRef<"User", 'String'>
    readonly emailVerificationTokenExpires: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
    readonly apiKey: FieldRef<"User", 'String'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly emailOtp: FieldRef<"User", 'String'>
    readonly emailOtpExpires: FieldRef<"User", 'DateTime'>
    readonly resetPasswordOtp: FieldRef<"User", 'String'>
    readonly resetPasswordOtpExpires: FieldRef<"User", 'DateTime'>
    readonly resetPasswordLastRequestAt: FieldRef<"User", 'DateTime'>
    readonly ssoOtp: FieldRef<"User", 'String'>
    readonly ssoOtpExpires: FieldRef<"User", 'DateTime'>
    readonly ssoLastRequestAt: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.whatsappCustomers
   */
  export type User$whatsappCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    where?: ServicesWhatsappCustomersWhereInput
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.userSessions
   */
  export type User$userSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.voucherUsage
   */
  export type User$voucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    cursor?: VoucherUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * User.WhatsAppBulkCampaigns
   */
  export type User$WhatsAppBulkCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    where?: WhatsAppBulkCampaignWhereInput
    orderBy?: WhatsAppBulkCampaignOrderByWithRelationInput | WhatsAppBulkCampaignOrderByWithRelationInput[]
    cursor?: WhatsAppBulkCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppBulkCampaignScalarFieldEnum | WhatsAppBulkCampaignScalarFieldEnum[]
  }

  /**
   * User.WhatsAppCampaigns
   */
  export type User$WhatsAppCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    where?: WhatsAppCampaignWhereInput
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    cursor?: WhatsAppCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * User.WhatsAppContact
   */
  export type User$WhatsAppContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    where?: WhatsAppContactWhereInput
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    cursor?: WhatsAppContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppContactScalarFieldEnum | WhatsAppContactScalarFieldEnum[]
  }

  /**
   * User.whatsAppSessions
   */
  export type User$whatsAppSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    where?: WhatsAppSessionWhereInput
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    cursor?: WhatsAppSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * User.whatsAppMessageStats
   */
  export type User$whatsAppMessageStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    where?: WhatsAppMessageStatsWhereInput
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppMessageStatsScalarFieldEnum | WhatsAppMessageStatsScalarFieldEnum[]
  }

  /**
   * User.whatsAppAIBots
   */
  export type User$whatsAppAIBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
    where?: WhatsAppAIBotWhereInput
    orderBy?: WhatsAppAIBotOrderByWithRelationInput | WhatsAppAIBotOrderByWithRelationInput[]
    cursor?: WhatsAppAIBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppAIBotScalarFieldEnum | WhatsAppAIBotScalarFieldEnum[]
  }

  /**
   * User.aiDocuments
   */
  export type User$aiDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
    where?: AIDocumentWhereInput
    orderBy?: AIDocumentOrderByWithRelationInput | AIDocumentOrderByWithRelationInput[]
    cursor?: AIDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIDocumentScalarFieldEnum | AIDocumentScalarFieldEnum[]
  }

  /**
   * User.aiUsageLogs
   */
  export type User$aiUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    where?: AIUsageLogWhereInput
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    cursor?: AIUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * User.aiBotSessionBindings
   */
  export type User$aiBotSessionBindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    where?: AIBotSessionBindingWhereInput
    orderBy?: AIBotSessionBindingOrderByWithRelationInput | AIBotSessionBindingOrderByWithRelationInput[]
    cursor?: AIBotSessionBindingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIBotSessionBindingScalarFieldEnum | AIBotSessionBindingScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppSession
   */

  export type AggregateWhatsAppSession = {
    _count: WhatsAppSessionCountAggregateOutputType | null
    _avg: WhatsAppSessionAvgAggregateOutputType | null
    _sum: WhatsAppSessionSumAggregateOutputType | null
    _min: WhatsAppSessionMinAggregateOutputType | null
    _max: WhatsAppSessionMaxAggregateOutputType | null
  }

  export type WhatsAppSessionAvgAggregateOutputType = {
    expiration: number | null
    s3RetentionDays: number | null
  }

  export type WhatsAppSessionSumAggregateOutputType = {
    expiration: number | null
    s3RetentionDays: number | null
  }

  export type WhatsAppSessionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    message: string | null
    sessionName: string | null
    connected: boolean | null
    events: string | null
    expiration: number | null
    isSystemSession: boolean | null
    jid: string | null
    loggedIn: boolean | null
    proxyEnabled: boolean | null
    proxyUrl: string | null
    qrcode: string | null
    s3AccessKey: string | null
    s3Bucket: string | null
    s3Enabled: boolean | null
    s3Endpoint: string | null
    s3MediaDelivery: string | null
    s3PathStyle: boolean | null
    s3PublicUrl: string | null
    s3Region: string | null
    s3RetentionDays: number | null
    s3SecretKey: string | null
    token: string | null
    webhook: string | null
    autoReadMessages: boolean | null
    typingIndicator: boolean | null
  }

  export type WhatsAppSessionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    message: string | null
    sessionName: string | null
    connected: boolean | null
    events: string | null
    expiration: number | null
    isSystemSession: boolean | null
    jid: string | null
    loggedIn: boolean | null
    proxyEnabled: boolean | null
    proxyUrl: string | null
    qrcode: string | null
    s3AccessKey: string | null
    s3Bucket: string | null
    s3Enabled: boolean | null
    s3Endpoint: string | null
    s3MediaDelivery: string | null
    s3PathStyle: boolean | null
    s3PublicUrl: string | null
    s3Region: string | null
    s3RetentionDays: number | null
    s3SecretKey: string | null
    token: string | null
    webhook: string | null
    autoReadMessages: boolean | null
    typingIndicator: boolean | null
  }

  export type WhatsAppSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    status: number
    createdAt: number
    updatedAt: number
    message: number
    sessionName: number
    connected: number
    events: number
    expiration: number
    isSystemSession: number
    jid: number
    loggedIn: number
    proxyEnabled: number
    proxyUrl: number
    qrcode: number
    s3AccessKey: number
    s3Bucket: number
    s3Enabled: number
    s3Endpoint: number
    s3MediaDelivery: number
    s3PathStyle: number
    s3PublicUrl: number
    s3Region: number
    s3RetentionDays: number
    s3SecretKey: number
    token: number
    webhook: number
    autoReadMessages: number
    typingIndicator: number
    _all: number
  }


  export type WhatsAppSessionAvgAggregateInputType = {
    expiration?: true
    s3RetentionDays?: true
  }

  export type WhatsAppSessionSumAggregateInputType = {
    expiration?: true
    s3RetentionDays?: true
  }

  export type WhatsAppSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    message?: true
    sessionName?: true
    connected?: true
    events?: true
    expiration?: true
    isSystemSession?: true
    jid?: true
    loggedIn?: true
    proxyEnabled?: true
    proxyUrl?: true
    qrcode?: true
    s3AccessKey?: true
    s3Bucket?: true
    s3Enabled?: true
    s3Endpoint?: true
    s3MediaDelivery?: true
    s3PathStyle?: true
    s3PublicUrl?: true
    s3Region?: true
    s3RetentionDays?: true
    s3SecretKey?: true
    token?: true
    webhook?: true
    autoReadMessages?: true
    typingIndicator?: true
  }

  export type WhatsAppSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    message?: true
    sessionName?: true
    connected?: true
    events?: true
    expiration?: true
    isSystemSession?: true
    jid?: true
    loggedIn?: true
    proxyEnabled?: true
    proxyUrl?: true
    qrcode?: true
    s3AccessKey?: true
    s3Bucket?: true
    s3Enabled?: true
    s3Endpoint?: true
    s3MediaDelivery?: true
    s3PathStyle?: true
    s3PublicUrl?: true
    s3Region?: true
    s3RetentionDays?: true
    s3SecretKey?: true
    token?: true
    webhook?: true
    autoReadMessages?: true
    typingIndicator?: true
  }

  export type WhatsAppSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    message?: true
    sessionName?: true
    connected?: true
    events?: true
    expiration?: true
    isSystemSession?: true
    jid?: true
    loggedIn?: true
    proxyEnabled?: true
    proxyUrl?: true
    qrcode?: true
    s3AccessKey?: true
    s3Bucket?: true
    s3Enabled?: true
    s3Endpoint?: true
    s3MediaDelivery?: true
    s3PathStyle?: true
    s3PublicUrl?: true
    s3Region?: true
    s3RetentionDays?: true
    s3SecretKey?: true
    token?: true
    webhook?: true
    autoReadMessages?: true
    typingIndicator?: true
    _all?: true
  }

  export type WhatsAppSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppSession to aggregate.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppSessions
    **/
    _count?: true | WhatsAppSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppSessionMaxAggregateInputType
  }

  export type GetWhatsAppSessionAggregateType<T extends WhatsAppSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppSession[P]>
      : GetScalarType<T[P], AggregateWhatsAppSession[P]>
  }




  export type WhatsAppSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppSessionWhereInput
    orderBy?: WhatsAppSessionOrderByWithAggregationInput | WhatsAppSessionOrderByWithAggregationInput[]
    by: WhatsAppSessionScalarFieldEnum[] | WhatsAppSessionScalarFieldEnum
    having?: WhatsAppSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppSessionCountAggregateInputType | true
    _avg?: WhatsAppSessionAvgAggregateInputType
    _sum?: WhatsAppSessionSumAggregateInputType
    _min?: WhatsAppSessionMinAggregateInputType
    _max?: WhatsAppSessionMaxAggregateInputType
  }

  export type WhatsAppSessionGroupByOutputType = {
    id: string
    sessionId: string
    userId: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    message: string | null
    sessionName: string
    connected: boolean
    events: string | null
    expiration: number
    isSystemSession: boolean
    jid: string | null
    loggedIn: boolean
    proxyEnabled: boolean
    proxyUrl: string | null
    qrcode: string | null
    s3AccessKey: string | null
    s3Bucket: string | null
    s3Enabled: boolean
    s3Endpoint: string | null
    s3MediaDelivery: string | null
    s3PathStyle: boolean
    s3PublicUrl: string | null
    s3Region: string | null
    s3RetentionDays: number
    s3SecretKey: string | null
    token: string
    webhook: string | null
    autoReadMessages: boolean
    typingIndicator: boolean
    _count: WhatsAppSessionCountAggregateOutputType | null
    _avg: WhatsAppSessionAvgAggregateOutputType | null
    _sum: WhatsAppSessionSumAggregateOutputType | null
    _min: WhatsAppSessionMinAggregateOutputType | null
    _max: WhatsAppSessionMaxAggregateOutputType | null
  }

  type GetWhatsAppSessionGroupByPayload<T extends WhatsAppSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppSessionGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean
    sessionName?: boolean
    connected?: boolean
    events?: boolean
    expiration?: boolean
    isSystemSession?: boolean
    jid?: boolean
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: boolean
    qrcode?: boolean
    s3AccessKey?: boolean
    s3Bucket?: boolean
    s3Enabled?: boolean
    s3Endpoint?: boolean
    s3MediaDelivery?: boolean
    s3PathStyle?: boolean
    s3PublicUrl?: boolean
    s3Region?: boolean
    s3RetentionDays?: boolean
    s3SecretKey?: boolean
    token?: boolean
    webhook?: boolean
    autoReadMessages?: boolean
    typingIndicator?: boolean
    user?: boolean | WhatsAppSession$userArgs<ExtArgs>
    whatsAppMessageStats?: boolean | WhatsAppSession$whatsAppMessageStatsArgs<ExtArgs>
    aiBotSessionBindings?: boolean | WhatsAppSession$aiBotSessionBindingsArgs<ExtArgs>
    _count?: boolean | WhatsAppSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppSession"]>

  export type WhatsAppSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean
    sessionName?: boolean
    connected?: boolean
    events?: boolean
    expiration?: boolean
    isSystemSession?: boolean
    jid?: boolean
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: boolean
    qrcode?: boolean
    s3AccessKey?: boolean
    s3Bucket?: boolean
    s3Enabled?: boolean
    s3Endpoint?: boolean
    s3MediaDelivery?: boolean
    s3PathStyle?: boolean
    s3PublicUrl?: boolean
    s3Region?: boolean
    s3RetentionDays?: boolean
    s3SecretKey?: boolean
    token?: boolean
    webhook?: boolean
    autoReadMessages?: boolean
    typingIndicator?: boolean
    user?: boolean | WhatsAppSession$userArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppSession"]>

  export type WhatsAppSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean
    sessionName?: boolean
    connected?: boolean
    events?: boolean
    expiration?: boolean
    isSystemSession?: boolean
    jid?: boolean
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: boolean
    qrcode?: boolean
    s3AccessKey?: boolean
    s3Bucket?: boolean
    s3Enabled?: boolean
    s3Endpoint?: boolean
    s3MediaDelivery?: boolean
    s3PathStyle?: boolean
    s3PublicUrl?: boolean
    s3Region?: boolean
    s3RetentionDays?: boolean
    s3SecretKey?: boolean
    token?: boolean
    webhook?: boolean
    autoReadMessages?: boolean
    typingIndicator?: boolean
    user?: boolean | WhatsAppSession$userArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppSession"]>

  export type WhatsAppSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean
    sessionName?: boolean
    connected?: boolean
    events?: boolean
    expiration?: boolean
    isSystemSession?: boolean
    jid?: boolean
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: boolean
    qrcode?: boolean
    s3AccessKey?: boolean
    s3Bucket?: boolean
    s3Enabled?: boolean
    s3Endpoint?: boolean
    s3MediaDelivery?: boolean
    s3PathStyle?: boolean
    s3PublicUrl?: boolean
    s3Region?: boolean
    s3RetentionDays?: boolean
    s3SecretKey?: boolean
    token?: boolean
    webhook?: boolean
    autoReadMessages?: boolean
    typingIndicator?: boolean
  }

  export type WhatsAppSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "status" | "createdAt" | "updatedAt" | "message" | "sessionName" | "connected" | "events" | "expiration" | "isSystemSession" | "jid" | "loggedIn" | "proxyEnabled" | "proxyUrl" | "qrcode" | "s3AccessKey" | "s3Bucket" | "s3Enabled" | "s3Endpoint" | "s3MediaDelivery" | "s3PathStyle" | "s3PublicUrl" | "s3Region" | "s3RetentionDays" | "s3SecretKey" | "token" | "webhook" | "autoReadMessages" | "typingIndicator", ExtArgs["result"]["whatsAppSession"]>
  export type WhatsAppSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | WhatsAppSession$userArgs<ExtArgs>
    whatsAppMessageStats?: boolean | WhatsAppSession$whatsAppMessageStatsArgs<ExtArgs>
    aiBotSessionBindings?: boolean | WhatsAppSession$aiBotSessionBindingsArgs<ExtArgs>
    _count?: boolean | WhatsAppSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | WhatsAppSession$userArgs<ExtArgs>
  }
  export type WhatsAppSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | WhatsAppSession$userArgs<ExtArgs>
  }

  export type $WhatsAppSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      whatsAppMessageStats: Prisma.$WhatsAppMessageStatsPayload<ExtArgs>[]
      aiBotSessionBindings: Prisma.$AIBotSessionBindingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      message: string | null
      sessionName: string
      connected: boolean
      events: string | null
      expiration: number
      isSystemSession: boolean
      jid: string | null
      loggedIn: boolean
      proxyEnabled: boolean
      proxyUrl: string | null
      qrcode: string | null
      s3AccessKey: string | null
      s3Bucket: string | null
      s3Enabled: boolean
      s3Endpoint: string | null
      s3MediaDelivery: string | null
      s3PathStyle: boolean
      s3PublicUrl: string | null
      s3Region: string | null
      s3RetentionDays: number
      s3SecretKey: string | null
      token: string
      webhook: string | null
      autoReadMessages: boolean
      typingIndicator: boolean
    }, ExtArgs["result"]["whatsAppSession"]>
    composites: {}
  }

  type WhatsAppSessionGetPayload<S extends boolean | null | undefined | WhatsAppSessionDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppSessionPayload, S>

  type WhatsAppSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppSessionCountAggregateInputType | true
    }

  export interface WhatsAppSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppSession'], meta: { name: 'WhatsAppSession' } }
    /**
     * Find zero or one WhatsAppSession that matches the filter.
     * @param {WhatsAppSessionFindUniqueArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppSessionFindUniqueArgs>(args: SelectSubset<T, WhatsAppSessionFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppSessionFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionFindFirstArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppSessionFindFirstArgs>(args?: SelectSubset<T, WhatsAppSessionFindFirstArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionFindFirstOrThrowArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppSessions
     * const whatsAppSessions = await prisma.whatsAppSession.findMany()
     * 
     * // Get first 10 WhatsAppSessions
     * const whatsAppSessions = await prisma.whatsAppSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppSessionWithIdOnly = await prisma.whatsAppSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppSessionFindManyArgs>(args?: SelectSubset<T, WhatsAppSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppSession.
     * @param {WhatsAppSessionCreateArgs} args - Arguments to create a WhatsAppSession.
     * @example
     * // Create one WhatsAppSession
     * const WhatsAppSession = await prisma.whatsAppSession.create({
     *   data: {
     *     // ... data to create a WhatsAppSession
     *   }
     * })
     * 
     */
    create<T extends WhatsAppSessionCreateArgs>(args: SelectSubset<T, WhatsAppSessionCreateArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppSessions.
     * @param {WhatsAppSessionCreateManyArgs} args - Arguments to create many WhatsAppSessions.
     * @example
     * // Create many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppSessionCreateManyArgs>(args?: SelectSubset<T, WhatsAppSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppSessions and returns the data saved in the database.
     * @param {WhatsAppSessionCreateManyAndReturnArgs} args - Arguments to create many WhatsAppSessions.
     * @example
     * // Create many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppSessions and only return the `id`
     * const whatsAppSessionWithIdOnly = await prisma.whatsAppSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppSession.
     * @param {WhatsAppSessionDeleteArgs} args - Arguments to delete one WhatsAppSession.
     * @example
     * // Delete one WhatsAppSession
     * const WhatsAppSession = await prisma.whatsAppSession.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppSession
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppSessionDeleteArgs>(args: SelectSubset<T, WhatsAppSessionDeleteArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppSession.
     * @param {WhatsAppSessionUpdateArgs} args - Arguments to update one WhatsAppSession.
     * @example
     * // Update one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppSessionUpdateArgs>(args: SelectSubset<T, WhatsAppSessionUpdateArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppSessions.
     * @param {WhatsAppSessionDeleteManyArgs} args - Arguments to filter WhatsAppSessions to delete.
     * @example
     * // Delete a few WhatsAppSessions
     * const { count } = await prisma.whatsAppSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppSessionDeleteManyArgs>(args?: SelectSubset<T, WhatsAppSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppSessionUpdateManyArgs>(args: SelectSubset<T, WhatsAppSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppSessions and returns the data updated in the database.
     * @param {WhatsAppSessionUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppSessions.
     * @example
     * // Update many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppSessions and only return the `id`
     * const whatsAppSessionWithIdOnly = await prisma.whatsAppSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppSession.
     * @param {WhatsAppSessionUpsertArgs} args - Arguments to update or create a WhatsAppSession.
     * @example
     * // Update or create a WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.upsert({
     *   create: {
     *     // ... data to create a WhatsAppSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppSession we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppSessionUpsertArgs>(args: SelectSubset<T, WhatsAppSessionUpsertArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionCountArgs} args - Arguments to filter WhatsAppSessions to count.
     * @example
     * // Count the number of WhatsAppSessions
     * const count = await prisma.whatsAppSession.count({
     *   where: {
     *     // ... the filter for the WhatsAppSessions we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppSessionCountArgs>(
      args?: Subset<T, WhatsAppSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppSessionAggregateArgs>(args: Subset<T, WhatsAppSessionAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppSessionAggregateType<T>>

    /**
     * Group by WhatsAppSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppSessionGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppSession model
   */
  readonly fields: WhatsAppSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends WhatsAppSession$userArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppSession$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    whatsAppMessageStats<T extends WhatsAppSession$whatsAppMessageStatsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppSession$whatsAppMessageStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiBotSessionBindings<T extends WhatsAppSession$aiBotSessionBindingsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppSession$aiBotSessionBindingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppSession model
   */
  interface WhatsAppSessionFieldRefs {
    readonly id: FieldRef<"WhatsAppSession", 'String'>
    readonly sessionId: FieldRef<"WhatsAppSession", 'String'>
    readonly userId: FieldRef<"WhatsAppSession", 'String'>
    readonly status: FieldRef<"WhatsAppSession", 'String'>
    readonly createdAt: FieldRef<"WhatsAppSession", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppSession", 'DateTime'>
    readonly message: FieldRef<"WhatsAppSession", 'String'>
    readonly sessionName: FieldRef<"WhatsAppSession", 'String'>
    readonly connected: FieldRef<"WhatsAppSession", 'Boolean'>
    readonly events: FieldRef<"WhatsAppSession", 'String'>
    readonly expiration: FieldRef<"WhatsAppSession", 'Int'>
    readonly isSystemSession: FieldRef<"WhatsAppSession", 'Boolean'>
    readonly jid: FieldRef<"WhatsAppSession", 'String'>
    readonly loggedIn: FieldRef<"WhatsAppSession", 'Boolean'>
    readonly proxyEnabled: FieldRef<"WhatsAppSession", 'Boolean'>
    readonly proxyUrl: FieldRef<"WhatsAppSession", 'String'>
    readonly qrcode: FieldRef<"WhatsAppSession", 'String'>
    readonly s3AccessKey: FieldRef<"WhatsAppSession", 'String'>
    readonly s3Bucket: FieldRef<"WhatsAppSession", 'String'>
    readonly s3Enabled: FieldRef<"WhatsAppSession", 'Boolean'>
    readonly s3Endpoint: FieldRef<"WhatsAppSession", 'String'>
    readonly s3MediaDelivery: FieldRef<"WhatsAppSession", 'String'>
    readonly s3PathStyle: FieldRef<"WhatsAppSession", 'Boolean'>
    readonly s3PublicUrl: FieldRef<"WhatsAppSession", 'String'>
    readonly s3Region: FieldRef<"WhatsAppSession", 'String'>
    readonly s3RetentionDays: FieldRef<"WhatsAppSession", 'Int'>
    readonly s3SecretKey: FieldRef<"WhatsAppSession", 'String'>
    readonly token: FieldRef<"WhatsAppSession", 'String'>
    readonly webhook: FieldRef<"WhatsAppSession", 'String'>
    readonly autoReadMessages: FieldRef<"WhatsAppSession", 'Boolean'>
    readonly typingIndicator: FieldRef<"WhatsAppSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppSession findUnique
   */
  export type WhatsAppSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession findUniqueOrThrow
   */
  export type WhatsAppSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession findFirst
   */
  export type WhatsAppSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppSessions.
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppSessions.
     */
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * WhatsAppSession findFirstOrThrow
   */
  export type WhatsAppSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppSessions.
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppSessions.
     */
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * WhatsAppSession findMany
   */
  export type WhatsAppSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSessions to fetch.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppSessions.
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * WhatsAppSession create
   */
  export type WhatsAppSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppSession.
     */
    data: XOR<WhatsAppSessionCreateInput, WhatsAppSessionUncheckedCreateInput>
  }

  /**
   * WhatsAppSession createMany
   */
  export type WhatsAppSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppSessions.
     */
    data: WhatsAppSessionCreateManyInput | WhatsAppSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppSession createManyAndReturn
   */
  export type WhatsAppSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppSessions.
     */
    data: WhatsAppSessionCreateManyInput | WhatsAppSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppSession update
   */
  export type WhatsAppSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppSession.
     */
    data: XOR<WhatsAppSessionUpdateInput, WhatsAppSessionUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppSession to update.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession updateMany
   */
  export type WhatsAppSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppSessions.
     */
    data: XOR<WhatsAppSessionUpdateManyMutationInput, WhatsAppSessionUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppSessions to update
     */
    where?: WhatsAppSessionWhereInput
    /**
     * Limit how many WhatsAppSessions to update.
     */
    limit?: number
  }

  /**
   * WhatsAppSession updateManyAndReturn
   */
  export type WhatsAppSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppSessions.
     */
    data: XOR<WhatsAppSessionUpdateManyMutationInput, WhatsAppSessionUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppSessions to update
     */
    where?: WhatsAppSessionWhereInput
    /**
     * Limit how many WhatsAppSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppSession upsert
   */
  export type WhatsAppSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppSession to update in case it exists.
     */
    where: WhatsAppSessionWhereUniqueInput
    /**
     * In case the WhatsAppSession found by the `where` argument doesn't exist, create a new WhatsAppSession with this data.
     */
    create: XOR<WhatsAppSessionCreateInput, WhatsAppSessionUncheckedCreateInput>
    /**
     * In case the WhatsAppSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppSessionUpdateInput, WhatsAppSessionUncheckedUpdateInput>
  }

  /**
   * WhatsAppSession delete
   */
  export type WhatsAppSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppSession to delete.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession deleteMany
   */
  export type WhatsAppSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppSessions to delete
     */
    where?: WhatsAppSessionWhereInput
    /**
     * Limit how many WhatsAppSessions to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppSession.user
   */
  export type WhatsAppSession$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WhatsAppSession.whatsAppMessageStats
   */
  export type WhatsAppSession$whatsAppMessageStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    where?: WhatsAppMessageStatsWhereInput
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppMessageStatsScalarFieldEnum | WhatsAppMessageStatsScalarFieldEnum[]
  }

  /**
   * WhatsAppSession.aiBotSessionBindings
   */
  export type WhatsAppSession$aiBotSessionBindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    where?: AIBotSessionBindingWhereInput
    orderBy?: AIBotSessionBindingOrderByWithRelationInput | AIBotSessionBindingOrderByWithRelationInput[]
    cursor?: AIBotSessionBindingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIBotSessionBindingScalarFieldEnum | AIBotSessionBindingScalarFieldEnum[]
  }

  /**
   * WhatsAppSession without action
   */
  export type WhatsAppSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
    discountAmount: Decimal | null
    originalAmount: Decimal | null
    finalAmount: Decimal | null
    serviceFeeAmount: Decimal | null
    totalAfterDiscount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
    discountAmount: Decimal | null
    originalAmount: Decimal | null
    finalAmount: Decimal | null
    serviceFeeAmount: Decimal | null
    totalAfterDiscount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionDate: Date | null
    status: string | null
    amount: Decimal | null
    createdAt: Date | null
    type: string | null
    updatedAt: Date | null
    discountAmount: Decimal | null
    originalAmount: Decimal | null
    voucherId: string | null
    notes: string | null
    currency: string | null
    finalAmount: Decimal | null
    serviceFeeAmount: Decimal | null
    totalAfterDiscount: Decimal | null
    expiresAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionDate: Date | null
    status: string | null
    amount: Decimal | null
    createdAt: Date | null
    type: string | null
    updatedAt: Date | null
    discountAmount: Decimal | null
    originalAmount: Decimal | null
    voucherId: string | null
    notes: string | null
    currency: string | null
    finalAmount: Decimal | null
    serviceFeeAmount: Decimal | null
    totalAfterDiscount: Decimal | null
    expiresAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    transactionDate: number
    status: number
    amount: number
    createdAt: number
    type: number
    updatedAt: number
    discountAmount: number
    originalAmount: number
    voucherId: number
    notes: number
    currency: number
    finalAmount: number
    serviceFeeAmount: number
    totalAfterDiscount: number
    expiresAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    discountAmount?: true
    originalAmount?: true
    finalAmount?: true
    serviceFeeAmount?: true
    totalAfterDiscount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    discountAmount?: true
    originalAmount?: true
    finalAmount?: true
    serviceFeeAmount?: true
    totalAfterDiscount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    transactionDate?: true
    status?: true
    amount?: true
    createdAt?: true
    type?: true
    updatedAt?: true
    discountAmount?: true
    originalAmount?: true
    voucherId?: true
    notes?: true
    currency?: true
    finalAmount?: true
    serviceFeeAmount?: true
    totalAfterDiscount?: true
    expiresAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    transactionDate?: true
    status?: true
    amount?: true
    createdAt?: true
    type?: true
    updatedAt?: true
    discountAmount?: true
    originalAmount?: true
    voucherId?: true
    notes?: true
    currency?: true
    finalAmount?: true
    serviceFeeAmount?: true
    totalAfterDiscount?: true
    expiresAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    transactionDate?: true
    status?: true
    amount?: true
    createdAt?: true
    type?: true
    updatedAt?: true
    discountAmount?: true
    originalAmount?: true
    voucherId?: true
    notes?: true
    currency?: true
    finalAmount?: true
    serviceFeeAmount?: true
    totalAfterDiscount?: true
    expiresAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    transactionDate: Date
    status: string
    amount: Decimal
    createdAt: Date
    type: string
    updatedAt: Date
    discountAmount: Decimal | null
    originalAmount: Decimal | null
    voucherId: string | null
    notes: string | null
    currency: string
    finalAmount: Decimal | null
    serviceFeeAmount: Decimal | null
    totalAfterDiscount: Decimal | null
    expiresAt: Date | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionDate?: boolean
    status?: boolean
    amount?: boolean
    createdAt?: boolean
    type?: boolean
    updatedAt?: boolean
    discountAmount?: boolean
    originalAmount?: boolean
    voucherId?: boolean
    notes?: boolean
    currency?: boolean
    finalAmount?: boolean
    serviceFeeAmount?: boolean
    totalAfterDiscount?: boolean
    expiresAt?: boolean
    payment?: boolean | Transaction$paymentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
    whatsappTransaction?: boolean | Transaction$whatsappTransactionArgs<ExtArgs>
    voucherUsage?: boolean | Transaction$voucherUsageArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionDate?: boolean
    status?: boolean
    amount?: boolean
    createdAt?: boolean
    type?: boolean
    updatedAt?: boolean
    discountAmount?: boolean
    originalAmount?: boolean
    voucherId?: boolean
    notes?: boolean
    currency?: boolean
    finalAmount?: boolean
    serviceFeeAmount?: boolean
    totalAfterDiscount?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionDate?: boolean
    status?: boolean
    amount?: boolean
    createdAt?: boolean
    type?: boolean
    updatedAt?: boolean
    discountAmount?: boolean
    originalAmount?: boolean
    voucherId?: boolean
    notes?: boolean
    currency?: boolean
    finalAmount?: boolean
    serviceFeeAmount?: boolean
    totalAfterDiscount?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    transactionDate?: boolean
    status?: boolean
    amount?: boolean
    createdAt?: boolean
    type?: boolean
    updatedAt?: boolean
    discountAmount?: boolean
    originalAmount?: boolean
    voucherId?: boolean
    notes?: boolean
    currency?: boolean
    finalAmount?: boolean
    serviceFeeAmount?: boolean
    totalAfterDiscount?: boolean
    expiresAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "transactionDate" | "status" | "amount" | "createdAt" | "type" | "updatedAt" | "discountAmount" | "originalAmount" | "voucherId" | "notes" | "currency" | "finalAmount" | "serviceFeeAmount" | "totalAfterDiscount" | "expiresAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | Transaction$paymentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
    whatsappTransaction?: boolean | Transaction$whatsappTransactionArgs<ExtArgs>
    voucherUsage?: boolean | Transaction$voucherUsageArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      voucher: Prisma.$VoucherPayload<ExtArgs> | null
      whatsappTransaction: Prisma.$TransactionWhatsappServicePayload<ExtArgs> | null
      voucherUsage: Prisma.$VoucherUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      transactionDate: Date
      status: string
      amount: Prisma.Decimal
      createdAt: Date
      type: string
      updatedAt: Date
      discountAmount: Prisma.Decimal | null
      originalAmount: Prisma.Decimal | null
      voucherId: string | null
      notes: string | null
      currency: string
      finalAmount: Prisma.Decimal | null
      serviceFeeAmount: Prisma.Decimal | null
      totalAfterDiscount: Prisma.Decimal | null
      expiresAt: Date | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends Transaction$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    voucher<T extends Transaction$voucherArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$voucherArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    whatsappTransaction<T extends Transaction$whatsappTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$whatsappTransactionArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    voucherUsage<T extends Transaction$voucherUsageArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$voucherUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly transactionDate: FieldRef<"Transaction", 'DateTime'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly discountAmount: FieldRef<"Transaction", 'Decimal'>
    readonly originalAmount: FieldRef<"Transaction", 'Decimal'>
    readonly voucherId: FieldRef<"Transaction", 'String'>
    readonly notes: FieldRef<"Transaction", 'String'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly finalAmount: FieldRef<"Transaction", 'Decimal'>
    readonly serviceFeeAmount: FieldRef<"Transaction", 'Decimal'>
    readonly totalAfterDiscount: FieldRef<"Transaction", 'Decimal'>
    readonly expiresAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.payment
   */
  export type Transaction$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Transaction.voucher
   */
  export type Transaction$voucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
  }

  /**
   * Transaction.whatsappTransaction
   */
  export type Transaction$whatsappTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    where?: TransactionWhatsappServiceWhereInput
  }

  /**
   * Transaction.voucherUsage
   */
  export type Transaction$voucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    cursor?: VoucherUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TransactionWhatsappService
   */

  export type AggregateTransactionWhatsappService = {
    _count: TransactionWhatsappServiceCountAggregateOutputType | null
    _min: TransactionWhatsappServiceMinAggregateOutputType | null
    _max: TransactionWhatsappServiceMaxAggregateOutputType | null
  }

  export type TransactionWhatsappServiceMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    whatsappPackageId: string | null
    duration: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type TransactionWhatsappServiceMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    whatsappPackageId: string | null
    duration: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type TransactionWhatsappServiceCountAggregateOutputType = {
    id: number
    transactionId: number
    whatsappPackageId: number
    duration: number
    status: number
    startDate: number
    endDate: number
    _all: number
  }


  export type TransactionWhatsappServiceMinAggregateInputType = {
    id?: true
    transactionId?: true
    whatsappPackageId?: true
    duration?: true
    status?: true
    startDate?: true
    endDate?: true
  }

  export type TransactionWhatsappServiceMaxAggregateInputType = {
    id?: true
    transactionId?: true
    whatsappPackageId?: true
    duration?: true
    status?: true
    startDate?: true
    endDate?: true
  }

  export type TransactionWhatsappServiceCountAggregateInputType = {
    id?: true
    transactionId?: true
    whatsappPackageId?: true
    duration?: true
    status?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type TransactionWhatsappServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionWhatsappService to aggregate.
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionWhatsappServices to fetch.
     */
    orderBy?: TransactionWhatsappServiceOrderByWithRelationInput | TransactionWhatsappServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhatsappServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionWhatsappServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionWhatsappServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionWhatsappServices
    **/
    _count?: true | TransactionWhatsappServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionWhatsappServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionWhatsappServiceMaxAggregateInputType
  }

  export type GetTransactionWhatsappServiceAggregateType<T extends TransactionWhatsappServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionWhatsappService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionWhatsappService[P]>
      : GetScalarType<T[P], AggregateTransactionWhatsappService[P]>
  }




  export type TransactionWhatsappServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhatsappServiceWhereInput
    orderBy?: TransactionWhatsappServiceOrderByWithAggregationInput | TransactionWhatsappServiceOrderByWithAggregationInput[]
    by: TransactionWhatsappServiceScalarFieldEnum[] | TransactionWhatsappServiceScalarFieldEnum
    having?: TransactionWhatsappServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionWhatsappServiceCountAggregateInputType | true
    _min?: TransactionWhatsappServiceMinAggregateInputType
    _max?: TransactionWhatsappServiceMaxAggregateInputType
  }

  export type TransactionWhatsappServiceGroupByOutputType = {
    id: string
    transactionId: string
    whatsappPackageId: string
    duration: string
    status: string
    startDate: Date | null
    endDate: Date | null
    _count: TransactionWhatsappServiceCountAggregateOutputType | null
    _min: TransactionWhatsappServiceMinAggregateOutputType | null
    _max: TransactionWhatsappServiceMaxAggregateOutputType | null
  }

  type GetTransactionWhatsappServiceGroupByPayload<T extends TransactionWhatsappServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionWhatsappServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionWhatsappServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionWhatsappServiceGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionWhatsappServiceGroupByOutputType[P]>
        }
      >
    >


  export type TransactionWhatsappServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    whatsappPackageId?: boolean
    duration?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionWhatsappService"]>

  export type TransactionWhatsappServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    whatsappPackageId?: boolean
    duration?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionWhatsappService"]>

  export type TransactionWhatsappServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    whatsappPackageId?: boolean
    duration?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionWhatsappService"]>

  export type TransactionWhatsappServiceSelectScalar = {
    id?: boolean
    transactionId?: boolean
    whatsappPackageId?: boolean
    duration?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type TransactionWhatsappServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "whatsappPackageId" | "duration" | "status" | "startDate" | "endDate", ExtArgs["result"]["transactionWhatsappService"]>
  export type TransactionWhatsappServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }
  export type TransactionWhatsappServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }
  export type TransactionWhatsappServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }

  export type $TransactionWhatsappServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionWhatsappService"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      whatsappPackage: Prisma.$WhatsappApiPackagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      whatsappPackageId: string
      duration: string
      status: string
      startDate: Date | null
      endDate: Date | null
    }, ExtArgs["result"]["transactionWhatsappService"]>
    composites: {}
  }

  type TransactionWhatsappServiceGetPayload<S extends boolean | null | undefined | TransactionWhatsappServiceDefaultArgs> = $Result.GetResult<Prisma.$TransactionWhatsappServicePayload, S>

  type TransactionWhatsappServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionWhatsappServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionWhatsappServiceCountAggregateInputType | true
    }

  export interface TransactionWhatsappServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionWhatsappService'], meta: { name: 'TransactionWhatsappService' } }
    /**
     * Find zero or one TransactionWhatsappService that matches the filter.
     * @param {TransactionWhatsappServiceFindUniqueArgs} args - Arguments to find a TransactionWhatsappService
     * @example
     * // Get one TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionWhatsappServiceFindUniqueArgs>(args: SelectSubset<T, TransactionWhatsappServiceFindUniqueArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionWhatsappService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionWhatsappServiceFindUniqueOrThrowArgs} args - Arguments to find a TransactionWhatsappService
     * @example
     * // Get one TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionWhatsappServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionWhatsappServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionWhatsappService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceFindFirstArgs} args - Arguments to find a TransactionWhatsappService
     * @example
     * // Get one TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionWhatsappServiceFindFirstArgs>(args?: SelectSubset<T, TransactionWhatsappServiceFindFirstArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionWhatsappService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceFindFirstOrThrowArgs} args - Arguments to find a TransactionWhatsappService
     * @example
     * // Get one TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionWhatsappServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionWhatsappServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionWhatsappServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionWhatsappServices
     * const transactionWhatsappServices = await prisma.transactionWhatsappService.findMany()
     * 
     * // Get first 10 TransactionWhatsappServices
     * const transactionWhatsappServices = await prisma.transactionWhatsappService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWhatsappServiceWithIdOnly = await prisma.transactionWhatsappService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionWhatsappServiceFindManyArgs>(args?: SelectSubset<T, TransactionWhatsappServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionWhatsappService.
     * @param {TransactionWhatsappServiceCreateArgs} args - Arguments to create a TransactionWhatsappService.
     * @example
     * // Create one TransactionWhatsappService
     * const TransactionWhatsappService = await prisma.transactionWhatsappService.create({
     *   data: {
     *     // ... data to create a TransactionWhatsappService
     *   }
     * })
     * 
     */
    create<T extends TransactionWhatsappServiceCreateArgs>(args: SelectSubset<T, TransactionWhatsappServiceCreateArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionWhatsappServices.
     * @param {TransactionWhatsappServiceCreateManyArgs} args - Arguments to create many TransactionWhatsappServices.
     * @example
     * // Create many TransactionWhatsappServices
     * const transactionWhatsappService = await prisma.transactionWhatsappService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionWhatsappServiceCreateManyArgs>(args?: SelectSubset<T, TransactionWhatsappServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionWhatsappServices and returns the data saved in the database.
     * @param {TransactionWhatsappServiceCreateManyAndReturnArgs} args - Arguments to create many TransactionWhatsappServices.
     * @example
     * // Create many TransactionWhatsappServices
     * const transactionWhatsappService = await prisma.transactionWhatsappService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionWhatsappServices and only return the `id`
     * const transactionWhatsappServiceWithIdOnly = await prisma.transactionWhatsappService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionWhatsappServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionWhatsappServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionWhatsappService.
     * @param {TransactionWhatsappServiceDeleteArgs} args - Arguments to delete one TransactionWhatsappService.
     * @example
     * // Delete one TransactionWhatsappService
     * const TransactionWhatsappService = await prisma.transactionWhatsappService.delete({
     *   where: {
     *     // ... filter to delete one TransactionWhatsappService
     *   }
     * })
     * 
     */
    delete<T extends TransactionWhatsappServiceDeleteArgs>(args: SelectSubset<T, TransactionWhatsappServiceDeleteArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionWhatsappService.
     * @param {TransactionWhatsappServiceUpdateArgs} args - Arguments to update one TransactionWhatsappService.
     * @example
     * // Update one TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionWhatsappServiceUpdateArgs>(args: SelectSubset<T, TransactionWhatsappServiceUpdateArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionWhatsappServices.
     * @param {TransactionWhatsappServiceDeleteManyArgs} args - Arguments to filter TransactionWhatsappServices to delete.
     * @example
     * // Delete a few TransactionWhatsappServices
     * const { count } = await prisma.transactionWhatsappService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionWhatsappServiceDeleteManyArgs>(args?: SelectSubset<T, TransactionWhatsappServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionWhatsappServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionWhatsappServices
     * const transactionWhatsappService = await prisma.transactionWhatsappService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionWhatsappServiceUpdateManyArgs>(args: SelectSubset<T, TransactionWhatsappServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionWhatsappServices and returns the data updated in the database.
     * @param {TransactionWhatsappServiceUpdateManyAndReturnArgs} args - Arguments to update many TransactionWhatsappServices.
     * @example
     * // Update many TransactionWhatsappServices
     * const transactionWhatsappService = await prisma.transactionWhatsappService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionWhatsappServices and only return the `id`
     * const transactionWhatsappServiceWithIdOnly = await prisma.transactionWhatsappService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionWhatsappServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionWhatsappServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionWhatsappService.
     * @param {TransactionWhatsappServiceUpsertArgs} args - Arguments to update or create a TransactionWhatsappService.
     * @example
     * // Update or create a TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.upsert({
     *   create: {
     *     // ... data to create a TransactionWhatsappService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionWhatsappService we want to update
     *   }
     * })
     */
    upsert<T extends TransactionWhatsappServiceUpsertArgs>(args: SelectSubset<T, TransactionWhatsappServiceUpsertArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionWhatsappServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceCountArgs} args - Arguments to filter TransactionWhatsappServices to count.
     * @example
     * // Count the number of TransactionWhatsappServices
     * const count = await prisma.transactionWhatsappService.count({
     *   where: {
     *     // ... the filter for the TransactionWhatsappServices we want to count
     *   }
     * })
    **/
    count<T extends TransactionWhatsappServiceCountArgs>(
      args?: Subset<T, TransactionWhatsappServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionWhatsappServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionWhatsappService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionWhatsappServiceAggregateArgs>(args: Subset<T, TransactionWhatsappServiceAggregateArgs>): Prisma.PrismaPromise<GetTransactionWhatsappServiceAggregateType<T>>

    /**
     * Group by TransactionWhatsappService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionWhatsappServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionWhatsappServiceGroupByArgs['orderBy'] }
        : { orderBy?: TransactionWhatsappServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionWhatsappServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionWhatsappServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionWhatsappService model
   */
  readonly fields: TransactionWhatsappServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionWhatsappService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionWhatsappServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    whatsappPackage<T extends WhatsappApiPackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappApiPackageDefaultArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionWhatsappService model
   */
  interface TransactionWhatsappServiceFieldRefs {
    readonly id: FieldRef<"TransactionWhatsappService", 'String'>
    readonly transactionId: FieldRef<"TransactionWhatsappService", 'String'>
    readonly whatsappPackageId: FieldRef<"TransactionWhatsappService", 'String'>
    readonly duration: FieldRef<"TransactionWhatsappService", 'String'>
    readonly status: FieldRef<"TransactionWhatsappService", 'String'>
    readonly startDate: FieldRef<"TransactionWhatsappService", 'DateTime'>
    readonly endDate: FieldRef<"TransactionWhatsappService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionWhatsappService findUnique
   */
  export type TransactionWhatsappServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter, which TransactionWhatsappService to fetch.
     */
    where: TransactionWhatsappServiceWhereUniqueInput
  }

  /**
   * TransactionWhatsappService findUniqueOrThrow
   */
  export type TransactionWhatsappServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter, which TransactionWhatsappService to fetch.
     */
    where: TransactionWhatsappServiceWhereUniqueInput
  }

  /**
   * TransactionWhatsappService findFirst
   */
  export type TransactionWhatsappServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter, which TransactionWhatsappService to fetch.
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionWhatsappServices to fetch.
     */
    orderBy?: TransactionWhatsappServiceOrderByWithRelationInput | TransactionWhatsappServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionWhatsappServices.
     */
    cursor?: TransactionWhatsappServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionWhatsappServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionWhatsappServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionWhatsappServices.
     */
    distinct?: TransactionWhatsappServiceScalarFieldEnum | TransactionWhatsappServiceScalarFieldEnum[]
  }

  /**
   * TransactionWhatsappService findFirstOrThrow
   */
  export type TransactionWhatsappServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter, which TransactionWhatsappService to fetch.
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionWhatsappServices to fetch.
     */
    orderBy?: TransactionWhatsappServiceOrderByWithRelationInput | TransactionWhatsappServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionWhatsappServices.
     */
    cursor?: TransactionWhatsappServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionWhatsappServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionWhatsappServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionWhatsappServices.
     */
    distinct?: TransactionWhatsappServiceScalarFieldEnum | TransactionWhatsappServiceScalarFieldEnum[]
  }

  /**
   * TransactionWhatsappService findMany
   */
  export type TransactionWhatsappServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter, which TransactionWhatsappServices to fetch.
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionWhatsappServices to fetch.
     */
    orderBy?: TransactionWhatsappServiceOrderByWithRelationInput | TransactionWhatsappServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionWhatsappServices.
     */
    cursor?: TransactionWhatsappServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionWhatsappServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionWhatsappServices.
     */
    skip?: number
    distinct?: TransactionWhatsappServiceScalarFieldEnum | TransactionWhatsappServiceScalarFieldEnum[]
  }

  /**
   * TransactionWhatsappService create
   */
  export type TransactionWhatsappServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionWhatsappService.
     */
    data: XOR<TransactionWhatsappServiceCreateInput, TransactionWhatsappServiceUncheckedCreateInput>
  }

  /**
   * TransactionWhatsappService createMany
   */
  export type TransactionWhatsappServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionWhatsappServices.
     */
    data: TransactionWhatsappServiceCreateManyInput | TransactionWhatsappServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionWhatsappService createManyAndReturn
   */
  export type TransactionWhatsappServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionWhatsappServices.
     */
    data: TransactionWhatsappServiceCreateManyInput | TransactionWhatsappServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionWhatsappService update
   */
  export type TransactionWhatsappServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionWhatsappService.
     */
    data: XOR<TransactionWhatsappServiceUpdateInput, TransactionWhatsappServiceUncheckedUpdateInput>
    /**
     * Choose, which TransactionWhatsappService to update.
     */
    where: TransactionWhatsappServiceWhereUniqueInput
  }

  /**
   * TransactionWhatsappService updateMany
   */
  export type TransactionWhatsappServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionWhatsappServices.
     */
    data: XOR<TransactionWhatsappServiceUpdateManyMutationInput, TransactionWhatsappServiceUncheckedUpdateManyInput>
    /**
     * Filter which TransactionWhatsappServices to update
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * Limit how many TransactionWhatsappServices to update.
     */
    limit?: number
  }

  /**
   * TransactionWhatsappService updateManyAndReturn
   */
  export type TransactionWhatsappServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * The data used to update TransactionWhatsappServices.
     */
    data: XOR<TransactionWhatsappServiceUpdateManyMutationInput, TransactionWhatsappServiceUncheckedUpdateManyInput>
    /**
     * Filter which TransactionWhatsappServices to update
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * Limit how many TransactionWhatsappServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionWhatsappService upsert
   */
  export type TransactionWhatsappServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionWhatsappService to update in case it exists.
     */
    where: TransactionWhatsappServiceWhereUniqueInput
    /**
     * In case the TransactionWhatsappService found by the `where` argument doesn't exist, create a new TransactionWhatsappService with this data.
     */
    create: XOR<TransactionWhatsappServiceCreateInput, TransactionWhatsappServiceUncheckedCreateInput>
    /**
     * In case the TransactionWhatsappService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionWhatsappServiceUpdateInput, TransactionWhatsappServiceUncheckedUpdateInput>
  }

  /**
   * TransactionWhatsappService delete
   */
  export type TransactionWhatsappServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter which TransactionWhatsappService to delete.
     */
    where: TransactionWhatsappServiceWhereUniqueInput
  }

  /**
   * TransactionWhatsappService deleteMany
   */
  export type TransactionWhatsappServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionWhatsappServices to delete
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * Limit how many TransactionWhatsappServices to delete.
     */
    limit?: number
  }

  /**
   * TransactionWhatsappService without action
   */
  export type TransactionWhatsappServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
    serviceFee: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
    serviceFee: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    amount: Decimal | null
    method: string | null
    status: string | null
    paymentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    externalId: string | null
    paymentUrl: string | null
    serviceFee: Decimal | null
    adminNotes: string | null
    adminAction: string | null
    adminUserId: string | null
    actionDate: Date | null
    gatewayProvider: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    amount: Decimal | null
    method: string | null
    status: string | null
    paymentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    externalId: string | null
    paymentUrl: string | null
    serviceFee: Decimal | null
    adminNotes: string | null
    adminAction: string | null
    adminUserId: string | null
    actionDate: Date | null
    gatewayProvider: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    transactionId: number
    amount: number
    method: number
    status: number
    paymentDate: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    externalId: number
    paymentUrl: number
    serviceFee: number
    adminNotes: number
    adminAction: number
    adminUserId: number
    actionDate: number
    gatewayProvider: number
    gatewayResponse: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    serviceFee?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    serviceFee?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    method?: true
    status?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    externalId?: true
    paymentUrl?: true
    serviceFee?: true
    adminNotes?: true
    adminAction?: true
    adminUserId?: true
    actionDate?: true
    gatewayProvider?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    method?: true
    status?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    externalId?: true
    paymentUrl?: true
    serviceFee?: true
    adminNotes?: true
    adminAction?: true
    adminUserId?: true
    actionDate?: true
    gatewayProvider?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    method?: true
    status?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    externalId?: true
    paymentUrl?: true
    serviceFee?: true
    adminNotes?: true
    adminAction?: true
    adminUserId?: true
    actionDate?: true
    gatewayProvider?: true
    gatewayResponse?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    transactionId: string | null
    amount: Decimal
    method: string
    status: string
    paymentDate: Date | null
    createdAt: Date
    updatedAt: Date
    expiresAt: Date | null
    externalId: string | null
    paymentUrl: string | null
    serviceFee: Decimal | null
    adminNotes: string | null
    adminAction: string | null
    adminUserId: string | null
    actionDate: Date | null
    gatewayProvider: string | null
    gatewayResponse: JsonValue | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    externalId?: boolean
    paymentUrl?: boolean
    serviceFee?: boolean
    adminNotes?: boolean
    adminAction?: boolean
    adminUserId?: boolean
    actionDate?: boolean
    gatewayProvider?: boolean
    gatewayResponse?: boolean
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    externalId?: boolean
    paymentUrl?: boolean
    serviceFee?: boolean
    adminNotes?: boolean
    adminAction?: boolean
    adminUserId?: boolean
    actionDate?: boolean
    gatewayProvider?: boolean
    gatewayResponse?: boolean
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    externalId?: boolean
    paymentUrl?: boolean
    serviceFee?: boolean
    adminNotes?: boolean
    adminAction?: boolean
    adminUserId?: boolean
    actionDate?: boolean
    gatewayProvider?: boolean
    gatewayResponse?: boolean
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    externalId?: boolean
    paymentUrl?: boolean
    serviceFee?: boolean
    adminNotes?: boolean
    adminAction?: boolean
    adminUserId?: boolean
    actionDate?: boolean
    gatewayProvider?: boolean
    gatewayResponse?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "amount" | "method" | "status" | "paymentDate" | "createdAt" | "updatedAt" | "expiresAt" | "externalId" | "paymentUrl" | "serviceFee" | "adminNotes" | "adminAction" | "adminUserId" | "actionDate" | "gatewayProvider" | "gatewayResponse", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string | null
      amount: Prisma.Decimal
      method: string
      status: string
      paymentDate: Date | null
      createdAt: Date
      updatedAt: Date
      expiresAt: Date | null
      externalId: string | null
      paymentUrl: string | null
      serviceFee: Prisma.Decimal | null
      adminNotes: string | null
      adminAction: string | null
      adminUserId: string | null
      actionDate: Date | null
      gatewayProvider: string | null
      gatewayResponse: Prisma.JsonValue | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends Payment$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Payment$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly expiresAt: FieldRef<"Payment", 'DateTime'>
    readonly externalId: FieldRef<"Payment", 'String'>
    readonly paymentUrl: FieldRef<"Payment", 'String'>
    readonly serviceFee: FieldRef<"Payment", 'Decimal'>
    readonly adminNotes: FieldRef<"Payment", 'String'>
    readonly adminAction: FieldRef<"Payment", 'String'>
    readonly adminUserId: FieldRef<"Payment", 'String'>
    readonly actionDate: FieldRef<"Payment", 'DateTime'>
    readonly gatewayProvider: FieldRef<"Payment", 'String'>
    readonly gatewayResponse: FieldRef<"Payment", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.transaction
   */
  export type Payment$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model WhatsappApiPackage
   */

  export type AggregateWhatsappApiPackage = {
    _count: WhatsappApiPackageCountAggregateOutputType | null
    _avg: WhatsappApiPackageAvgAggregateOutputType | null
    _sum: WhatsappApiPackageSumAggregateOutputType | null
    _min: WhatsappApiPackageMinAggregateOutputType | null
    _max: WhatsappApiPackageMaxAggregateOutputType | null
  }

  export type WhatsappApiPackageAvgAggregateOutputType = {
    priceMonth: number | null
    priceYear: number | null
    maxSession: number | null
  }

  export type WhatsappApiPackageSumAggregateOutputType = {
    priceMonth: number | null
    priceYear: number | null
    maxSession: number | null
  }

  export type WhatsappApiPackageMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    priceMonth: number | null
    priceYear: number | null
    maxSession: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsappApiPackageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    priceMonth: number | null
    priceYear: number | null
    maxSession: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsappApiPackageCountAggregateOutputType = {
    id: number
    name: number
    description: number
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsappApiPackageAvgAggregateInputType = {
    priceMonth?: true
    priceYear?: true
    maxSession?: true
  }

  export type WhatsappApiPackageSumAggregateInputType = {
    priceMonth?: true
    priceYear?: true
    maxSession?: true
  }

  export type WhatsappApiPackageMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonth?: true
    priceYear?: true
    maxSession?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsappApiPackageMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonth?: true
    priceYear?: true
    maxSession?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsappApiPackageCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonth?: true
    priceYear?: true
    maxSession?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsappApiPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappApiPackage to aggregate.
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappApiPackages to fetch.
     */
    orderBy?: WhatsappApiPackageOrderByWithRelationInput | WhatsappApiPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsappApiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappApiPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappApiPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsappApiPackages
    **/
    _count?: true | WhatsappApiPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsappApiPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsappApiPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsappApiPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsappApiPackageMaxAggregateInputType
  }

  export type GetWhatsappApiPackageAggregateType<T extends WhatsappApiPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsappApiPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsappApiPackage[P]>
      : GetScalarType<T[P], AggregateWhatsappApiPackage[P]>
  }




  export type WhatsappApiPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappApiPackageWhereInput
    orderBy?: WhatsappApiPackageOrderByWithAggregationInput | WhatsappApiPackageOrderByWithAggregationInput[]
    by: WhatsappApiPackageScalarFieldEnum[] | WhatsappApiPackageScalarFieldEnum
    having?: WhatsappApiPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsappApiPackageCountAggregateInputType | true
    _avg?: WhatsappApiPackageAvgAggregateInputType
    _sum?: WhatsappApiPackageSumAggregateInputType
    _min?: WhatsappApiPackageMinAggregateInputType
    _max?: WhatsappApiPackageMaxAggregateInputType
  }

  export type WhatsappApiPackageGroupByOutputType = {
    id: string
    name: string
    description: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt: Date
    updatedAt: Date
    _count: WhatsappApiPackageCountAggregateOutputType | null
    _avg: WhatsappApiPackageAvgAggregateOutputType | null
    _sum: WhatsappApiPackageSumAggregateOutputType | null
    _min: WhatsappApiPackageMinAggregateOutputType | null
    _max: WhatsappApiPackageMaxAggregateOutputType | null
  }

  type GetWhatsappApiPackageGroupByPayload<T extends WhatsappApiPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsappApiPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsappApiPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsappApiPackageGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsappApiPackageGroupByOutputType[P]>
        }
      >
    >


  export type WhatsappApiPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonth?: boolean
    priceYear?: boolean
    maxSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatsappCustomers?: boolean | WhatsappApiPackage$whatsappCustomersArgs<ExtArgs>
    whatsappTransactions?: boolean | WhatsappApiPackage$whatsappTransactionsArgs<ExtArgs>
    _count?: boolean | WhatsappApiPackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsappApiPackage"]>

  export type WhatsappApiPackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonth?: boolean
    priceYear?: boolean
    maxSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["whatsappApiPackage"]>

  export type WhatsappApiPackageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonth?: boolean
    priceYear?: boolean
    maxSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["whatsappApiPackage"]>

  export type WhatsappApiPackageSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonth?: boolean
    priceYear?: boolean
    maxSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsappApiPackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "priceMonth" | "priceYear" | "maxSession" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsappApiPackage"]>
  export type WhatsappApiPackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsappCustomers?: boolean | WhatsappApiPackage$whatsappCustomersArgs<ExtArgs>
    whatsappTransactions?: boolean | WhatsappApiPackage$whatsappTransactionsArgs<ExtArgs>
    _count?: boolean | WhatsappApiPackageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsappApiPackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WhatsappApiPackageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WhatsappApiPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsappApiPackage"
    objects: {
      whatsappCustomers: Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>[]
      whatsappTransactions: Prisma.$TransactionWhatsappServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      priceMonth: number
      priceYear: number
      maxSession: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsappApiPackage"]>
    composites: {}
  }

  type WhatsappApiPackageGetPayload<S extends boolean | null | undefined | WhatsappApiPackageDefaultArgs> = $Result.GetResult<Prisma.$WhatsappApiPackagePayload, S>

  type WhatsappApiPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsappApiPackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsappApiPackageCountAggregateInputType | true
    }

  export interface WhatsappApiPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsappApiPackage'], meta: { name: 'WhatsappApiPackage' } }
    /**
     * Find zero or one WhatsappApiPackage that matches the filter.
     * @param {WhatsappApiPackageFindUniqueArgs} args - Arguments to find a WhatsappApiPackage
     * @example
     * // Get one WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsappApiPackageFindUniqueArgs>(args: SelectSubset<T, WhatsappApiPackageFindUniqueArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsappApiPackage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsappApiPackageFindUniqueOrThrowArgs} args - Arguments to find a WhatsappApiPackage
     * @example
     * // Get one WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsappApiPackageFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsappApiPackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsappApiPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageFindFirstArgs} args - Arguments to find a WhatsappApiPackage
     * @example
     * // Get one WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsappApiPackageFindFirstArgs>(args?: SelectSubset<T, WhatsappApiPackageFindFirstArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsappApiPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageFindFirstOrThrowArgs} args - Arguments to find a WhatsappApiPackage
     * @example
     * // Get one WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsappApiPackageFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsappApiPackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsappApiPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsappApiPackages
     * const whatsappApiPackages = await prisma.whatsappApiPackage.findMany()
     * 
     * // Get first 10 WhatsappApiPackages
     * const whatsappApiPackages = await prisma.whatsappApiPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsappApiPackageWithIdOnly = await prisma.whatsappApiPackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsappApiPackageFindManyArgs>(args?: SelectSubset<T, WhatsappApiPackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsappApiPackage.
     * @param {WhatsappApiPackageCreateArgs} args - Arguments to create a WhatsappApiPackage.
     * @example
     * // Create one WhatsappApiPackage
     * const WhatsappApiPackage = await prisma.whatsappApiPackage.create({
     *   data: {
     *     // ... data to create a WhatsappApiPackage
     *   }
     * })
     * 
     */
    create<T extends WhatsappApiPackageCreateArgs>(args: SelectSubset<T, WhatsappApiPackageCreateArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsappApiPackages.
     * @param {WhatsappApiPackageCreateManyArgs} args - Arguments to create many WhatsappApiPackages.
     * @example
     * // Create many WhatsappApiPackages
     * const whatsappApiPackage = await prisma.whatsappApiPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsappApiPackageCreateManyArgs>(args?: SelectSubset<T, WhatsappApiPackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsappApiPackages and returns the data saved in the database.
     * @param {WhatsappApiPackageCreateManyAndReturnArgs} args - Arguments to create many WhatsappApiPackages.
     * @example
     * // Create many WhatsappApiPackages
     * const whatsappApiPackage = await prisma.whatsappApiPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsappApiPackages and only return the `id`
     * const whatsappApiPackageWithIdOnly = await prisma.whatsappApiPackage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsappApiPackageCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsappApiPackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsappApiPackage.
     * @param {WhatsappApiPackageDeleteArgs} args - Arguments to delete one WhatsappApiPackage.
     * @example
     * // Delete one WhatsappApiPackage
     * const WhatsappApiPackage = await prisma.whatsappApiPackage.delete({
     *   where: {
     *     // ... filter to delete one WhatsappApiPackage
     *   }
     * })
     * 
     */
    delete<T extends WhatsappApiPackageDeleteArgs>(args: SelectSubset<T, WhatsappApiPackageDeleteArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsappApiPackage.
     * @param {WhatsappApiPackageUpdateArgs} args - Arguments to update one WhatsappApiPackage.
     * @example
     * // Update one WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsappApiPackageUpdateArgs>(args: SelectSubset<T, WhatsappApiPackageUpdateArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsappApiPackages.
     * @param {WhatsappApiPackageDeleteManyArgs} args - Arguments to filter WhatsappApiPackages to delete.
     * @example
     * // Delete a few WhatsappApiPackages
     * const { count } = await prisma.whatsappApiPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsappApiPackageDeleteManyArgs>(args?: SelectSubset<T, WhatsappApiPackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappApiPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsappApiPackages
     * const whatsappApiPackage = await prisma.whatsappApiPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsappApiPackageUpdateManyArgs>(args: SelectSubset<T, WhatsappApiPackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappApiPackages and returns the data updated in the database.
     * @param {WhatsappApiPackageUpdateManyAndReturnArgs} args - Arguments to update many WhatsappApiPackages.
     * @example
     * // Update many WhatsappApiPackages
     * const whatsappApiPackage = await prisma.whatsappApiPackage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsappApiPackages and only return the `id`
     * const whatsappApiPackageWithIdOnly = await prisma.whatsappApiPackage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsappApiPackageUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsappApiPackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsappApiPackage.
     * @param {WhatsappApiPackageUpsertArgs} args - Arguments to update or create a WhatsappApiPackage.
     * @example
     * // Update or create a WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.upsert({
     *   create: {
     *     // ... data to create a WhatsappApiPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsappApiPackage we want to update
     *   }
     * })
     */
    upsert<T extends WhatsappApiPackageUpsertArgs>(args: SelectSubset<T, WhatsappApiPackageUpsertArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsappApiPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageCountArgs} args - Arguments to filter WhatsappApiPackages to count.
     * @example
     * // Count the number of WhatsappApiPackages
     * const count = await prisma.whatsappApiPackage.count({
     *   where: {
     *     // ... the filter for the WhatsappApiPackages we want to count
     *   }
     * })
    **/
    count<T extends WhatsappApiPackageCountArgs>(
      args?: Subset<T, WhatsappApiPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsappApiPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsappApiPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsappApiPackageAggregateArgs>(args: Subset<T, WhatsappApiPackageAggregateArgs>): Prisma.PrismaPromise<GetWhatsappApiPackageAggregateType<T>>

    /**
     * Group by WhatsappApiPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsappApiPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsappApiPackageGroupByArgs['orderBy'] }
        : { orderBy?: WhatsappApiPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsappApiPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsappApiPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsappApiPackage model
   */
  readonly fields: WhatsappApiPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsappApiPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsappApiPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsappCustomers<T extends WhatsappApiPackage$whatsappCustomersArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappApiPackage$whatsappCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappTransactions<T extends WhatsappApiPackage$whatsappTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappApiPackage$whatsappTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsappApiPackage model
   */
  interface WhatsappApiPackageFieldRefs {
    readonly id: FieldRef<"WhatsappApiPackage", 'String'>
    readonly name: FieldRef<"WhatsappApiPackage", 'String'>
    readonly description: FieldRef<"WhatsappApiPackage", 'String'>
    readonly priceMonth: FieldRef<"WhatsappApiPackage", 'Int'>
    readonly priceYear: FieldRef<"WhatsappApiPackage", 'Int'>
    readonly maxSession: FieldRef<"WhatsappApiPackage", 'Int'>
    readonly createdAt: FieldRef<"WhatsappApiPackage", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsappApiPackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsappApiPackage findUnique
   */
  export type WhatsappApiPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappApiPackage to fetch.
     */
    where: WhatsappApiPackageWhereUniqueInput
  }

  /**
   * WhatsappApiPackage findUniqueOrThrow
   */
  export type WhatsappApiPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappApiPackage to fetch.
     */
    where: WhatsappApiPackageWhereUniqueInput
  }

  /**
   * WhatsappApiPackage findFirst
   */
  export type WhatsappApiPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappApiPackage to fetch.
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappApiPackages to fetch.
     */
    orderBy?: WhatsappApiPackageOrderByWithRelationInput | WhatsappApiPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappApiPackages.
     */
    cursor?: WhatsappApiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappApiPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappApiPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappApiPackages.
     */
    distinct?: WhatsappApiPackageScalarFieldEnum | WhatsappApiPackageScalarFieldEnum[]
  }

  /**
   * WhatsappApiPackage findFirstOrThrow
   */
  export type WhatsappApiPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappApiPackage to fetch.
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappApiPackages to fetch.
     */
    orderBy?: WhatsappApiPackageOrderByWithRelationInput | WhatsappApiPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappApiPackages.
     */
    cursor?: WhatsappApiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappApiPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappApiPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappApiPackages.
     */
    distinct?: WhatsappApiPackageScalarFieldEnum | WhatsappApiPackageScalarFieldEnum[]
  }

  /**
   * WhatsappApiPackage findMany
   */
  export type WhatsappApiPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappApiPackages to fetch.
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappApiPackages to fetch.
     */
    orderBy?: WhatsappApiPackageOrderByWithRelationInput | WhatsappApiPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsappApiPackages.
     */
    cursor?: WhatsappApiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappApiPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappApiPackages.
     */
    skip?: number
    distinct?: WhatsappApiPackageScalarFieldEnum | WhatsappApiPackageScalarFieldEnum[]
  }

  /**
   * WhatsappApiPackage create
   */
  export type WhatsappApiPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsappApiPackage.
     */
    data: XOR<WhatsappApiPackageCreateInput, WhatsappApiPackageUncheckedCreateInput>
  }

  /**
   * WhatsappApiPackage createMany
   */
  export type WhatsappApiPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsappApiPackages.
     */
    data: WhatsappApiPackageCreateManyInput | WhatsappApiPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsappApiPackage createManyAndReturn
   */
  export type WhatsappApiPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsappApiPackages.
     */
    data: WhatsappApiPackageCreateManyInput | WhatsappApiPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsappApiPackage update
   */
  export type WhatsappApiPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsappApiPackage.
     */
    data: XOR<WhatsappApiPackageUpdateInput, WhatsappApiPackageUncheckedUpdateInput>
    /**
     * Choose, which WhatsappApiPackage to update.
     */
    where: WhatsappApiPackageWhereUniqueInput
  }

  /**
   * WhatsappApiPackage updateMany
   */
  export type WhatsappApiPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsappApiPackages.
     */
    data: XOR<WhatsappApiPackageUpdateManyMutationInput, WhatsappApiPackageUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappApiPackages to update
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * Limit how many WhatsappApiPackages to update.
     */
    limit?: number
  }

  /**
   * WhatsappApiPackage updateManyAndReturn
   */
  export type WhatsappApiPackageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * The data used to update WhatsappApiPackages.
     */
    data: XOR<WhatsappApiPackageUpdateManyMutationInput, WhatsappApiPackageUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappApiPackages to update
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * Limit how many WhatsappApiPackages to update.
     */
    limit?: number
  }

  /**
   * WhatsappApiPackage upsert
   */
  export type WhatsappApiPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsappApiPackage to update in case it exists.
     */
    where: WhatsappApiPackageWhereUniqueInput
    /**
     * In case the WhatsappApiPackage found by the `where` argument doesn't exist, create a new WhatsappApiPackage with this data.
     */
    create: XOR<WhatsappApiPackageCreateInput, WhatsappApiPackageUncheckedCreateInput>
    /**
     * In case the WhatsappApiPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsappApiPackageUpdateInput, WhatsappApiPackageUncheckedUpdateInput>
  }

  /**
   * WhatsappApiPackage delete
   */
  export type WhatsappApiPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter which WhatsappApiPackage to delete.
     */
    where: WhatsappApiPackageWhereUniqueInput
  }

  /**
   * WhatsappApiPackage deleteMany
   */
  export type WhatsappApiPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappApiPackages to delete
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * Limit how many WhatsappApiPackages to delete.
     */
    limit?: number
  }

  /**
   * WhatsappApiPackage.whatsappCustomers
   */
  export type WhatsappApiPackage$whatsappCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    where?: ServicesWhatsappCustomersWhereInput
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * WhatsappApiPackage.whatsappTransactions
   */
  export type WhatsappApiPackage$whatsappTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    where?: TransactionWhatsappServiceWhereInput
    orderBy?: TransactionWhatsappServiceOrderByWithRelationInput | TransactionWhatsappServiceOrderByWithRelationInput[]
    cursor?: TransactionWhatsappServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionWhatsappServiceScalarFieldEnum | TransactionWhatsappServiceScalarFieldEnum[]
  }

  /**
   * WhatsappApiPackage without action
   */
  export type WhatsappApiPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
  }


  /**
   * Model ServicesWhatsappCustomers
   */

  export type AggregateServicesWhatsappCustomers = {
    _count: ServicesWhatsappCustomersCountAggregateOutputType | null
    _min: ServicesWhatsappCustomersMinAggregateOutputType | null
    _max: ServicesWhatsappCustomersMaxAggregateOutputType | null
  }

  export type ServicesWhatsappCustomersMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    packageId: string | null
    status: string | null
    expiredAt: Date | null
    activatedAt: Date | null
    updatedAt: Date | null
    lastSubscriptionAt: Date | null
  }

  export type ServicesWhatsappCustomersMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    packageId: string | null
    status: string | null
    expiredAt: Date | null
    activatedAt: Date | null
    updatedAt: Date | null
    lastSubscriptionAt: Date | null
  }

  export type ServicesWhatsappCustomersCountAggregateOutputType = {
    id: number
    customerId: number
    packageId: number
    status: number
    expiredAt: number
    activatedAt: number
    updatedAt: number
    lastSubscriptionAt: number
    _all: number
  }


  export type ServicesWhatsappCustomersMinAggregateInputType = {
    id?: true
    customerId?: true
    packageId?: true
    status?: true
    expiredAt?: true
    activatedAt?: true
    updatedAt?: true
    lastSubscriptionAt?: true
  }

  export type ServicesWhatsappCustomersMaxAggregateInputType = {
    id?: true
    customerId?: true
    packageId?: true
    status?: true
    expiredAt?: true
    activatedAt?: true
    updatedAt?: true
    lastSubscriptionAt?: true
  }

  export type ServicesWhatsappCustomersCountAggregateInputType = {
    id?: true
    customerId?: true
    packageId?: true
    status?: true
    expiredAt?: true
    activatedAt?: true
    updatedAt?: true
    lastSubscriptionAt?: true
    _all?: true
  }

  export type ServicesWhatsappCustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicesWhatsappCustomers to aggregate.
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesWhatsappCustomers to fetch.
     */
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesWhatsappCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesWhatsappCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicesWhatsappCustomers
    **/
    _count?: true | ServicesWhatsappCustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesWhatsappCustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesWhatsappCustomersMaxAggregateInputType
  }

  export type GetServicesWhatsappCustomersAggregateType<T extends ServicesWhatsappCustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateServicesWhatsappCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicesWhatsappCustomers[P]>
      : GetScalarType<T[P], AggregateServicesWhatsappCustomers[P]>
  }




  export type ServicesWhatsappCustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhatsappCustomersWhereInput
    orderBy?: ServicesWhatsappCustomersOrderByWithAggregationInput | ServicesWhatsappCustomersOrderByWithAggregationInput[]
    by: ServicesWhatsappCustomersScalarFieldEnum[] | ServicesWhatsappCustomersScalarFieldEnum
    having?: ServicesWhatsappCustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesWhatsappCustomersCountAggregateInputType | true
    _min?: ServicesWhatsappCustomersMinAggregateInputType
    _max?: ServicesWhatsappCustomersMaxAggregateInputType
  }

  export type ServicesWhatsappCustomersGroupByOutputType = {
    id: string
    customerId: string
    packageId: string
    status: string
    expiredAt: Date
    activatedAt: Date
    updatedAt: Date
    lastSubscriptionAt: Date
    _count: ServicesWhatsappCustomersCountAggregateOutputType | null
    _min: ServicesWhatsappCustomersMinAggregateOutputType | null
    _max: ServicesWhatsappCustomersMaxAggregateOutputType | null
  }

  type GetServicesWhatsappCustomersGroupByPayload<T extends ServicesWhatsappCustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicesWhatsappCustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesWhatsappCustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesWhatsappCustomersGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesWhatsappCustomersGroupByOutputType[P]>
        }
      >
    >


  export type ServicesWhatsappCustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    packageId?: boolean
    status?: boolean
    expiredAt?: boolean
    activatedAt?: boolean
    updatedAt?: boolean
    lastSubscriptionAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicesWhatsappCustomers"]>

  export type ServicesWhatsappCustomersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    packageId?: boolean
    status?: boolean
    expiredAt?: boolean
    activatedAt?: boolean
    updatedAt?: boolean
    lastSubscriptionAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicesWhatsappCustomers"]>

  export type ServicesWhatsappCustomersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    packageId?: boolean
    status?: boolean
    expiredAt?: boolean
    activatedAt?: boolean
    updatedAt?: boolean
    lastSubscriptionAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicesWhatsappCustomers"]>

  export type ServicesWhatsappCustomersSelectScalar = {
    id?: boolean
    customerId?: boolean
    packageId?: boolean
    status?: boolean
    expiredAt?: boolean
    activatedAt?: boolean
    updatedAt?: boolean
    lastSubscriptionAt?: boolean
  }

  export type ServicesWhatsappCustomersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "packageId" | "status" | "expiredAt" | "activatedAt" | "updatedAt" | "lastSubscriptionAt", ExtArgs["result"]["servicesWhatsappCustomers"]>
  export type ServicesWhatsappCustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }
  export type ServicesWhatsappCustomersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }
  export type ServicesWhatsappCustomersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }

  export type $ServicesWhatsappCustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicesWhatsappCustomers"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      package: Prisma.$WhatsappApiPackagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      packageId: string
      status: string
      expiredAt: Date
      activatedAt: Date
      updatedAt: Date
      lastSubscriptionAt: Date
    }, ExtArgs["result"]["servicesWhatsappCustomers"]>
    composites: {}
  }

  type ServicesWhatsappCustomersGetPayload<S extends boolean | null | undefined | ServicesWhatsappCustomersDefaultArgs> = $Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload, S>

  type ServicesWhatsappCustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicesWhatsappCustomersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicesWhatsappCustomersCountAggregateInputType | true
    }

  export interface ServicesWhatsappCustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicesWhatsappCustomers'], meta: { name: 'ServicesWhatsappCustomers' } }
    /**
     * Find zero or one ServicesWhatsappCustomers that matches the filter.
     * @param {ServicesWhatsappCustomersFindUniqueArgs} args - Arguments to find a ServicesWhatsappCustomers
     * @example
     * // Get one ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicesWhatsappCustomersFindUniqueArgs>(args: SelectSubset<T, ServicesWhatsappCustomersFindUniqueArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServicesWhatsappCustomers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicesWhatsappCustomersFindUniqueOrThrowArgs} args - Arguments to find a ServicesWhatsappCustomers
     * @example
     * // Get one ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicesWhatsappCustomersFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicesWhatsappCustomersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicesWhatsappCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersFindFirstArgs} args - Arguments to find a ServicesWhatsappCustomers
     * @example
     * // Get one ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicesWhatsappCustomersFindFirstArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersFindFirstArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicesWhatsappCustomers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersFindFirstOrThrowArgs} args - Arguments to find a ServicesWhatsappCustomers
     * @example
     * // Get one ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicesWhatsappCustomersFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicesWhatsappCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findMany()
     * 
     * // Get first 10 ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesWhatsappCustomersWithIdOnly = await prisma.servicesWhatsappCustomers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicesWhatsappCustomersFindManyArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersCreateArgs} args - Arguments to create a ServicesWhatsappCustomers.
     * @example
     * // Create one ServicesWhatsappCustomers
     * const ServicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.create({
     *   data: {
     *     // ... data to create a ServicesWhatsappCustomers
     *   }
     * })
     * 
     */
    create<T extends ServicesWhatsappCustomersCreateArgs>(args: SelectSubset<T, ServicesWhatsappCustomersCreateArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersCreateManyArgs} args - Arguments to create many ServicesWhatsappCustomers.
     * @example
     * // Create many ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicesWhatsappCustomersCreateManyArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicesWhatsappCustomers and returns the data saved in the database.
     * @param {ServicesWhatsappCustomersCreateManyAndReturnArgs} args - Arguments to create many ServicesWhatsappCustomers.
     * @example
     * // Create many ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicesWhatsappCustomers and only return the `id`
     * const servicesWhatsappCustomersWithIdOnly = await prisma.servicesWhatsappCustomers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicesWhatsappCustomersCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersDeleteArgs} args - Arguments to delete one ServicesWhatsappCustomers.
     * @example
     * // Delete one ServicesWhatsappCustomers
     * const ServicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.delete({
     *   where: {
     *     // ... filter to delete one ServicesWhatsappCustomers
     *   }
     * })
     * 
     */
    delete<T extends ServicesWhatsappCustomersDeleteArgs>(args: SelectSubset<T, ServicesWhatsappCustomersDeleteArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersUpdateArgs} args - Arguments to update one ServicesWhatsappCustomers.
     * @example
     * // Update one ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicesWhatsappCustomersUpdateArgs>(args: SelectSubset<T, ServicesWhatsappCustomersUpdateArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersDeleteManyArgs} args - Arguments to filter ServicesWhatsappCustomers to delete.
     * @example
     * // Delete a few ServicesWhatsappCustomers
     * const { count } = await prisma.servicesWhatsappCustomers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicesWhatsappCustomersDeleteManyArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicesWhatsappCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicesWhatsappCustomersUpdateManyArgs>(args: SelectSubset<T, ServicesWhatsappCustomersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicesWhatsappCustomers and returns the data updated in the database.
     * @param {ServicesWhatsappCustomersUpdateManyAndReturnArgs} args - Arguments to update many ServicesWhatsappCustomers.
     * @example
     * // Update many ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServicesWhatsappCustomers and only return the `id`
     * const servicesWhatsappCustomersWithIdOnly = await prisma.servicesWhatsappCustomers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicesWhatsappCustomersUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicesWhatsappCustomersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersUpsertArgs} args - Arguments to update or create a ServicesWhatsappCustomers.
     * @example
     * // Update or create a ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.upsert({
     *   create: {
     *     // ... data to create a ServicesWhatsappCustomers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicesWhatsappCustomers we want to update
     *   }
     * })
     */
    upsert<T extends ServicesWhatsappCustomersUpsertArgs>(args: SelectSubset<T, ServicesWhatsappCustomersUpsertArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServicesWhatsappCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersCountArgs} args - Arguments to filter ServicesWhatsappCustomers to count.
     * @example
     * // Count the number of ServicesWhatsappCustomers
     * const count = await prisma.servicesWhatsappCustomers.count({
     *   where: {
     *     // ... the filter for the ServicesWhatsappCustomers we want to count
     *   }
     * })
    **/
    count<T extends ServicesWhatsappCustomersCountArgs>(
      args?: Subset<T, ServicesWhatsappCustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesWhatsappCustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicesWhatsappCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesWhatsappCustomersAggregateArgs>(args: Subset<T, ServicesWhatsappCustomersAggregateArgs>): Prisma.PrismaPromise<GetServicesWhatsappCustomersAggregateType<T>>

    /**
     * Group by ServicesWhatsappCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesWhatsappCustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesWhatsappCustomersGroupByArgs['orderBy'] }
        : { orderBy?: ServicesWhatsappCustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesWhatsappCustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesWhatsappCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicesWhatsappCustomers model
   */
  readonly fields: ServicesWhatsappCustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicesWhatsappCustomers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicesWhatsappCustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    package<T extends WhatsappApiPackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappApiPackageDefaultArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicesWhatsappCustomers model
   */
  interface ServicesWhatsappCustomersFieldRefs {
    readonly id: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly customerId: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly packageId: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly status: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly expiredAt: FieldRef<"ServicesWhatsappCustomers", 'DateTime'>
    readonly activatedAt: FieldRef<"ServicesWhatsappCustomers", 'DateTime'>
    readonly updatedAt: FieldRef<"ServicesWhatsappCustomers", 'DateTime'>
    readonly lastSubscriptionAt: FieldRef<"ServicesWhatsappCustomers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicesWhatsappCustomers findUnique
   */
  export type ServicesWhatsappCustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesWhatsappCustomers to fetch.
     */
    where: ServicesWhatsappCustomersWhereUniqueInput
  }

  /**
   * ServicesWhatsappCustomers findUniqueOrThrow
   */
  export type ServicesWhatsappCustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesWhatsappCustomers to fetch.
     */
    where: ServicesWhatsappCustomersWhereUniqueInput
  }

  /**
   * ServicesWhatsappCustomers findFirst
   */
  export type ServicesWhatsappCustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesWhatsappCustomers to fetch.
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesWhatsappCustomers to fetch.
     */
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicesWhatsappCustomers.
     */
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesWhatsappCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesWhatsappCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicesWhatsappCustomers.
     */
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * ServicesWhatsappCustomers findFirstOrThrow
   */
  export type ServicesWhatsappCustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesWhatsappCustomers to fetch.
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesWhatsappCustomers to fetch.
     */
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicesWhatsappCustomers.
     */
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesWhatsappCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesWhatsappCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicesWhatsappCustomers.
     */
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * ServicesWhatsappCustomers findMany
   */
  export type ServicesWhatsappCustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesWhatsappCustomers to fetch.
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesWhatsappCustomers to fetch.
     */
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicesWhatsappCustomers.
     */
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesWhatsappCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesWhatsappCustomers.
     */
    skip?: number
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * ServicesWhatsappCustomers create
   */
  export type ServicesWhatsappCustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicesWhatsappCustomers.
     */
    data: XOR<ServicesWhatsappCustomersCreateInput, ServicesWhatsappCustomersUncheckedCreateInput>
  }

  /**
   * ServicesWhatsappCustomers createMany
   */
  export type ServicesWhatsappCustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicesWhatsappCustomers.
     */
    data: ServicesWhatsappCustomersCreateManyInput | ServicesWhatsappCustomersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicesWhatsappCustomers createManyAndReturn
   */
  export type ServicesWhatsappCustomersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * The data used to create many ServicesWhatsappCustomers.
     */
    data: ServicesWhatsappCustomersCreateManyInput | ServicesWhatsappCustomersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicesWhatsappCustomers update
   */
  export type ServicesWhatsappCustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicesWhatsappCustomers.
     */
    data: XOR<ServicesWhatsappCustomersUpdateInput, ServicesWhatsappCustomersUncheckedUpdateInput>
    /**
     * Choose, which ServicesWhatsappCustomers to update.
     */
    where: ServicesWhatsappCustomersWhereUniqueInput
  }

  /**
   * ServicesWhatsappCustomers updateMany
   */
  export type ServicesWhatsappCustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicesWhatsappCustomers.
     */
    data: XOR<ServicesWhatsappCustomersUpdateManyMutationInput, ServicesWhatsappCustomersUncheckedUpdateManyInput>
    /**
     * Filter which ServicesWhatsappCustomers to update
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * Limit how many ServicesWhatsappCustomers to update.
     */
    limit?: number
  }

  /**
   * ServicesWhatsappCustomers updateManyAndReturn
   */
  export type ServicesWhatsappCustomersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * The data used to update ServicesWhatsappCustomers.
     */
    data: XOR<ServicesWhatsappCustomersUpdateManyMutationInput, ServicesWhatsappCustomersUncheckedUpdateManyInput>
    /**
     * Filter which ServicesWhatsappCustomers to update
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * Limit how many ServicesWhatsappCustomers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicesWhatsappCustomers upsert
   */
  export type ServicesWhatsappCustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicesWhatsappCustomers to update in case it exists.
     */
    where: ServicesWhatsappCustomersWhereUniqueInput
    /**
     * In case the ServicesWhatsappCustomers found by the `where` argument doesn't exist, create a new ServicesWhatsappCustomers with this data.
     */
    create: XOR<ServicesWhatsappCustomersCreateInput, ServicesWhatsappCustomersUncheckedCreateInput>
    /**
     * In case the ServicesWhatsappCustomers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicesWhatsappCustomersUpdateInput, ServicesWhatsappCustomersUncheckedUpdateInput>
  }

  /**
   * ServicesWhatsappCustomers delete
   */
  export type ServicesWhatsappCustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter which ServicesWhatsappCustomers to delete.
     */
    where: ServicesWhatsappCustomersWhereUniqueInput
  }

  /**
   * ServicesWhatsappCustomers deleteMany
   */
  export type ServicesWhatsappCustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicesWhatsappCustomers to delete
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * Limit how many ServicesWhatsappCustomers to delete.
     */
    limit?: number
  }

  /**
   * ServicesWhatsappCustomers without action
   */
  export type ServicesWhatsappCustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    userId: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean | null
    lastUsed: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type UserSessionMaxAggregateOutputType = {
    userId: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean | null
    lastUsed: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type UserSessionCountAggregateOutputType = {
    userId: number
    token: number
    deviceInfo: number
    ipAddress: number
    userAgent: number
    isActive: number
    lastUsed: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type UserSessionMaxAggregateInputType = {
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type UserSessionCountAggregateInputType = {
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    userId: string
    token: string
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean
    lastUsed: Date
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    id: string
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "token" | "deviceInfo" | "ipAddress" | "userAgent" | "isActive" | "lastUsed" | "expiresAt" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      token: string
      deviceInfo: string | null
      ipAddress: string | null
      userAgent: string | null
      isActive: boolean
      lastUsed: Date
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSessionWithUserIdOnly = await prisma.userSession.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `userId`
     * const userSessionWithUserIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `userId`
     * const userSessionWithUserIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly token: FieldRef<"UserSession", 'String'>
    readonly deviceInfo: FieldRef<"UserSession", 'String'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly userAgent: FieldRef<"UserSession", 'String'>
    readonly isActive: FieldRef<"UserSession", 'Boolean'>
    readonly lastUsed: FieldRef<"UserSession", 'DateTime'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
    readonly id: FieldRef<"UserSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model Voucher
   */

  export type AggregateVoucher = {
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  export type VoucherAvgAggregateOutputType = {
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    maxUses: number | null
    usedCount: number | null
  }

  export type VoucherSumAggregateOutputType = {
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    maxUses: number | null
    usedCount: number | null
  }

  export type VoucherMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: string | null
    discountType: string | null
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    maxUses: number | null
    usedCount: number | null
    allowMultipleUsePerUser: boolean | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: string | null
    discountType: string | null
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    maxUses: number | null
    usedCount: number | null
    allowMultipleUsePerUser: boolean | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    type: number
    discountType: number
    value: number
    minAmount: number
    maxDiscount: number
    maxUses: number
    usedCount: number
    allowMultipleUsePerUser: number
    isActive: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoucherAvgAggregateInputType = {
    value?: true
    minAmount?: true
    maxDiscount?: true
    maxUses?: true
    usedCount?: true
  }

  export type VoucherSumAggregateInputType = {
    value?: true
    minAmount?: true
    maxDiscount?: true
    maxUses?: true
    usedCount?: true
  }

  export type VoucherMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    discountType?: true
    value?: true
    minAmount?: true
    maxDiscount?: true
    maxUses?: true
    usedCount?: true
    allowMultipleUsePerUser?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    discountType?: true
    value?: true
    minAmount?: true
    maxDiscount?: true
    maxUses?: true
    usedCount?: true
    allowMultipleUsePerUser?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    discountType?: true
    value?: true
    minAmount?: true
    maxDiscount?: true
    maxUses?: true
    usedCount?: true
    allowMultipleUsePerUser?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voucher to aggregate.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vouchers
    **/
    _count?: true | VoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherMaxAggregateInputType
  }

  export type GetVoucherAggregateType<T extends VoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucher[P]>
      : GetScalarType<T[P], AggregateVoucher[P]>
  }




  export type VoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithAggregationInput | VoucherOrderByWithAggregationInput[]
    by: VoucherScalarFieldEnum[] | VoucherScalarFieldEnum
    having?: VoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherCountAggregateInputType | true
    _avg?: VoucherAvgAggregateInputType
    _sum?: VoucherSumAggregateInputType
    _min?: VoucherMinAggregateInputType
    _max?: VoucherMaxAggregateInputType
  }

  export type VoucherGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    type: string
    discountType: string
    value: Decimal
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    maxUses: number | null
    usedCount: number
    allowMultipleUsePerUser: boolean
    isActive: boolean
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  type GetVoucherGroupByPayload<T extends VoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountType?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    maxUses?: boolean
    usedCount?: boolean
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | Voucher$transactionsArgs<ExtArgs>
    voucherUsage?: boolean | Voucher$voucherUsageArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountType?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    maxUses?: boolean
    usedCount?: boolean
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountType?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    maxUses?: boolean
    usedCount?: boolean
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountType?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    maxUses?: boolean
    usedCount?: boolean
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoucherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "type" | "discountType" | "value" | "minAmount" | "maxDiscount" | "maxUses" | "usedCount" | "allowMultipleUsePerUser" | "isActive" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["voucher"]>
  export type VoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Voucher$transactionsArgs<ExtArgs>
    voucherUsage?: boolean | Voucher$voucherUsageArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VoucherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voucher"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      voucherUsage: Prisma.$VoucherUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      type: string
      discountType: string
      value: Prisma.Decimal
      minAmount: Prisma.Decimal | null
      maxDiscount: Prisma.Decimal | null
      maxUses: number | null
      usedCount: number
      allowMultipleUsePerUser: boolean
      isActive: boolean
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["voucher"]>
    composites: {}
  }

  type VoucherGetPayload<S extends boolean | null | undefined | VoucherDefaultArgs> = $Result.GetResult<Prisma.$VoucherPayload, S>

  type VoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherCountAggregateInputType | true
    }

  export interface VoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voucher'], meta: { name: 'Voucher' } }
    /**
     * Find zero or one Voucher that matches the filter.
     * @param {VoucherFindUniqueArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherFindUniqueArgs>(args: SelectSubset<T, VoucherFindUniqueArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Voucher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherFindUniqueOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherFindFirstArgs>(args?: SelectSubset<T, VoucherFindFirstArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vouchers
     * const vouchers = await prisma.voucher.findMany()
     * 
     * // Get first 10 Vouchers
     * const vouchers = await prisma.voucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherWithIdOnly = await prisma.voucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherFindManyArgs>(args?: SelectSubset<T, VoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Voucher.
     * @param {VoucherCreateArgs} args - Arguments to create a Voucher.
     * @example
     * // Create one Voucher
     * const Voucher = await prisma.voucher.create({
     *   data: {
     *     // ... data to create a Voucher
     *   }
     * })
     * 
     */
    create<T extends VoucherCreateArgs>(args: SelectSubset<T, VoucherCreateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vouchers.
     * @param {VoucherCreateManyArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherCreateManyArgs>(args?: SelectSubset<T, VoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vouchers and returns the data saved in the database.
     * @param {VoucherCreateManyAndReturnArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Voucher.
     * @param {VoucherDeleteArgs} args - Arguments to delete one Voucher.
     * @example
     * // Delete one Voucher
     * const Voucher = await prisma.voucher.delete({
     *   where: {
     *     // ... filter to delete one Voucher
     *   }
     * })
     * 
     */
    delete<T extends VoucherDeleteArgs>(args: SelectSubset<T, VoucherDeleteArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Voucher.
     * @param {VoucherUpdateArgs} args - Arguments to update one Voucher.
     * @example
     * // Update one Voucher
     * const voucher = await prisma.voucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUpdateArgs>(args: SelectSubset<T, VoucherUpdateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vouchers.
     * @param {VoucherDeleteManyArgs} args - Arguments to filter Vouchers to delete.
     * @example
     * // Delete a few Vouchers
     * const { count } = await prisma.voucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherDeleteManyArgs>(args?: SelectSubset<T, VoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUpdateManyArgs>(args: SelectSubset<T, VoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers and returns the data updated in the database.
     * @param {VoucherUpdateManyAndReturnArgs} args - Arguments to update many Vouchers.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Voucher.
     * @param {VoucherUpsertArgs} args - Arguments to update or create a Voucher.
     * @example
     * // Update or create a Voucher
     * const voucher = await prisma.voucher.upsert({
     *   create: {
     *     // ... data to create a Voucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voucher we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUpsertArgs>(args: SelectSubset<T, VoucherUpsertArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherCountArgs} args - Arguments to filter Vouchers to count.
     * @example
     * // Count the number of Vouchers
     * const count = await prisma.voucher.count({
     *   where: {
     *     // ... the filter for the Vouchers we want to count
     *   }
     * })
    **/
    count<T extends VoucherCountArgs>(
      args?: Subset<T, VoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherAggregateArgs>(args: Subset<T, VoucherAggregateArgs>): Prisma.PrismaPromise<GetVoucherAggregateType<T>>

    /**
     * Group by Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherGroupByArgs['orderBy'] }
        : { orderBy?: VoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voucher model
   */
  readonly fields: VoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Voucher$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voucherUsage<T extends Voucher$voucherUsageArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$voucherUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Voucher model
   */
  interface VoucherFieldRefs {
    readonly id: FieldRef<"Voucher", 'String'>
    readonly code: FieldRef<"Voucher", 'String'>
    readonly name: FieldRef<"Voucher", 'String'>
    readonly description: FieldRef<"Voucher", 'String'>
    readonly type: FieldRef<"Voucher", 'String'>
    readonly discountType: FieldRef<"Voucher", 'String'>
    readonly value: FieldRef<"Voucher", 'Decimal'>
    readonly minAmount: FieldRef<"Voucher", 'Decimal'>
    readonly maxDiscount: FieldRef<"Voucher", 'Decimal'>
    readonly maxUses: FieldRef<"Voucher", 'Int'>
    readonly usedCount: FieldRef<"Voucher", 'Int'>
    readonly allowMultipleUsePerUser: FieldRef<"Voucher", 'Boolean'>
    readonly isActive: FieldRef<"Voucher", 'Boolean'>
    readonly startDate: FieldRef<"Voucher", 'DateTime'>
    readonly endDate: FieldRef<"Voucher", 'DateTime'>
    readonly createdAt: FieldRef<"Voucher", 'DateTime'>
    readonly updatedAt: FieldRef<"Voucher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Voucher findUnique
   */
  export type VoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findUniqueOrThrow
   */
  export type VoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findFirst
   */
  export type VoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findFirstOrThrow
   */
  export type VoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findMany
   */
  export type VoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Vouchers to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher create
   */
  export type VoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a Voucher.
     */
    data: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
  }

  /**
   * Voucher createMany
   */
  export type VoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher createManyAndReturn
   */
  export type VoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher update
   */
  export type VoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a Voucher.
     */
    data: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
    /**
     * Choose, which Voucher to update.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher updateMany
   */
  export type VoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher updateManyAndReturn
   */
  export type VoucherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher upsert
   */
  export type VoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the Voucher to update in case it exists.
     */
    where: VoucherWhereUniqueInput
    /**
     * In case the Voucher found by the `where` argument doesn't exist, create a new Voucher with this data.
     */
    create: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
    /**
     * In case the Voucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
  }

  /**
   * Voucher delete
   */
  export type VoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter which Voucher to delete.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher deleteMany
   */
  export type VoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vouchers to delete
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to delete.
     */
    limit?: number
  }

  /**
   * Voucher.transactions
   */
  export type Voucher$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Voucher.voucherUsage
   */
  export type Voucher$voucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    cursor?: VoucherUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * Voucher without action
   */
  export type VoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
  }


  /**
   * Model VoucherUsage
   */

  export type AggregateVoucherUsage = {
    _count: VoucherUsageCountAggregateOutputType | null
    _avg: VoucherUsageAvgAggregateOutputType | null
    _sum: VoucherUsageSumAggregateOutputType | null
    _min: VoucherUsageMinAggregateOutputType | null
    _max: VoucherUsageMaxAggregateOutputType | null
  }

  export type VoucherUsageAvgAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type VoucherUsageSumAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type VoucherUsageMinAggregateOutputType = {
    id: string | null
    voucherId: string | null
    userId: string | null
    transactionId: string | null
    usedAt: Date | null
    discountAmount: Decimal | null
  }

  export type VoucherUsageMaxAggregateOutputType = {
    id: string | null
    voucherId: string | null
    userId: string | null
    transactionId: string | null
    usedAt: Date | null
    discountAmount: Decimal | null
  }

  export type VoucherUsageCountAggregateOutputType = {
    id: number
    voucherId: number
    userId: number
    transactionId: number
    usedAt: number
    discountAmount: number
    _all: number
  }


  export type VoucherUsageAvgAggregateInputType = {
    discountAmount?: true
  }

  export type VoucherUsageSumAggregateInputType = {
    discountAmount?: true
  }

  export type VoucherUsageMinAggregateInputType = {
    id?: true
    voucherId?: true
    userId?: true
    transactionId?: true
    usedAt?: true
    discountAmount?: true
  }

  export type VoucherUsageMaxAggregateInputType = {
    id?: true
    voucherId?: true
    userId?: true
    transactionId?: true
    usedAt?: true
    discountAmount?: true
  }

  export type VoucherUsageCountAggregateInputType = {
    id?: true
    voucherId?: true
    userId?: true
    transactionId?: true
    usedAt?: true
    discountAmount?: true
    _all?: true
  }

  export type VoucherUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherUsage to aggregate.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoucherUsages
    **/
    _count?: true | VoucherUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherUsageMaxAggregateInputType
  }

  export type GetVoucherUsageAggregateType<T extends VoucherUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucherUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucherUsage[P]>
      : GetScalarType<T[P], AggregateVoucherUsage[P]>
  }




  export type VoucherUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithAggregationInput | VoucherUsageOrderByWithAggregationInput[]
    by: VoucherUsageScalarFieldEnum[] | VoucherUsageScalarFieldEnum
    having?: VoucherUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherUsageCountAggregateInputType | true
    _avg?: VoucherUsageAvgAggregateInputType
    _sum?: VoucherUsageSumAggregateInputType
    _min?: VoucherUsageMinAggregateInputType
    _max?: VoucherUsageMaxAggregateInputType
  }

  export type VoucherUsageGroupByOutputType = {
    id: string
    voucherId: string
    userId: string
    transactionId: string | null
    usedAt: Date
    discountAmount: Decimal
    _count: VoucherUsageCountAggregateOutputType | null
    _avg: VoucherUsageAvgAggregateOutputType | null
    _sum: VoucherUsageSumAggregateOutputType | null
    _min: VoucherUsageMinAggregateOutputType | null
    _max: VoucherUsageMaxAggregateOutputType | null
  }

  type GetVoucherUsageGroupByPayload<T extends VoucherUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherUsageGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherUsageGroupByOutputType[P]>
        }
      >
    >


  export type VoucherUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    transactionId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherUsage"]>

  export type VoucherUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    transactionId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherUsage"]>

  export type VoucherUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    transactionId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherUsage"]>

  export type VoucherUsageSelectScalar = {
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    transactionId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
  }

  export type VoucherUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voucherId" | "userId" | "transactionId" | "usedAt" | "discountAmount", ExtArgs["result"]["voucherUsage"]>
  export type VoucherUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }
  export type VoucherUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }
  export type VoucherUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }

  export type $VoucherUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoucherUsage"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      voucher: Prisma.$VoucherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      voucherId: string
      userId: string
      transactionId: string | null
      usedAt: Date
      discountAmount: Prisma.Decimal
    }, ExtArgs["result"]["voucherUsage"]>
    composites: {}
  }

  type VoucherUsageGetPayload<S extends boolean | null | undefined | VoucherUsageDefaultArgs> = $Result.GetResult<Prisma.$VoucherUsagePayload, S>

  type VoucherUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherUsageCountAggregateInputType | true
    }

  export interface VoucherUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoucherUsage'], meta: { name: 'VoucherUsage' } }
    /**
     * Find zero or one VoucherUsage that matches the filter.
     * @param {VoucherUsageFindUniqueArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherUsageFindUniqueArgs>(args: SelectSubset<T, VoucherUsageFindUniqueArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoucherUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherUsageFindUniqueOrThrowArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageFindFirstArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherUsageFindFirstArgs>(args?: SelectSubset<T, VoucherUsageFindFirstArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageFindFirstOrThrowArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoucherUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoucherUsages
     * const voucherUsages = await prisma.voucherUsage.findMany()
     * 
     * // Get first 10 VoucherUsages
     * const voucherUsages = await prisma.voucherUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherUsageWithIdOnly = await prisma.voucherUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherUsageFindManyArgs>(args?: SelectSubset<T, VoucherUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoucherUsage.
     * @param {VoucherUsageCreateArgs} args - Arguments to create a VoucherUsage.
     * @example
     * // Create one VoucherUsage
     * const VoucherUsage = await prisma.voucherUsage.create({
     *   data: {
     *     // ... data to create a VoucherUsage
     *   }
     * })
     * 
     */
    create<T extends VoucherUsageCreateArgs>(args: SelectSubset<T, VoucherUsageCreateArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoucherUsages.
     * @param {VoucherUsageCreateManyArgs} args - Arguments to create many VoucherUsages.
     * @example
     * // Create many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherUsageCreateManyArgs>(args?: SelectSubset<T, VoucherUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoucherUsages and returns the data saved in the database.
     * @param {VoucherUsageCreateManyAndReturnArgs} args - Arguments to create many VoucherUsages.
     * @example
     * // Create many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoucherUsages and only return the `id`
     * const voucherUsageWithIdOnly = await prisma.voucherUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoucherUsage.
     * @param {VoucherUsageDeleteArgs} args - Arguments to delete one VoucherUsage.
     * @example
     * // Delete one VoucherUsage
     * const VoucherUsage = await prisma.voucherUsage.delete({
     *   where: {
     *     // ... filter to delete one VoucherUsage
     *   }
     * })
     * 
     */
    delete<T extends VoucherUsageDeleteArgs>(args: SelectSubset<T, VoucherUsageDeleteArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoucherUsage.
     * @param {VoucherUsageUpdateArgs} args - Arguments to update one VoucherUsage.
     * @example
     * // Update one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUsageUpdateArgs>(args: SelectSubset<T, VoucherUsageUpdateArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoucherUsages.
     * @param {VoucherUsageDeleteManyArgs} args - Arguments to filter VoucherUsages to delete.
     * @example
     * // Delete a few VoucherUsages
     * const { count } = await prisma.voucherUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherUsageDeleteManyArgs>(args?: SelectSubset<T, VoucherUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUsageUpdateManyArgs>(args: SelectSubset<T, VoucherUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherUsages and returns the data updated in the database.
     * @param {VoucherUsageUpdateManyAndReturnArgs} args - Arguments to update many VoucherUsages.
     * @example
     * // Update many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoucherUsages and only return the `id`
     * const voucherUsageWithIdOnly = await prisma.voucherUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoucherUsage.
     * @param {VoucherUsageUpsertArgs} args - Arguments to update or create a VoucherUsage.
     * @example
     * // Update or create a VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.upsert({
     *   create: {
     *     // ... data to create a VoucherUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoucherUsage we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUsageUpsertArgs>(args: SelectSubset<T, VoucherUsageUpsertArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoucherUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageCountArgs} args - Arguments to filter VoucherUsages to count.
     * @example
     * // Count the number of VoucherUsages
     * const count = await prisma.voucherUsage.count({
     *   where: {
     *     // ... the filter for the VoucherUsages we want to count
     *   }
     * })
    **/
    count<T extends VoucherUsageCountArgs>(
      args?: Subset<T, VoucherUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoucherUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherUsageAggregateArgs>(args: Subset<T, VoucherUsageAggregateArgs>): Prisma.PrismaPromise<GetVoucherUsageAggregateType<T>>

    /**
     * Group by VoucherUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherUsageGroupByArgs['orderBy'] }
        : { orderBy?: VoucherUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoucherUsage model
   */
  readonly fields: VoucherUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoucherUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends VoucherUsage$transactionArgs<ExtArgs> = {}>(args?: Subset<T, VoucherUsage$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    voucher<T extends VoucherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VoucherDefaultArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoucherUsage model
   */
  interface VoucherUsageFieldRefs {
    readonly id: FieldRef<"VoucherUsage", 'String'>
    readonly voucherId: FieldRef<"VoucherUsage", 'String'>
    readonly userId: FieldRef<"VoucherUsage", 'String'>
    readonly transactionId: FieldRef<"VoucherUsage", 'String'>
    readonly usedAt: FieldRef<"VoucherUsage", 'DateTime'>
    readonly discountAmount: FieldRef<"VoucherUsage", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * VoucherUsage findUnique
   */
  export type VoucherUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage findUniqueOrThrow
   */
  export type VoucherUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage findFirst
   */
  export type VoucherUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherUsages.
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherUsages.
     */
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * VoucherUsage findFirstOrThrow
   */
  export type VoucherUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherUsages.
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherUsages.
     */
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * VoucherUsage findMany
   */
  export type VoucherUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsages to fetch.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoucherUsages.
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * VoucherUsage create
   */
  export type VoucherUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a VoucherUsage.
     */
    data: XOR<VoucherUsageCreateInput, VoucherUsageUncheckedCreateInput>
  }

  /**
   * VoucherUsage createMany
   */
  export type VoucherUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoucherUsages.
     */
    data: VoucherUsageCreateManyInput | VoucherUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoucherUsage createManyAndReturn
   */
  export type VoucherUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * The data used to create many VoucherUsages.
     */
    data: VoucherUsageCreateManyInput | VoucherUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherUsage update
   */
  export type VoucherUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a VoucherUsage.
     */
    data: XOR<VoucherUsageUpdateInput, VoucherUsageUncheckedUpdateInput>
    /**
     * Choose, which VoucherUsage to update.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage updateMany
   */
  export type VoucherUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoucherUsages.
     */
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyInput>
    /**
     * Filter which VoucherUsages to update
     */
    where?: VoucherUsageWhereInput
    /**
     * Limit how many VoucherUsages to update.
     */
    limit?: number
  }

  /**
   * VoucherUsage updateManyAndReturn
   */
  export type VoucherUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * The data used to update VoucherUsages.
     */
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyInput>
    /**
     * Filter which VoucherUsages to update
     */
    where?: VoucherUsageWhereInput
    /**
     * Limit how many VoucherUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherUsage upsert
   */
  export type VoucherUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the VoucherUsage to update in case it exists.
     */
    where: VoucherUsageWhereUniqueInput
    /**
     * In case the VoucherUsage found by the `where` argument doesn't exist, create a new VoucherUsage with this data.
     */
    create: XOR<VoucherUsageCreateInput, VoucherUsageUncheckedCreateInput>
    /**
     * In case the VoucherUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUsageUpdateInput, VoucherUsageUncheckedUpdateInput>
  }

  /**
   * VoucherUsage delete
   */
  export type VoucherUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter which VoucherUsage to delete.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage deleteMany
   */
  export type VoucherUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherUsages to delete
     */
    where?: VoucherUsageWhereInput
    /**
     * Limit how many VoucherUsages to delete.
     */
    limit?: number
  }

  /**
   * VoucherUsage.transaction
   */
  export type VoucherUsage$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * VoucherUsage without action
   */
  export type VoucherUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    feeValue: Decimal | null
    minFee: Decimal | null
    maxFee: Decimal | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    feeValue: Decimal | null
    minFee: Decimal | null
    maxFee: Decimal | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: string | null
    isActive: boolean | null
    isSystem: boolean | null
    gatewayProvider: string | null
    gatewayCode: string | null
    gatewayImageUrl: string | null
    isGatewayMethod: boolean | null
    bankDetailId: string | null
    feeType: string | null
    feeValue: Decimal | null
    minFee: Decimal | null
    maxFee: Decimal | null
    requiresManualApproval: boolean | null
    paymentInstructions: string | null
    instructionType: string | null
    instructionImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: string | null
    isActive: boolean | null
    isSystem: boolean | null
    gatewayProvider: string | null
    gatewayCode: string | null
    gatewayImageUrl: string | null
    isGatewayMethod: boolean | null
    bankDetailId: string | null
    feeType: string | null
    feeValue: Decimal | null
    minFee: Decimal | null
    maxFee: Decimal | null
    requiresManualApproval: boolean | null
    paymentInstructions: string | null
    instructionType: string | null
    instructionImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    type: number
    isActive: number
    isSystem: number
    gatewayProvider: number
    gatewayCode: number
    gatewayImageUrl: number
    isGatewayMethod: number
    bankDetailId: number
    feeType: number
    feeValue: number
    minFee: number
    maxFee: number
    requiresManualApproval: number
    paymentInstructions: number
    instructionType: number
    instructionImageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    feeValue?: true
    minFee?: true
    maxFee?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    feeValue?: true
    minFee?: true
    maxFee?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    isActive?: true
    isSystem?: true
    gatewayProvider?: true
    gatewayCode?: true
    gatewayImageUrl?: true
    isGatewayMethod?: true
    bankDetailId?: true
    feeType?: true
    feeValue?: true
    minFee?: true
    maxFee?: true
    requiresManualApproval?: true
    paymentInstructions?: true
    instructionType?: true
    instructionImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    isActive?: true
    isSystem?: true
    gatewayProvider?: true
    gatewayCode?: true
    gatewayImageUrl?: true
    isGatewayMethod?: true
    bankDetailId?: true
    feeType?: true
    feeValue?: true
    minFee?: true
    maxFee?: true
    requiresManualApproval?: true
    paymentInstructions?: true
    instructionType?: true
    instructionImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    isActive?: true
    isSystem?: true
    gatewayProvider?: true
    gatewayCode?: true
    gatewayImageUrl?: true
    isGatewayMethod?: true
    bankDetailId?: true
    feeType?: true
    feeValue?: true
    minFee?: true
    maxFee?: true
    requiresManualApproval?: true
    paymentInstructions?: true
    instructionType?: true
    instructionImageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    type: string
    isActive: boolean
    isSystem: boolean
    gatewayProvider: string | null
    gatewayCode: string | null
    gatewayImageUrl: string | null
    isGatewayMethod: boolean
    bankDetailId: string | null
    feeType: string | null
    feeValue: Decimal | null
    minFee: Decimal | null
    maxFee: Decimal | null
    requiresManualApproval: boolean
    paymentInstructions: string | null
    instructionType: string | null
    instructionImageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    isActive?: boolean
    isSystem?: boolean
    gatewayProvider?: boolean
    gatewayCode?: boolean
    gatewayImageUrl?: boolean
    isGatewayMethod?: boolean
    bankDetailId?: boolean
    feeType?: boolean
    feeValue?: boolean
    minFee?: boolean
    maxFee?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: boolean
    instructionType?: boolean
    instructionImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankDetail?: boolean | PaymentMethod$bankDetailArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    isActive?: boolean
    isSystem?: boolean
    gatewayProvider?: boolean
    gatewayCode?: boolean
    gatewayImageUrl?: boolean
    isGatewayMethod?: boolean
    bankDetailId?: boolean
    feeType?: boolean
    feeValue?: boolean
    minFee?: boolean
    maxFee?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: boolean
    instructionType?: boolean
    instructionImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankDetail?: boolean | PaymentMethod$bankDetailArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    isActive?: boolean
    isSystem?: boolean
    gatewayProvider?: boolean
    gatewayCode?: boolean
    gatewayImageUrl?: boolean
    isGatewayMethod?: boolean
    bankDetailId?: boolean
    feeType?: boolean
    feeValue?: boolean
    minFee?: boolean
    maxFee?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: boolean
    instructionType?: boolean
    instructionImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankDetail?: boolean | PaymentMethod$bankDetailArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    isActive?: boolean
    isSystem?: boolean
    gatewayProvider?: boolean
    gatewayCode?: boolean
    gatewayImageUrl?: boolean
    isGatewayMethod?: boolean
    bankDetailId?: boolean
    feeType?: boolean
    feeValue?: boolean
    minFee?: boolean
    maxFee?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: boolean
    instructionType?: boolean
    instructionImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "type" | "isActive" | "isSystem" | "gatewayProvider" | "gatewayCode" | "gatewayImageUrl" | "isGatewayMethod" | "bankDetailId" | "feeType" | "feeValue" | "minFee" | "maxFee" | "requiresManualApproval" | "paymentInstructions" | "instructionType" | "instructionImageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankDetail?: boolean | PaymentMethod$bankDetailArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankDetail?: boolean | PaymentMethod$bankDetailArgs<ExtArgs>
  }
  export type PaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankDetail?: boolean | PaymentMethod$bankDetailArgs<ExtArgs>
  }

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      bankDetail: Prisma.$BankDetailPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      type: string
      isActive: boolean
      isSystem: boolean
      gatewayProvider: string | null
      gatewayCode: string | null
      gatewayImageUrl: string | null
      isGatewayMethod: boolean
      bankDetailId: string | null
      feeType: string | null
      feeValue: Prisma.Decimal | null
      minFee: Prisma.Decimal | null
      maxFee: Prisma.Decimal | null
      requiresManualApproval: boolean
      paymentInstructions: string | null
      instructionType: string | null
      instructionImageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bankDetail<T extends PaymentMethod$bankDetailArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$bankDetailArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly code: FieldRef<"PaymentMethod", 'String'>
    readonly name: FieldRef<"PaymentMethod", 'String'>
    readonly description: FieldRef<"PaymentMethod", 'String'>
    readonly type: FieldRef<"PaymentMethod", 'String'>
    readonly isActive: FieldRef<"PaymentMethod", 'Boolean'>
    readonly isSystem: FieldRef<"PaymentMethod", 'Boolean'>
    readonly gatewayProvider: FieldRef<"PaymentMethod", 'String'>
    readonly gatewayCode: FieldRef<"PaymentMethod", 'String'>
    readonly gatewayImageUrl: FieldRef<"PaymentMethod", 'String'>
    readonly isGatewayMethod: FieldRef<"PaymentMethod", 'Boolean'>
    readonly bankDetailId: FieldRef<"PaymentMethod", 'String'>
    readonly feeType: FieldRef<"PaymentMethod", 'String'>
    readonly feeValue: FieldRef<"PaymentMethod", 'Decimal'>
    readonly minFee: FieldRef<"PaymentMethod", 'Decimal'>
    readonly maxFee: FieldRef<"PaymentMethod", 'Decimal'>
    readonly requiresManualApproval: FieldRef<"PaymentMethod", 'Boolean'>
    readonly paymentInstructions: FieldRef<"PaymentMethod", 'String'>
    readonly instructionType: FieldRef<"PaymentMethod", 'String'>
    readonly instructionImageUrl: FieldRef<"PaymentMethod", 'String'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod.bankDetail
   */
  export type PaymentMethod$bankDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    where?: BankDetailWhereInput
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model BankDetail
   */

  export type AggregateBankDetail = {
    _count: BankDetailCountAggregateOutputType | null
    _min: BankDetailMinAggregateOutputType | null
    _max: BankDetailMaxAggregateOutputType | null
  }

  export type BankDetailMinAggregateOutputType = {
    id: string | null
    bankName: string | null
    accountNumber: string | null
    accountName: string | null
    swiftCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailMaxAggregateOutputType = {
    id: string | null
    bankName: string | null
    accountNumber: string | null
    accountName: string | null
    swiftCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailCountAggregateOutputType = {
    id: number
    bankName: number
    accountNumber: number
    accountName: number
    swiftCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankDetailMinAggregateInputType = {
    id?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    swiftCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailMaxAggregateInputType = {
    id?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    swiftCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailCountAggregateInputType = {
    id?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    swiftCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetail to aggregate.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankDetails
    **/
    _count?: true | BankDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankDetailMaxAggregateInputType
  }

  export type GetBankDetailAggregateType<T extends BankDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateBankDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankDetail[P]>
      : GetScalarType<T[P], AggregateBankDetail[P]>
  }




  export type BankDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankDetailWhereInput
    orderBy?: BankDetailOrderByWithAggregationInput | BankDetailOrderByWithAggregationInput[]
    by: BankDetailScalarFieldEnum[] | BankDetailScalarFieldEnum
    having?: BankDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankDetailCountAggregateInputType | true
    _min?: BankDetailMinAggregateInputType
    _max?: BankDetailMaxAggregateInputType
  }

  export type BankDetailGroupByOutputType = {
    id: string
    bankName: string
    accountNumber: string
    accountName: string
    swiftCode: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BankDetailCountAggregateOutputType | null
    _min: BankDetailMinAggregateOutputType | null
    _max: BankDetailMaxAggregateOutputType | null
  }

  type GetBankDetailGroupByPayload<T extends BankDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankDetailGroupByOutputType[P]>
            : GetScalarType<T[P], BankDetailGroupByOutputType[P]>
        }
      >
    >


  export type BankDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    swiftCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentMethods?: boolean | BankDetail$paymentMethodsArgs<ExtArgs>
    _count?: boolean | BankDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    swiftCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    swiftCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectScalar = {
    id?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    swiftCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bankName" | "accountNumber" | "accountName" | "swiftCode" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["bankDetail"]>
  export type BankDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentMethods?: boolean | BankDetail$paymentMethodsArgs<ExtArgs>
    _count?: boolean | BankDetailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BankDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BankDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BankDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankDetail"
    objects: {
      paymentMethods: Prisma.$PaymentMethodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bankName: string
      accountNumber: string
      accountName: string
      swiftCode: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankDetail"]>
    composites: {}
  }

  type BankDetailGetPayload<S extends boolean | null | undefined | BankDetailDefaultArgs> = $Result.GetResult<Prisma.$BankDetailPayload, S>

  type BankDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankDetailCountAggregateInputType | true
    }

  export interface BankDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankDetail'], meta: { name: 'BankDetail' } }
    /**
     * Find zero or one BankDetail that matches the filter.
     * @param {BankDetailFindUniqueArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankDetailFindUniqueArgs>(args: SelectSubset<T, BankDetailFindUniqueArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankDetailFindUniqueOrThrowArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, BankDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindFirstArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankDetailFindFirstArgs>(args?: SelectSubset<T, BankDetailFindFirstArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindFirstOrThrowArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, BankDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankDetails
     * const bankDetails = await prisma.bankDetail.findMany()
     * 
     * // Get first 10 BankDetails
     * const bankDetails = await prisma.bankDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankDetailFindManyArgs>(args?: SelectSubset<T, BankDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankDetail.
     * @param {BankDetailCreateArgs} args - Arguments to create a BankDetail.
     * @example
     * // Create one BankDetail
     * const BankDetail = await prisma.bankDetail.create({
     *   data: {
     *     // ... data to create a BankDetail
     *   }
     * })
     * 
     */
    create<T extends BankDetailCreateArgs>(args: SelectSubset<T, BankDetailCreateArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankDetails.
     * @param {BankDetailCreateManyArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetail = await prisma.bankDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankDetailCreateManyArgs>(args?: SelectSubset<T, BankDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankDetails and returns the data saved in the database.
     * @param {BankDetailCreateManyAndReturnArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetail = await prisma.bankDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankDetails and only return the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, BankDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankDetail.
     * @param {BankDetailDeleteArgs} args - Arguments to delete one BankDetail.
     * @example
     * // Delete one BankDetail
     * const BankDetail = await prisma.bankDetail.delete({
     *   where: {
     *     // ... filter to delete one BankDetail
     *   }
     * })
     * 
     */
    delete<T extends BankDetailDeleteArgs>(args: SelectSubset<T, BankDetailDeleteArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankDetail.
     * @param {BankDetailUpdateArgs} args - Arguments to update one BankDetail.
     * @example
     * // Update one BankDetail
     * const bankDetail = await prisma.bankDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankDetailUpdateArgs>(args: SelectSubset<T, BankDetailUpdateArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankDetails.
     * @param {BankDetailDeleteManyArgs} args - Arguments to filter BankDetails to delete.
     * @example
     * // Delete a few BankDetails
     * const { count } = await prisma.bankDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankDetailDeleteManyArgs>(args?: SelectSubset<T, BankDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankDetails
     * const bankDetail = await prisma.bankDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankDetailUpdateManyArgs>(args: SelectSubset<T, BankDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails and returns the data updated in the database.
     * @param {BankDetailUpdateManyAndReturnArgs} args - Arguments to update many BankDetails.
     * @example
     * // Update many BankDetails
     * const bankDetail = await prisma.bankDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankDetails and only return the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, BankDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankDetail.
     * @param {BankDetailUpsertArgs} args - Arguments to update or create a BankDetail.
     * @example
     * // Update or create a BankDetail
     * const bankDetail = await prisma.bankDetail.upsert({
     *   create: {
     *     // ... data to create a BankDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankDetail we want to update
     *   }
     * })
     */
    upsert<T extends BankDetailUpsertArgs>(args: SelectSubset<T, BankDetailUpsertArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailCountArgs} args - Arguments to filter BankDetails to count.
     * @example
     * // Count the number of BankDetails
     * const count = await prisma.bankDetail.count({
     *   where: {
     *     // ... the filter for the BankDetails we want to count
     *   }
     * })
    **/
    count<T extends BankDetailCountArgs>(
      args?: Subset<T, BankDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankDetailAggregateArgs>(args: Subset<T, BankDetailAggregateArgs>): Prisma.PrismaPromise<GetBankDetailAggregateType<T>>

    /**
     * Group by BankDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankDetailGroupByArgs['orderBy'] }
        : { orderBy?: BankDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankDetail model
   */
  readonly fields: BankDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paymentMethods<T extends BankDetail$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, BankDetail$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankDetail model
   */
  interface BankDetailFieldRefs {
    readonly id: FieldRef<"BankDetail", 'String'>
    readonly bankName: FieldRef<"BankDetail", 'String'>
    readonly accountNumber: FieldRef<"BankDetail", 'String'>
    readonly accountName: FieldRef<"BankDetail", 'String'>
    readonly swiftCode: FieldRef<"BankDetail", 'String'>
    readonly isActive: FieldRef<"BankDetail", 'Boolean'>
    readonly createdAt: FieldRef<"BankDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"BankDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankDetail findUnique
   */
  export type BankDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail findUniqueOrThrow
   */
  export type BankDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail findFirst
   */
  export type BankDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail findFirstOrThrow
   */
  export type BankDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail findMany
   */
  export type BankDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail create
   */
  export type BankDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a BankDetail.
     */
    data: XOR<BankDetailCreateInput, BankDetailUncheckedCreateInput>
  }

  /**
   * BankDetail createMany
   */
  export type BankDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailCreateManyInput | BankDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankDetail createManyAndReturn
   */
  export type BankDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailCreateManyInput | BankDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankDetail update
   */
  export type BankDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a BankDetail.
     */
    data: XOR<BankDetailUpdateInput, BankDetailUncheckedUpdateInput>
    /**
     * Choose, which BankDetail to update.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail updateMany
   */
  export type BankDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailUpdateManyMutationInput, BankDetailUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
  }

  /**
   * BankDetail updateManyAndReturn
   */
  export type BankDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailUpdateManyMutationInput, BankDetailUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
  }

  /**
   * BankDetail upsert
   */
  export type BankDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the BankDetail to update in case it exists.
     */
    where: BankDetailWhereUniqueInput
    /**
     * In case the BankDetail found by the `where` argument doesn't exist, create a new BankDetail with this data.
     */
    create: XOR<BankDetailCreateInput, BankDetailUncheckedCreateInput>
    /**
     * In case the BankDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankDetailUpdateInput, BankDetailUncheckedUpdateInput>
  }

  /**
   * BankDetail delete
   */
  export type BankDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter which BankDetail to delete.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail deleteMany
   */
  export type BankDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetails to delete
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to delete.
     */
    limit?: number
  }

  /**
   * BankDetail.paymentMethods
   */
  export type BankDetail$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    cursor?: PaymentMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * BankDetail without action
   */
  export type BankDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppCampaign
   */

  export type AggregateWhatsAppCampaign = {
    _count: WhatsAppCampaignCountAggregateOutputType | null
    _avg: WhatsAppCampaignAvgAggregateOutputType | null
    _sum: WhatsAppCampaignSumAggregateOutputType | null
    _min: WhatsAppCampaignMinAggregateOutputType | null
    _max: WhatsAppCampaignMaxAggregateOutputType | null
  }

  export type WhatsAppCampaignAvgAggregateOutputType = {
    id: number | null
  }

  export type WhatsAppCampaignSumAggregateOutputType = {
    id: bigint | null
  }

  export type WhatsAppCampaignMinAggregateOutputType = {
    id: bigint | null
    user_id: string | null
    name: string | null
    type: string | null
    status: string | null
    message_body: string | null
    image_url: string | null
    image_base64: string | null
    caption: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type WhatsAppCampaignMaxAggregateOutputType = {
    id: bigint | null
    user_id: string | null
    name: string | null
    type: string | null
    status: string | null
    message_body: string | null
    image_url: string | null
    image_base64: string | null
    caption: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type WhatsAppCampaignCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    type: number
    status: number
    message_body: number
    image_url: number
    image_base64: number
    caption: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type WhatsAppCampaignAvgAggregateInputType = {
    id?: true
  }

  export type WhatsAppCampaignSumAggregateInputType = {
    id?: true
  }

  export type WhatsAppCampaignMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    type?: true
    status?: true
    message_body?: true
    image_url?: true
    image_base64?: true
    caption?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type WhatsAppCampaignMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    type?: true
    status?: true
    message_body?: true
    image_url?: true
    image_base64?: true
    caption?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type WhatsAppCampaignCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    type?: true
    status?: true
    message_body?: true
    image_url?: true
    image_base64?: true
    caption?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type WhatsAppCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppCampaign to aggregate.
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCampaigns to fetch.
     */
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppCampaigns
    **/
    _count?: true | WhatsAppCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppCampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppCampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppCampaignMaxAggregateInputType
  }

  export type GetWhatsAppCampaignAggregateType<T extends WhatsAppCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppCampaign[P]>
      : GetScalarType<T[P], AggregateWhatsAppCampaign[P]>
  }




  export type WhatsAppCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppCampaignWhereInput
    orderBy?: WhatsAppCampaignOrderByWithAggregationInput | WhatsAppCampaignOrderByWithAggregationInput[]
    by: WhatsAppCampaignScalarFieldEnum[] | WhatsAppCampaignScalarFieldEnum
    having?: WhatsAppCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppCampaignCountAggregateInputType | true
    _avg?: WhatsAppCampaignAvgAggregateInputType
    _sum?: WhatsAppCampaignSumAggregateInputType
    _min?: WhatsAppCampaignMinAggregateInputType
    _max?: WhatsAppCampaignMaxAggregateInputType
  }

  export type WhatsAppCampaignGroupByOutputType = {
    id: bigint
    user_id: string
    name: string
    type: string
    status: string | null
    message_body: string | null
    image_url: string | null
    image_base64: string | null
    caption: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: WhatsAppCampaignCountAggregateOutputType | null
    _avg: WhatsAppCampaignAvgAggregateOutputType | null
    _sum: WhatsAppCampaignSumAggregateOutputType | null
    _min: WhatsAppCampaignMinAggregateOutputType | null
    _max: WhatsAppCampaignMaxAggregateOutputType | null
  }

  type GetWhatsAppCampaignGroupByPayload<T extends WhatsAppCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppCampaignGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    message_body?: boolean
    image_url?: boolean
    image_base64?: boolean
    caption?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    WhatsAppBulkCampaigns?: boolean | WhatsAppCampaign$WhatsAppBulkCampaignsArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WhatsAppCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppCampaign"]>

  export type WhatsAppCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    message_body?: boolean
    image_url?: boolean
    image_base64?: boolean
    caption?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppCampaign"]>

  export type WhatsAppCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    message_body?: boolean
    image_url?: boolean
    image_base64?: boolean
    caption?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppCampaign"]>

  export type WhatsAppCampaignSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    message_body?: boolean
    image_url?: boolean
    image_base64?: boolean
    caption?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type WhatsAppCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "type" | "status" | "message_body" | "image_url" | "image_base64" | "caption" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["whatsAppCampaign"]>
  export type WhatsAppCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatsAppBulkCampaigns?: boolean | WhatsAppCampaign$WhatsAppBulkCampaignsArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WhatsAppCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhatsAppCampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WhatsAppCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppCampaign"
    objects: {
      WhatsAppBulkCampaigns: Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: string
      name: string
      type: string
      status: string | null
      message_body: string | null
      image_url: string | null
      image_base64: string | null
      caption: string | null
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["whatsAppCampaign"]>
    composites: {}
  }

  type WhatsAppCampaignGetPayload<S extends boolean | null | undefined | WhatsAppCampaignDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppCampaignPayload, S>

  type WhatsAppCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppCampaignCountAggregateInputType | true
    }

  export interface WhatsAppCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppCampaign'], meta: { name: 'WhatsAppCampaign' } }
    /**
     * Find zero or one WhatsAppCampaign that matches the filter.
     * @param {WhatsAppCampaignFindUniqueArgs} args - Arguments to find a WhatsAppCampaign
     * @example
     * // Get one WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppCampaignFindUniqueArgs>(args: SelectSubset<T, WhatsAppCampaignFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppCampaignFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppCampaign
     * @example
     * // Get one WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignFindFirstArgs} args - Arguments to find a WhatsAppCampaign
     * @example
     * // Get one WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppCampaignFindFirstArgs>(args?: SelectSubset<T, WhatsAppCampaignFindFirstArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignFindFirstOrThrowArgs} args - Arguments to find a WhatsAppCampaign
     * @example
     * // Get one WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppCampaigns
     * const whatsAppCampaigns = await prisma.whatsAppCampaign.findMany()
     * 
     * // Get first 10 WhatsAppCampaigns
     * const whatsAppCampaigns = await prisma.whatsAppCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppCampaignWithIdOnly = await prisma.whatsAppCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppCampaignFindManyArgs>(args?: SelectSubset<T, WhatsAppCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppCampaign.
     * @param {WhatsAppCampaignCreateArgs} args - Arguments to create a WhatsAppCampaign.
     * @example
     * // Create one WhatsAppCampaign
     * const WhatsAppCampaign = await prisma.whatsAppCampaign.create({
     *   data: {
     *     // ... data to create a WhatsAppCampaign
     *   }
     * })
     * 
     */
    create<T extends WhatsAppCampaignCreateArgs>(args: SelectSubset<T, WhatsAppCampaignCreateArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppCampaigns.
     * @param {WhatsAppCampaignCreateManyArgs} args - Arguments to create many WhatsAppCampaigns.
     * @example
     * // Create many WhatsAppCampaigns
     * const whatsAppCampaign = await prisma.whatsAppCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppCampaignCreateManyArgs>(args?: SelectSubset<T, WhatsAppCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppCampaigns and returns the data saved in the database.
     * @param {WhatsAppCampaignCreateManyAndReturnArgs} args - Arguments to create many WhatsAppCampaigns.
     * @example
     * // Create many WhatsAppCampaigns
     * const whatsAppCampaign = await prisma.whatsAppCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppCampaigns and only return the `id`
     * const whatsAppCampaignWithIdOnly = await prisma.whatsAppCampaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppCampaign.
     * @param {WhatsAppCampaignDeleteArgs} args - Arguments to delete one WhatsAppCampaign.
     * @example
     * // Delete one WhatsAppCampaign
     * const WhatsAppCampaign = await prisma.whatsAppCampaign.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppCampaign
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppCampaignDeleteArgs>(args: SelectSubset<T, WhatsAppCampaignDeleteArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppCampaign.
     * @param {WhatsAppCampaignUpdateArgs} args - Arguments to update one WhatsAppCampaign.
     * @example
     * // Update one WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppCampaignUpdateArgs>(args: SelectSubset<T, WhatsAppCampaignUpdateArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppCampaigns.
     * @param {WhatsAppCampaignDeleteManyArgs} args - Arguments to filter WhatsAppCampaigns to delete.
     * @example
     * // Delete a few WhatsAppCampaigns
     * const { count } = await prisma.whatsAppCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppCampaignDeleteManyArgs>(args?: SelectSubset<T, WhatsAppCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppCampaigns
     * const whatsAppCampaign = await prisma.whatsAppCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppCampaignUpdateManyArgs>(args: SelectSubset<T, WhatsAppCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppCampaigns and returns the data updated in the database.
     * @param {WhatsAppCampaignUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppCampaigns.
     * @example
     * // Update many WhatsAppCampaigns
     * const whatsAppCampaign = await prisma.whatsAppCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppCampaigns and only return the `id`
     * const whatsAppCampaignWithIdOnly = await prisma.whatsAppCampaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppCampaign.
     * @param {WhatsAppCampaignUpsertArgs} args - Arguments to update or create a WhatsAppCampaign.
     * @example
     * // Update or create a WhatsAppCampaign
     * const whatsAppCampaign = await prisma.whatsAppCampaign.upsert({
     *   create: {
     *     // ... data to create a WhatsAppCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppCampaign we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppCampaignUpsertArgs>(args: SelectSubset<T, WhatsAppCampaignUpsertArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignCountArgs} args - Arguments to filter WhatsAppCampaigns to count.
     * @example
     * // Count the number of WhatsAppCampaigns
     * const count = await prisma.whatsAppCampaign.count({
     *   where: {
     *     // ... the filter for the WhatsAppCampaigns we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppCampaignCountArgs>(
      args?: Subset<T, WhatsAppCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppCampaignAggregateArgs>(args: Subset<T, WhatsAppCampaignAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppCampaignAggregateType<T>>

    /**
     * Group by WhatsAppCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppCampaignGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppCampaign model
   */
  readonly fields: WhatsAppCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WhatsAppBulkCampaigns<T extends WhatsAppCampaign$WhatsAppBulkCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppCampaign$WhatsAppBulkCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppCampaign model
   */
  interface WhatsAppCampaignFieldRefs {
    readonly id: FieldRef<"WhatsAppCampaign", 'BigInt'>
    readonly user_id: FieldRef<"WhatsAppCampaign", 'String'>
    readonly name: FieldRef<"WhatsAppCampaign", 'String'>
    readonly type: FieldRef<"WhatsAppCampaign", 'String'>
    readonly status: FieldRef<"WhatsAppCampaign", 'String'>
    readonly message_body: FieldRef<"WhatsAppCampaign", 'String'>
    readonly image_url: FieldRef<"WhatsAppCampaign", 'String'>
    readonly image_base64: FieldRef<"WhatsAppCampaign", 'String'>
    readonly caption: FieldRef<"WhatsAppCampaign", 'String'>
    readonly created_at: FieldRef<"WhatsAppCampaign", 'DateTime'>
    readonly updated_at: FieldRef<"WhatsAppCampaign", 'DateTime'>
    readonly deleted_at: FieldRef<"WhatsAppCampaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppCampaign findUnique
   */
  export type WhatsAppCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCampaign to fetch.
     */
    where: WhatsAppCampaignWhereUniqueInput
  }

  /**
   * WhatsAppCampaign findUniqueOrThrow
   */
  export type WhatsAppCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCampaign to fetch.
     */
    where: WhatsAppCampaignWhereUniqueInput
  }

  /**
   * WhatsAppCampaign findFirst
   */
  export type WhatsAppCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCampaign to fetch.
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCampaigns to fetch.
     */
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppCampaigns.
     */
    cursor?: WhatsAppCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppCampaigns.
     */
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppCampaign findFirstOrThrow
   */
  export type WhatsAppCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCampaign to fetch.
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCampaigns to fetch.
     */
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppCampaigns.
     */
    cursor?: WhatsAppCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppCampaigns.
     */
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppCampaign findMany
   */
  export type WhatsAppCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCampaigns to fetch.
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCampaigns to fetch.
     */
    orderBy?: WhatsAppCampaignOrderByWithRelationInput | WhatsAppCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppCampaigns.
     */
    cursor?: WhatsAppCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCampaigns.
     */
    skip?: number
    distinct?: WhatsAppCampaignScalarFieldEnum | WhatsAppCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppCampaign create
   */
  export type WhatsAppCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppCampaign.
     */
    data: XOR<WhatsAppCampaignCreateInput, WhatsAppCampaignUncheckedCreateInput>
  }

  /**
   * WhatsAppCampaign createMany
   */
  export type WhatsAppCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppCampaigns.
     */
    data: WhatsAppCampaignCreateManyInput | WhatsAppCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppCampaign createManyAndReturn
   */
  export type WhatsAppCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppCampaigns.
     */
    data: WhatsAppCampaignCreateManyInput | WhatsAppCampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppCampaign update
   */
  export type WhatsAppCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppCampaign.
     */
    data: XOR<WhatsAppCampaignUpdateInput, WhatsAppCampaignUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppCampaign to update.
     */
    where: WhatsAppCampaignWhereUniqueInput
  }

  /**
   * WhatsAppCampaign updateMany
   */
  export type WhatsAppCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppCampaigns.
     */
    data: XOR<WhatsAppCampaignUpdateManyMutationInput, WhatsAppCampaignUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppCampaigns to update
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * Limit how many WhatsAppCampaigns to update.
     */
    limit?: number
  }

  /**
   * WhatsAppCampaign updateManyAndReturn
   */
  export type WhatsAppCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppCampaigns.
     */
    data: XOR<WhatsAppCampaignUpdateManyMutationInput, WhatsAppCampaignUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppCampaigns to update
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * Limit how many WhatsAppCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppCampaign upsert
   */
  export type WhatsAppCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppCampaign to update in case it exists.
     */
    where: WhatsAppCampaignWhereUniqueInput
    /**
     * In case the WhatsAppCampaign found by the `where` argument doesn't exist, create a new WhatsAppCampaign with this data.
     */
    create: XOR<WhatsAppCampaignCreateInput, WhatsAppCampaignUncheckedCreateInput>
    /**
     * In case the WhatsAppCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppCampaignUpdateInput, WhatsAppCampaignUncheckedUpdateInput>
  }

  /**
   * WhatsAppCampaign delete
   */
  export type WhatsAppCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppCampaign to delete.
     */
    where: WhatsAppCampaignWhereUniqueInput
  }

  /**
   * WhatsAppCampaign deleteMany
   */
  export type WhatsAppCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppCampaigns to delete
     */
    where?: WhatsAppCampaignWhereInput
    /**
     * Limit how many WhatsAppCampaigns to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppCampaign.WhatsAppBulkCampaigns
   */
  export type WhatsAppCampaign$WhatsAppBulkCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    where?: WhatsAppBulkCampaignWhereInput
    orderBy?: WhatsAppBulkCampaignOrderByWithRelationInput | WhatsAppBulkCampaignOrderByWithRelationInput[]
    cursor?: WhatsAppBulkCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppBulkCampaignScalarFieldEnum | WhatsAppBulkCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppCampaign without action
   */
  export type WhatsAppCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppBulkCampaign
   */

  export type AggregateWhatsAppBulkCampaign = {
    _count: WhatsAppBulkCampaignCountAggregateOutputType | null
    _avg: WhatsAppBulkCampaignAvgAggregateOutputType | null
    _sum: WhatsAppBulkCampaignSumAggregateOutputType | null
    _min: WhatsAppBulkCampaignMinAggregateOutputType | null
    _max: WhatsAppBulkCampaignMaxAggregateOutputType | null
  }

  export type WhatsAppBulkCampaignAvgAggregateOutputType = {
    id: number | null
    campaign_id: number | null
    total_count: number | null
    sent_count: number | null
    failed_count: number | null
  }

  export type WhatsAppBulkCampaignSumAggregateOutputType = {
    id: bigint | null
    campaign_id: bigint | null
    total_count: bigint | null
    sent_count: bigint | null
    failed_count: bigint | null
  }

  export type WhatsAppBulkCampaignMinAggregateOutputType = {
    id: bigint | null
    user_id: string | null
    campaign_id: bigint | null
    name: string | null
    type: string | null
    message_body: string | null
    image_url: string | null
    image_base64: string | null
    caption: string | null
    status: string | null
    total_count: bigint | null
    sent_count: bigint | null
    failed_count: bigint | null
    scheduled_at: Date | null
    timezone: string | null
    processed_at: Date | null
    completed_at: Date | null
    error_message: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type WhatsAppBulkCampaignMaxAggregateOutputType = {
    id: bigint | null
    user_id: string | null
    campaign_id: bigint | null
    name: string | null
    type: string | null
    message_body: string | null
    image_url: string | null
    image_base64: string | null
    caption: string | null
    status: string | null
    total_count: bigint | null
    sent_count: bigint | null
    failed_count: bigint | null
    scheduled_at: Date | null
    timezone: string | null
    processed_at: Date | null
    completed_at: Date | null
    error_message: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type WhatsAppBulkCampaignCountAggregateOutputType = {
    id: number
    user_id: number
    campaign_id: number
    name: number
    type: number
    message_body: number
    image_url: number
    image_base64: number
    caption: number
    status: number
    total_count: number
    sent_count: number
    failed_count: number
    scheduled_at: number
    timezone: number
    processed_at: number
    completed_at: number
    error_message: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type WhatsAppBulkCampaignAvgAggregateInputType = {
    id?: true
    campaign_id?: true
    total_count?: true
    sent_count?: true
    failed_count?: true
  }

  export type WhatsAppBulkCampaignSumAggregateInputType = {
    id?: true
    campaign_id?: true
    total_count?: true
    sent_count?: true
    failed_count?: true
  }

  export type WhatsAppBulkCampaignMinAggregateInputType = {
    id?: true
    user_id?: true
    campaign_id?: true
    name?: true
    type?: true
    message_body?: true
    image_url?: true
    image_base64?: true
    caption?: true
    status?: true
    total_count?: true
    sent_count?: true
    failed_count?: true
    scheduled_at?: true
    timezone?: true
    processed_at?: true
    completed_at?: true
    error_message?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type WhatsAppBulkCampaignMaxAggregateInputType = {
    id?: true
    user_id?: true
    campaign_id?: true
    name?: true
    type?: true
    message_body?: true
    image_url?: true
    image_base64?: true
    caption?: true
    status?: true
    total_count?: true
    sent_count?: true
    failed_count?: true
    scheduled_at?: true
    timezone?: true
    processed_at?: true
    completed_at?: true
    error_message?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type WhatsAppBulkCampaignCountAggregateInputType = {
    id?: true
    user_id?: true
    campaign_id?: true
    name?: true
    type?: true
    message_body?: true
    image_url?: true
    image_base64?: true
    caption?: true
    status?: true
    total_count?: true
    sent_count?: true
    failed_count?: true
    scheduled_at?: true
    timezone?: true
    processed_at?: true
    completed_at?: true
    error_message?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type WhatsAppBulkCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppBulkCampaign to aggregate.
     */
    where?: WhatsAppBulkCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBulkCampaigns to fetch.
     */
    orderBy?: WhatsAppBulkCampaignOrderByWithRelationInput | WhatsAppBulkCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppBulkCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBulkCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBulkCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppBulkCampaigns
    **/
    _count?: true | WhatsAppBulkCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppBulkCampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppBulkCampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppBulkCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppBulkCampaignMaxAggregateInputType
  }

  export type GetWhatsAppBulkCampaignAggregateType<T extends WhatsAppBulkCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppBulkCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppBulkCampaign[P]>
      : GetScalarType<T[P], AggregateWhatsAppBulkCampaign[P]>
  }




  export type WhatsAppBulkCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppBulkCampaignWhereInput
    orderBy?: WhatsAppBulkCampaignOrderByWithAggregationInput | WhatsAppBulkCampaignOrderByWithAggregationInput[]
    by: WhatsAppBulkCampaignScalarFieldEnum[] | WhatsAppBulkCampaignScalarFieldEnum
    having?: WhatsAppBulkCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppBulkCampaignCountAggregateInputType | true
    _avg?: WhatsAppBulkCampaignAvgAggregateInputType
    _sum?: WhatsAppBulkCampaignSumAggregateInputType
    _min?: WhatsAppBulkCampaignMinAggregateInputType
    _max?: WhatsAppBulkCampaignMaxAggregateInputType
  }

  export type WhatsAppBulkCampaignGroupByOutputType = {
    id: bigint
    user_id: string
    campaign_id: bigint | null
    name: string
    type: string
    message_body: string | null
    image_url: string | null
    image_base64: string | null
    caption: string | null
    status: string | null
    total_count: bigint | null
    sent_count: bigint | null
    failed_count: bigint | null
    scheduled_at: Date | null
    timezone: string | null
    processed_at: Date | null
    completed_at: Date | null
    error_message: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: WhatsAppBulkCampaignCountAggregateOutputType | null
    _avg: WhatsAppBulkCampaignAvgAggregateOutputType | null
    _sum: WhatsAppBulkCampaignSumAggregateOutputType | null
    _min: WhatsAppBulkCampaignMinAggregateOutputType | null
    _max: WhatsAppBulkCampaignMaxAggregateOutputType | null
  }

  type GetWhatsAppBulkCampaignGroupByPayload<T extends WhatsAppBulkCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppBulkCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppBulkCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppBulkCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppBulkCampaignGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppBulkCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    campaign_id?: boolean
    name?: boolean
    type?: boolean
    message_body?: boolean
    image_url?: boolean
    image_base64?: boolean
    caption?: boolean
    status?: boolean
    total_count?: boolean
    sent_count?: boolean
    failed_count?: boolean
    scheduled_at?: boolean
    timezone?: boolean
    processed_at?: boolean
    completed_at?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    WhatsAppBulkCampaignItems?: boolean | WhatsAppBulkCampaign$WhatsAppBulkCampaignItemsArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    WhatsAppCampaigns?: boolean | WhatsAppBulkCampaign$WhatsAppCampaignsArgs<ExtArgs>
    _count?: boolean | WhatsAppBulkCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppBulkCampaign"]>

  export type WhatsAppBulkCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    campaign_id?: boolean
    name?: boolean
    type?: boolean
    message_body?: boolean
    image_url?: boolean
    image_base64?: boolean
    caption?: boolean
    status?: boolean
    total_count?: boolean
    sent_count?: boolean
    failed_count?: boolean
    scheduled_at?: boolean
    timezone?: boolean
    processed_at?: boolean
    completed_at?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    WhatsAppCampaigns?: boolean | WhatsAppBulkCampaign$WhatsAppCampaignsArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppBulkCampaign"]>

  export type WhatsAppBulkCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    campaign_id?: boolean
    name?: boolean
    type?: boolean
    message_body?: boolean
    image_url?: boolean
    image_base64?: boolean
    caption?: boolean
    status?: boolean
    total_count?: boolean
    sent_count?: boolean
    failed_count?: boolean
    scheduled_at?: boolean
    timezone?: boolean
    processed_at?: boolean
    completed_at?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    WhatsAppCampaigns?: boolean | WhatsAppBulkCampaign$WhatsAppCampaignsArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppBulkCampaign"]>

  export type WhatsAppBulkCampaignSelectScalar = {
    id?: boolean
    user_id?: boolean
    campaign_id?: boolean
    name?: boolean
    type?: boolean
    message_body?: boolean
    image_url?: boolean
    image_base64?: boolean
    caption?: boolean
    status?: boolean
    total_count?: boolean
    sent_count?: boolean
    failed_count?: boolean
    scheduled_at?: boolean
    timezone?: boolean
    processed_at?: boolean
    completed_at?: boolean
    error_message?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type WhatsAppBulkCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "campaign_id" | "name" | "type" | "message_body" | "image_url" | "image_base64" | "caption" | "status" | "total_count" | "sent_count" | "failed_count" | "scheduled_at" | "timezone" | "processed_at" | "completed_at" | "error_message" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["whatsAppBulkCampaign"]>
  export type WhatsAppBulkCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatsAppBulkCampaignItems?: boolean | WhatsAppBulkCampaign$WhatsAppBulkCampaignItemsArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    WhatsAppCampaigns?: boolean | WhatsAppBulkCampaign$WhatsAppCampaignsArgs<ExtArgs>
    _count?: boolean | WhatsAppBulkCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppBulkCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    WhatsAppCampaigns?: boolean | WhatsAppBulkCampaign$WhatsAppCampaignsArgs<ExtArgs>
  }
  export type WhatsAppBulkCampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    WhatsAppCampaigns?: boolean | WhatsAppBulkCampaign$WhatsAppCampaignsArgs<ExtArgs>
  }

  export type $WhatsAppBulkCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppBulkCampaign"
    objects: {
      WhatsAppBulkCampaignItems: Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
      WhatsAppCampaigns: Prisma.$WhatsAppCampaignPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: string
      campaign_id: bigint | null
      name: string
      type: string
      message_body: string | null
      image_url: string | null
      image_base64: string | null
      caption: string | null
      status: string | null
      total_count: bigint | null
      sent_count: bigint | null
      failed_count: bigint | null
      scheduled_at: Date | null
      timezone: string | null
      processed_at: Date | null
      completed_at: Date | null
      error_message: string | null
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["whatsAppBulkCampaign"]>
    composites: {}
  }

  type WhatsAppBulkCampaignGetPayload<S extends boolean | null | undefined | WhatsAppBulkCampaignDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload, S>

  type WhatsAppBulkCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppBulkCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppBulkCampaignCountAggregateInputType | true
    }

  export interface WhatsAppBulkCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppBulkCampaign'], meta: { name: 'WhatsAppBulkCampaign' } }
    /**
     * Find zero or one WhatsAppBulkCampaign that matches the filter.
     * @param {WhatsAppBulkCampaignFindUniqueArgs} args - Arguments to find a WhatsAppBulkCampaign
     * @example
     * // Get one WhatsAppBulkCampaign
     * const whatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppBulkCampaignFindUniqueArgs>(args: SelectSubset<T, WhatsAppBulkCampaignFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppBulkCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppBulkCampaignFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppBulkCampaign
     * @example
     * // Get one WhatsAppBulkCampaign
     * const whatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppBulkCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppBulkCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppBulkCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignFindFirstArgs} args - Arguments to find a WhatsAppBulkCampaign
     * @example
     * // Get one WhatsAppBulkCampaign
     * const whatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppBulkCampaignFindFirstArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignFindFirstArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppBulkCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignFindFirstOrThrowArgs} args - Arguments to find a WhatsAppBulkCampaign
     * @example
     * // Get one WhatsAppBulkCampaign
     * const whatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppBulkCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppBulkCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppBulkCampaigns
     * const whatsAppBulkCampaigns = await prisma.whatsAppBulkCampaign.findMany()
     * 
     * // Get first 10 WhatsAppBulkCampaigns
     * const whatsAppBulkCampaigns = await prisma.whatsAppBulkCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppBulkCampaignWithIdOnly = await prisma.whatsAppBulkCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppBulkCampaignFindManyArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppBulkCampaign.
     * @param {WhatsAppBulkCampaignCreateArgs} args - Arguments to create a WhatsAppBulkCampaign.
     * @example
     * // Create one WhatsAppBulkCampaign
     * const WhatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.create({
     *   data: {
     *     // ... data to create a WhatsAppBulkCampaign
     *   }
     * })
     * 
     */
    create<T extends WhatsAppBulkCampaignCreateArgs>(args: SelectSubset<T, WhatsAppBulkCampaignCreateArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppBulkCampaigns.
     * @param {WhatsAppBulkCampaignCreateManyArgs} args - Arguments to create many WhatsAppBulkCampaigns.
     * @example
     * // Create many WhatsAppBulkCampaigns
     * const whatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppBulkCampaignCreateManyArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppBulkCampaigns and returns the data saved in the database.
     * @param {WhatsAppBulkCampaignCreateManyAndReturnArgs} args - Arguments to create many WhatsAppBulkCampaigns.
     * @example
     * // Create many WhatsAppBulkCampaigns
     * const whatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppBulkCampaigns and only return the `id`
     * const whatsAppBulkCampaignWithIdOnly = await prisma.whatsAppBulkCampaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppBulkCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppBulkCampaign.
     * @param {WhatsAppBulkCampaignDeleteArgs} args - Arguments to delete one WhatsAppBulkCampaign.
     * @example
     * // Delete one WhatsAppBulkCampaign
     * const WhatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppBulkCampaign
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppBulkCampaignDeleteArgs>(args: SelectSubset<T, WhatsAppBulkCampaignDeleteArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppBulkCampaign.
     * @param {WhatsAppBulkCampaignUpdateArgs} args - Arguments to update one WhatsAppBulkCampaign.
     * @example
     * // Update one WhatsAppBulkCampaign
     * const whatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppBulkCampaignUpdateArgs>(args: SelectSubset<T, WhatsAppBulkCampaignUpdateArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppBulkCampaigns.
     * @param {WhatsAppBulkCampaignDeleteManyArgs} args - Arguments to filter WhatsAppBulkCampaigns to delete.
     * @example
     * // Delete a few WhatsAppBulkCampaigns
     * const { count } = await prisma.whatsAppBulkCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppBulkCampaignDeleteManyArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppBulkCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppBulkCampaigns
     * const whatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppBulkCampaignUpdateManyArgs>(args: SelectSubset<T, WhatsAppBulkCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppBulkCampaigns and returns the data updated in the database.
     * @param {WhatsAppBulkCampaignUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppBulkCampaigns.
     * @example
     * // Update many WhatsAppBulkCampaigns
     * const whatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppBulkCampaigns and only return the `id`
     * const whatsAppBulkCampaignWithIdOnly = await prisma.whatsAppBulkCampaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppBulkCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppBulkCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppBulkCampaign.
     * @param {WhatsAppBulkCampaignUpsertArgs} args - Arguments to update or create a WhatsAppBulkCampaign.
     * @example
     * // Update or create a WhatsAppBulkCampaign
     * const whatsAppBulkCampaign = await prisma.whatsAppBulkCampaign.upsert({
     *   create: {
     *     // ... data to create a WhatsAppBulkCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppBulkCampaign we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppBulkCampaignUpsertArgs>(args: SelectSubset<T, WhatsAppBulkCampaignUpsertArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppBulkCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignCountArgs} args - Arguments to filter WhatsAppBulkCampaigns to count.
     * @example
     * // Count the number of WhatsAppBulkCampaigns
     * const count = await prisma.whatsAppBulkCampaign.count({
     *   where: {
     *     // ... the filter for the WhatsAppBulkCampaigns we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppBulkCampaignCountArgs>(
      args?: Subset<T, WhatsAppBulkCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppBulkCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppBulkCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppBulkCampaignAggregateArgs>(args: Subset<T, WhatsAppBulkCampaignAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppBulkCampaignAggregateType<T>>

    /**
     * Group by WhatsAppBulkCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppBulkCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppBulkCampaignGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppBulkCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppBulkCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppBulkCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppBulkCampaign model
   */
  readonly fields: WhatsAppBulkCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppBulkCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppBulkCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WhatsAppBulkCampaignItems<T extends WhatsAppBulkCampaign$WhatsAppBulkCampaignItemsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppBulkCampaign$WhatsAppBulkCampaignItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    WhatsAppCampaigns<T extends WhatsAppBulkCampaign$WhatsAppCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppBulkCampaign$WhatsAppCampaignsArgs<ExtArgs>>): Prisma__WhatsAppCampaignClient<$Result.GetResult<Prisma.$WhatsAppCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppBulkCampaign model
   */
  interface WhatsAppBulkCampaignFieldRefs {
    readonly id: FieldRef<"WhatsAppBulkCampaign", 'BigInt'>
    readonly user_id: FieldRef<"WhatsAppBulkCampaign", 'String'>
    readonly campaign_id: FieldRef<"WhatsAppBulkCampaign", 'BigInt'>
    readonly name: FieldRef<"WhatsAppBulkCampaign", 'String'>
    readonly type: FieldRef<"WhatsAppBulkCampaign", 'String'>
    readonly message_body: FieldRef<"WhatsAppBulkCampaign", 'String'>
    readonly image_url: FieldRef<"WhatsAppBulkCampaign", 'String'>
    readonly image_base64: FieldRef<"WhatsAppBulkCampaign", 'String'>
    readonly caption: FieldRef<"WhatsAppBulkCampaign", 'String'>
    readonly status: FieldRef<"WhatsAppBulkCampaign", 'String'>
    readonly total_count: FieldRef<"WhatsAppBulkCampaign", 'BigInt'>
    readonly sent_count: FieldRef<"WhatsAppBulkCampaign", 'BigInt'>
    readonly failed_count: FieldRef<"WhatsAppBulkCampaign", 'BigInt'>
    readonly scheduled_at: FieldRef<"WhatsAppBulkCampaign", 'DateTime'>
    readonly timezone: FieldRef<"WhatsAppBulkCampaign", 'String'>
    readonly processed_at: FieldRef<"WhatsAppBulkCampaign", 'DateTime'>
    readonly completed_at: FieldRef<"WhatsAppBulkCampaign", 'DateTime'>
    readonly error_message: FieldRef<"WhatsAppBulkCampaign", 'String'>
    readonly created_at: FieldRef<"WhatsAppBulkCampaign", 'DateTime'>
    readonly updated_at: FieldRef<"WhatsAppBulkCampaign", 'DateTime'>
    readonly deleted_at: FieldRef<"WhatsAppBulkCampaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppBulkCampaign findUnique
   */
  export type WhatsAppBulkCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBulkCampaign to fetch.
     */
    where: WhatsAppBulkCampaignWhereUniqueInput
  }

  /**
   * WhatsAppBulkCampaign findUniqueOrThrow
   */
  export type WhatsAppBulkCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBulkCampaign to fetch.
     */
    where: WhatsAppBulkCampaignWhereUniqueInput
  }

  /**
   * WhatsAppBulkCampaign findFirst
   */
  export type WhatsAppBulkCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBulkCampaign to fetch.
     */
    where?: WhatsAppBulkCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBulkCampaigns to fetch.
     */
    orderBy?: WhatsAppBulkCampaignOrderByWithRelationInput | WhatsAppBulkCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppBulkCampaigns.
     */
    cursor?: WhatsAppBulkCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBulkCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBulkCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppBulkCampaigns.
     */
    distinct?: WhatsAppBulkCampaignScalarFieldEnum | WhatsAppBulkCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppBulkCampaign findFirstOrThrow
   */
  export type WhatsAppBulkCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBulkCampaign to fetch.
     */
    where?: WhatsAppBulkCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBulkCampaigns to fetch.
     */
    orderBy?: WhatsAppBulkCampaignOrderByWithRelationInput | WhatsAppBulkCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppBulkCampaigns.
     */
    cursor?: WhatsAppBulkCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBulkCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBulkCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppBulkCampaigns.
     */
    distinct?: WhatsAppBulkCampaignScalarFieldEnum | WhatsAppBulkCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppBulkCampaign findMany
   */
  export type WhatsAppBulkCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBulkCampaigns to fetch.
     */
    where?: WhatsAppBulkCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBulkCampaigns to fetch.
     */
    orderBy?: WhatsAppBulkCampaignOrderByWithRelationInput | WhatsAppBulkCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppBulkCampaigns.
     */
    cursor?: WhatsAppBulkCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBulkCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBulkCampaigns.
     */
    skip?: number
    distinct?: WhatsAppBulkCampaignScalarFieldEnum | WhatsAppBulkCampaignScalarFieldEnum[]
  }

  /**
   * WhatsAppBulkCampaign create
   */
  export type WhatsAppBulkCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppBulkCampaign.
     */
    data: XOR<WhatsAppBulkCampaignCreateInput, WhatsAppBulkCampaignUncheckedCreateInput>
  }

  /**
   * WhatsAppBulkCampaign createMany
   */
  export type WhatsAppBulkCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppBulkCampaigns.
     */
    data: WhatsAppBulkCampaignCreateManyInput | WhatsAppBulkCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppBulkCampaign createManyAndReturn
   */
  export type WhatsAppBulkCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppBulkCampaigns.
     */
    data: WhatsAppBulkCampaignCreateManyInput | WhatsAppBulkCampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppBulkCampaign update
   */
  export type WhatsAppBulkCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppBulkCampaign.
     */
    data: XOR<WhatsAppBulkCampaignUpdateInput, WhatsAppBulkCampaignUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppBulkCampaign to update.
     */
    where: WhatsAppBulkCampaignWhereUniqueInput
  }

  /**
   * WhatsAppBulkCampaign updateMany
   */
  export type WhatsAppBulkCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppBulkCampaigns.
     */
    data: XOR<WhatsAppBulkCampaignUpdateManyMutationInput, WhatsAppBulkCampaignUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppBulkCampaigns to update
     */
    where?: WhatsAppBulkCampaignWhereInput
    /**
     * Limit how many WhatsAppBulkCampaigns to update.
     */
    limit?: number
  }

  /**
   * WhatsAppBulkCampaign updateManyAndReturn
   */
  export type WhatsAppBulkCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppBulkCampaigns.
     */
    data: XOR<WhatsAppBulkCampaignUpdateManyMutationInput, WhatsAppBulkCampaignUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppBulkCampaigns to update
     */
    where?: WhatsAppBulkCampaignWhereInput
    /**
     * Limit how many WhatsAppBulkCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppBulkCampaign upsert
   */
  export type WhatsAppBulkCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppBulkCampaign to update in case it exists.
     */
    where: WhatsAppBulkCampaignWhereUniqueInput
    /**
     * In case the WhatsAppBulkCampaign found by the `where` argument doesn't exist, create a new WhatsAppBulkCampaign with this data.
     */
    create: XOR<WhatsAppBulkCampaignCreateInput, WhatsAppBulkCampaignUncheckedCreateInput>
    /**
     * In case the WhatsAppBulkCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppBulkCampaignUpdateInput, WhatsAppBulkCampaignUncheckedUpdateInput>
  }

  /**
   * WhatsAppBulkCampaign delete
   */
  export type WhatsAppBulkCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppBulkCampaign to delete.
     */
    where: WhatsAppBulkCampaignWhereUniqueInput
  }

  /**
   * WhatsAppBulkCampaign deleteMany
   */
  export type WhatsAppBulkCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppBulkCampaigns to delete
     */
    where?: WhatsAppBulkCampaignWhereInput
    /**
     * Limit how many WhatsAppBulkCampaigns to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppBulkCampaign.WhatsAppBulkCampaignItems
   */
  export type WhatsAppBulkCampaign$WhatsAppBulkCampaignItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
    where?: WhatsAppBulkCampaignItemWhereInput
    orderBy?: WhatsAppBulkCampaignItemOrderByWithRelationInput | WhatsAppBulkCampaignItemOrderByWithRelationInput[]
    cursor?: WhatsAppBulkCampaignItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppBulkCampaignItemScalarFieldEnum | WhatsAppBulkCampaignItemScalarFieldEnum[]
  }

  /**
   * WhatsAppBulkCampaign.WhatsAppCampaigns
   */
  export type WhatsAppBulkCampaign$WhatsAppCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCampaign
     */
    select?: WhatsAppCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCampaign
     */
    omit?: WhatsAppCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCampaignInclude<ExtArgs> | null
    where?: WhatsAppCampaignWhereInput
  }

  /**
   * WhatsAppBulkCampaign without action
   */
  export type WhatsAppBulkCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaign
     */
    select?: WhatsAppBulkCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaign
     */
    omit?: WhatsAppBulkCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppBulkCampaignItem
   */

  export type AggregateWhatsAppBulkCampaignItem = {
    _count: WhatsAppBulkCampaignItemCountAggregateOutputType | null
    _avg: WhatsAppBulkCampaignItemAvgAggregateOutputType | null
    _sum: WhatsAppBulkCampaignItemSumAggregateOutputType | null
    _min: WhatsAppBulkCampaignItemMinAggregateOutputType | null
    _max: WhatsAppBulkCampaignItemMaxAggregateOutputType | null
  }

  export type WhatsAppBulkCampaignItemAvgAggregateOutputType = {
    id: number | null
    bulk_campaign_id: number | null
  }

  export type WhatsAppBulkCampaignItemSumAggregateOutputType = {
    id: bigint | null
    bulk_campaign_id: bigint | null
  }

  export type WhatsAppBulkCampaignItemMinAggregateOutputType = {
    id: bigint | null
    bulk_campaign_id: bigint | null
    phone: string | null
    status: string | null
    message_id: string | null
    error_message: string | null
    sent_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type WhatsAppBulkCampaignItemMaxAggregateOutputType = {
    id: bigint | null
    bulk_campaign_id: bigint | null
    phone: string | null
    status: string | null
    message_id: string | null
    error_message: string | null
    sent_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type WhatsAppBulkCampaignItemCountAggregateOutputType = {
    id: number
    bulk_campaign_id: number
    phone: number
    status: number
    message_id: number
    error_message: number
    sent_at: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type WhatsAppBulkCampaignItemAvgAggregateInputType = {
    id?: true
    bulk_campaign_id?: true
  }

  export type WhatsAppBulkCampaignItemSumAggregateInputType = {
    id?: true
    bulk_campaign_id?: true
  }

  export type WhatsAppBulkCampaignItemMinAggregateInputType = {
    id?: true
    bulk_campaign_id?: true
    phone?: true
    status?: true
    message_id?: true
    error_message?: true
    sent_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type WhatsAppBulkCampaignItemMaxAggregateInputType = {
    id?: true
    bulk_campaign_id?: true
    phone?: true
    status?: true
    message_id?: true
    error_message?: true
    sent_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type WhatsAppBulkCampaignItemCountAggregateInputType = {
    id?: true
    bulk_campaign_id?: true
    phone?: true
    status?: true
    message_id?: true
    error_message?: true
    sent_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type WhatsAppBulkCampaignItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppBulkCampaignItem to aggregate.
     */
    where?: WhatsAppBulkCampaignItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBulkCampaignItems to fetch.
     */
    orderBy?: WhatsAppBulkCampaignItemOrderByWithRelationInput | WhatsAppBulkCampaignItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppBulkCampaignItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBulkCampaignItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBulkCampaignItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppBulkCampaignItems
    **/
    _count?: true | WhatsAppBulkCampaignItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppBulkCampaignItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppBulkCampaignItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppBulkCampaignItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppBulkCampaignItemMaxAggregateInputType
  }

  export type GetWhatsAppBulkCampaignItemAggregateType<T extends WhatsAppBulkCampaignItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppBulkCampaignItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppBulkCampaignItem[P]>
      : GetScalarType<T[P], AggregateWhatsAppBulkCampaignItem[P]>
  }




  export type WhatsAppBulkCampaignItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppBulkCampaignItemWhereInput
    orderBy?: WhatsAppBulkCampaignItemOrderByWithAggregationInput | WhatsAppBulkCampaignItemOrderByWithAggregationInput[]
    by: WhatsAppBulkCampaignItemScalarFieldEnum[] | WhatsAppBulkCampaignItemScalarFieldEnum
    having?: WhatsAppBulkCampaignItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppBulkCampaignItemCountAggregateInputType | true
    _avg?: WhatsAppBulkCampaignItemAvgAggregateInputType
    _sum?: WhatsAppBulkCampaignItemSumAggregateInputType
    _min?: WhatsAppBulkCampaignItemMinAggregateInputType
    _max?: WhatsAppBulkCampaignItemMaxAggregateInputType
  }

  export type WhatsAppBulkCampaignItemGroupByOutputType = {
    id: bigint
    bulk_campaign_id: bigint
    phone: string
    status: string | null
    message_id: string | null
    error_message: string | null
    sent_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: WhatsAppBulkCampaignItemCountAggregateOutputType | null
    _avg: WhatsAppBulkCampaignItemAvgAggregateOutputType | null
    _sum: WhatsAppBulkCampaignItemSumAggregateOutputType | null
    _min: WhatsAppBulkCampaignItemMinAggregateOutputType | null
    _max: WhatsAppBulkCampaignItemMaxAggregateOutputType | null
  }

  type GetWhatsAppBulkCampaignItemGroupByPayload<T extends WhatsAppBulkCampaignItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppBulkCampaignItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppBulkCampaignItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppBulkCampaignItemGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppBulkCampaignItemGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppBulkCampaignItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bulk_campaign_id?: boolean
    phone?: boolean
    status?: boolean
    message_id?: boolean
    error_message?: boolean
    sent_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    WhatsAppBulkCampaigns?: boolean | WhatsAppBulkCampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppBulkCampaignItem"]>

  export type WhatsAppBulkCampaignItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bulk_campaign_id?: boolean
    phone?: boolean
    status?: boolean
    message_id?: boolean
    error_message?: boolean
    sent_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    WhatsAppBulkCampaigns?: boolean | WhatsAppBulkCampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppBulkCampaignItem"]>

  export type WhatsAppBulkCampaignItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bulk_campaign_id?: boolean
    phone?: boolean
    status?: boolean
    message_id?: boolean
    error_message?: boolean
    sent_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    WhatsAppBulkCampaigns?: boolean | WhatsAppBulkCampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppBulkCampaignItem"]>

  export type WhatsAppBulkCampaignItemSelectScalar = {
    id?: boolean
    bulk_campaign_id?: boolean
    phone?: boolean
    status?: boolean
    message_id?: boolean
    error_message?: boolean
    sent_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type WhatsAppBulkCampaignItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bulk_campaign_id" | "phone" | "status" | "message_id" | "error_message" | "sent_at" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["whatsAppBulkCampaignItem"]>
  export type WhatsAppBulkCampaignItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatsAppBulkCampaigns?: boolean | WhatsAppBulkCampaignDefaultArgs<ExtArgs>
  }
  export type WhatsAppBulkCampaignItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatsAppBulkCampaigns?: boolean | WhatsAppBulkCampaignDefaultArgs<ExtArgs>
  }
  export type WhatsAppBulkCampaignItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatsAppBulkCampaigns?: boolean | WhatsAppBulkCampaignDefaultArgs<ExtArgs>
  }

  export type $WhatsAppBulkCampaignItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppBulkCampaignItem"
    objects: {
      WhatsAppBulkCampaigns: Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      bulk_campaign_id: bigint
      phone: string
      status: string | null
      message_id: string | null
      error_message: string | null
      sent_at: Date | null
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["whatsAppBulkCampaignItem"]>
    composites: {}
  }

  type WhatsAppBulkCampaignItemGetPayload<S extends boolean | null | undefined | WhatsAppBulkCampaignItemDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload, S>

  type WhatsAppBulkCampaignItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppBulkCampaignItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppBulkCampaignItemCountAggregateInputType | true
    }

  export interface WhatsAppBulkCampaignItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppBulkCampaignItem'], meta: { name: 'WhatsAppBulkCampaignItem' } }
    /**
     * Find zero or one WhatsAppBulkCampaignItem that matches the filter.
     * @param {WhatsAppBulkCampaignItemFindUniqueArgs} args - Arguments to find a WhatsAppBulkCampaignItem
     * @example
     * // Get one WhatsAppBulkCampaignItem
     * const whatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppBulkCampaignItemFindUniqueArgs>(args: SelectSubset<T, WhatsAppBulkCampaignItemFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignItemClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppBulkCampaignItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppBulkCampaignItemFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppBulkCampaignItem
     * @example
     * // Get one WhatsAppBulkCampaignItem
     * const whatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppBulkCampaignItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppBulkCampaignItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignItemClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppBulkCampaignItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignItemFindFirstArgs} args - Arguments to find a WhatsAppBulkCampaignItem
     * @example
     * // Get one WhatsAppBulkCampaignItem
     * const whatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppBulkCampaignItemFindFirstArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignItemFindFirstArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignItemClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppBulkCampaignItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignItemFindFirstOrThrowArgs} args - Arguments to find a WhatsAppBulkCampaignItem
     * @example
     * // Get one WhatsAppBulkCampaignItem
     * const whatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppBulkCampaignItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignItemClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppBulkCampaignItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppBulkCampaignItems
     * const whatsAppBulkCampaignItems = await prisma.whatsAppBulkCampaignItem.findMany()
     * 
     * // Get first 10 WhatsAppBulkCampaignItems
     * const whatsAppBulkCampaignItems = await prisma.whatsAppBulkCampaignItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppBulkCampaignItemWithIdOnly = await prisma.whatsAppBulkCampaignItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppBulkCampaignItemFindManyArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppBulkCampaignItem.
     * @param {WhatsAppBulkCampaignItemCreateArgs} args - Arguments to create a WhatsAppBulkCampaignItem.
     * @example
     * // Create one WhatsAppBulkCampaignItem
     * const WhatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.create({
     *   data: {
     *     // ... data to create a WhatsAppBulkCampaignItem
     *   }
     * })
     * 
     */
    create<T extends WhatsAppBulkCampaignItemCreateArgs>(args: SelectSubset<T, WhatsAppBulkCampaignItemCreateArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignItemClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppBulkCampaignItems.
     * @param {WhatsAppBulkCampaignItemCreateManyArgs} args - Arguments to create many WhatsAppBulkCampaignItems.
     * @example
     * // Create many WhatsAppBulkCampaignItems
     * const whatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppBulkCampaignItemCreateManyArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppBulkCampaignItems and returns the data saved in the database.
     * @param {WhatsAppBulkCampaignItemCreateManyAndReturnArgs} args - Arguments to create many WhatsAppBulkCampaignItems.
     * @example
     * // Create many WhatsAppBulkCampaignItems
     * const whatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppBulkCampaignItems and only return the `id`
     * const whatsAppBulkCampaignItemWithIdOnly = await prisma.whatsAppBulkCampaignItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppBulkCampaignItemCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppBulkCampaignItem.
     * @param {WhatsAppBulkCampaignItemDeleteArgs} args - Arguments to delete one WhatsAppBulkCampaignItem.
     * @example
     * // Delete one WhatsAppBulkCampaignItem
     * const WhatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppBulkCampaignItem
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppBulkCampaignItemDeleteArgs>(args: SelectSubset<T, WhatsAppBulkCampaignItemDeleteArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignItemClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppBulkCampaignItem.
     * @param {WhatsAppBulkCampaignItemUpdateArgs} args - Arguments to update one WhatsAppBulkCampaignItem.
     * @example
     * // Update one WhatsAppBulkCampaignItem
     * const whatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppBulkCampaignItemUpdateArgs>(args: SelectSubset<T, WhatsAppBulkCampaignItemUpdateArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignItemClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppBulkCampaignItems.
     * @param {WhatsAppBulkCampaignItemDeleteManyArgs} args - Arguments to filter WhatsAppBulkCampaignItems to delete.
     * @example
     * // Delete a few WhatsAppBulkCampaignItems
     * const { count } = await prisma.whatsAppBulkCampaignItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppBulkCampaignItemDeleteManyArgs>(args?: SelectSubset<T, WhatsAppBulkCampaignItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppBulkCampaignItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppBulkCampaignItems
     * const whatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppBulkCampaignItemUpdateManyArgs>(args: SelectSubset<T, WhatsAppBulkCampaignItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppBulkCampaignItems and returns the data updated in the database.
     * @param {WhatsAppBulkCampaignItemUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppBulkCampaignItems.
     * @example
     * // Update many WhatsAppBulkCampaignItems
     * const whatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppBulkCampaignItems and only return the `id`
     * const whatsAppBulkCampaignItemWithIdOnly = await prisma.whatsAppBulkCampaignItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppBulkCampaignItemUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppBulkCampaignItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppBulkCampaignItem.
     * @param {WhatsAppBulkCampaignItemUpsertArgs} args - Arguments to update or create a WhatsAppBulkCampaignItem.
     * @example
     * // Update or create a WhatsAppBulkCampaignItem
     * const whatsAppBulkCampaignItem = await prisma.whatsAppBulkCampaignItem.upsert({
     *   create: {
     *     // ... data to create a WhatsAppBulkCampaignItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppBulkCampaignItem we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppBulkCampaignItemUpsertArgs>(args: SelectSubset<T, WhatsAppBulkCampaignItemUpsertArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignItemClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppBulkCampaignItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignItemCountArgs} args - Arguments to filter WhatsAppBulkCampaignItems to count.
     * @example
     * // Count the number of WhatsAppBulkCampaignItems
     * const count = await prisma.whatsAppBulkCampaignItem.count({
     *   where: {
     *     // ... the filter for the WhatsAppBulkCampaignItems we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppBulkCampaignItemCountArgs>(
      args?: Subset<T, WhatsAppBulkCampaignItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppBulkCampaignItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppBulkCampaignItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppBulkCampaignItemAggregateArgs>(args: Subset<T, WhatsAppBulkCampaignItemAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppBulkCampaignItemAggregateType<T>>

    /**
     * Group by WhatsAppBulkCampaignItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppBulkCampaignItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppBulkCampaignItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppBulkCampaignItemGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppBulkCampaignItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppBulkCampaignItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppBulkCampaignItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppBulkCampaignItem model
   */
  readonly fields: WhatsAppBulkCampaignItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppBulkCampaignItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppBulkCampaignItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WhatsAppBulkCampaigns<T extends WhatsAppBulkCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppBulkCampaignDefaultArgs<ExtArgs>>): Prisma__WhatsAppBulkCampaignClient<$Result.GetResult<Prisma.$WhatsAppBulkCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppBulkCampaignItem model
   */
  interface WhatsAppBulkCampaignItemFieldRefs {
    readonly id: FieldRef<"WhatsAppBulkCampaignItem", 'BigInt'>
    readonly bulk_campaign_id: FieldRef<"WhatsAppBulkCampaignItem", 'BigInt'>
    readonly phone: FieldRef<"WhatsAppBulkCampaignItem", 'String'>
    readonly status: FieldRef<"WhatsAppBulkCampaignItem", 'String'>
    readonly message_id: FieldRef<"WhatsAppBulkCampaignItem", 'String'>
    readonly error_message: FieldRef<"WhatsAppBulkCampaignItem", 'String'>
    readonly sent_at: FieldRef<"WhatsAppBulkCampaignItem", 'DateTime'>
    readonly created_at: FieldRef<"WhatsAppBulkCampaignItem", 'DateTime'>
    readonly updated_at: FieldRef<"WhatsAppBulkCampaignItem", 'DateTime'>
    readonly deleted_at: FieldRef<"WhatsAppBulkCampaignItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppBulkCampaignItem findUnique
   */
  export type WhatsAppBulkCampaignItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBulkCampaignItem to fetch.
     */
    where: WhatsAppBulkCampaignItemWhereUniqueInput
  }

  /**
   * WhatsAppBulkCampaignItem findUniqueOrThrow
   */
  export type WhatsAppBulkCampaignItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBulkCampaignItem to fetch.
     */
    where: WhatsAppBulkCampaignItemWhereUniqueInput
  }

  /**
   * WhatsAppBulkCampaignItem findFirst
   */
  export type WhatsAppBulkCampaignItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBulkCampaignItem to fetch.
     */
    where?: WhatsAppBulkCampaignItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBulkCampaignItems to fetch.
     */
    orderBy?: WhatsAppBulkCampaignItemOrderByWithRelationInput | WhatsAppBulkCampaignItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppBulkCampaignItems.
     */
    cursor?: WhatsAppBulkCampaignItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBulkCampaignItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBulkCampaignItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppBulkCampaignItems.
     */
    distinct?: WhatsAppBulkCampaignItemScalarFieldEnum | WhatsAppBulkCampaignItemScalarFieldEnum[]
  }

  /**
   * WhatsAppBulkCampaignItem findFirstOrThrow
   */
  export type WhatsAppBulkCampaignItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBulkCampaignItem to fetch.
     */
    where?: WhatsAppBulkCampaignItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBulkCampaignItems to fetch.
     */
    orderBy?: WhatsAppBulkCampaignItemOrderByWithRelationInput | WhatsAppBulkCampaignItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppBulkCampaignItems.
     */
    cursor?: WhatsAppBulkCampaignItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBulkCampaignItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBulkCampaignItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppBulkCampaignItems.
     */
    distinct?: WhatsAppBulkCampaignItemScalarFieldEnum | WhatsAppBulkCampaignItemScalarFieldEnum[]
  }

  /**
   * WhatsAppBulkCampaignItem findMany
   */
  export type WhatsAppBulkCampaignItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppBulkCampaignItems to fetch.
     */
    where?: WhatsAppBulkCampaignItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppBulkCampaignItems to fetch.
     */
    orderBy?: WhatsAppBulkCampaignItemOrderByWithRelationInput | WhatsAppBulkCampaignItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppBulkCampaignItems.
     */
    cursor?: WhatsAppBulkCampaignItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppBulkCampaignItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppBulkCampaignItems.
     */
    skip?: number
    distinct?: WhatsAppBulkCampaignItemScalarFieldEnum | WhatsAppBulkCampaignItemScalarFieldEnum[]
  }

  /**
   * WhatsAppBulkCampaignItem create
   */
  export type WhatsAppBulkCampaignItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppBulkCampaignItem.
     */
    data: XOR<WhatsAppBulkCampaignItemCreateInput, WhatsAppBulkCampaignItemUncheckedCreateInput>
  }

  /**
   * WhatsAppBulkCampaignItem createMany
   */
  export type WhatsAppBulkCampaignItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppBulkCampaignItems.
     */
    data: WhatsAppBulkCampaignItemCreateManyInput | WhatsAppBulkCampaignItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppBulkCampaignItem createManyAndReturn
   */
  export type WhatsAppBulkCampaignItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppBulkCampaignItems.
     */
    data: WhatsAppBulkCampaignItemCreateManyInput | WhatsAppBulkCampaignItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppBulkCampaignItem update
   */
  export type WhatsAppBulkCampaignItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppBulkCampaignItem.
     */
    data: XOR<WhatsAppBulkCampaignItemUpdateInput, WhatsAppBulkCampaignItemUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppBulkCampaignItem to update.
     */
    where: WhatsAppBulkCampaignItemWhereUniqueInput
  }

  /**
   * WhatsAppBulkCampaignItem updateMany
   */
  export type WhatsAppBulkCampaignItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppBulkCampaignItems.
     */
    data: XOR<WhatsAppBulkCampaignItemUpdateManyMutationInput, WhatsAppBulkCampaignItemUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppBulkCampaignItems to update
     */
    where?: WhatsAppBulkCampaignItemWhereInput
    /**
     * Limit how many WhatsAppBulkCampaignItems to update.
     */
    limit?: number
  }

  /**
   * WhatsAppBulkCampaignItem updateManyAndReturn
   */
  export type WhatsAppBulkCampaignItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppBulkCampaignItems.
     */
    data: XOR<WhatsAppBulkCampaignItemUpdateManyMutationInput, WhatsAppBulkCampaignItemUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppBulkCampaignItems to update
     */
    where?: WhatsAppBulkCampaignItemWhereInput
    /**
     * Limit how many WhatsAppBulkCampaignItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppBulkCampaignItem upsert
   */
  export type WhatsAppBulkCampaignItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppBulkCampaignItem to update in case it exists.
     */
    where: WhatsAppBulkCampaignItemWhereUniqueInput
    /**
     * In case the WhatsAppBulkCampaignItem found by the `where` argument doesn't exist, create a new WhatsAppBulkCampaignItem with this data.
     */
    create: XOR<WhatsAppBulkCampaignItemCreateInput, WhatsAppBulkCampaignItemUncheckedCreateInput>
    /**
     * In case the WhatsAppBulkCampaignItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppBulkCampaignItemUpdateInput, WhatsAppBulkCampaignItemUncheckedUpdateInput>
  }

  /**
   * WhatsAppBulkCampaignItem delete
   */
  export type WhatsAppBulkCampaignItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppBulkCampaignItem to delete.
     */
    where: WhatsAppBulkCampaignItemWhereUniqueInput
  }

  /**
   * WhatsAppBulkCampaignItem deleteMany
   */
  export type WhatsAppBulkCampaignItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppBulkCampaignItems to delete
     */
    where?: WhatsAppBulkCampaignItemWhereInput
    /**
     * Limit how many WhatsAppBulkCampaignItems to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppBulkCampaignItem without action
   */
  export type WhatsAppBulkCampaignItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppBulkCampaignItem
     */
    select?: WhatsAppBulkCampaignItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppBulkCampaignItem
     */
    omit?: WhatsAppBulkCampaignItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppBulkCampaignItemInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppContact
   */

  export type AggregateWhatsAppContact = {
    _count: WhatsAppContactCountAggregateOutputType | null
    _avg: WhatsAppContactAvgAggregateOutputType | null
    _sum: WhatsAppContactSumAggregateOutputType | null
    _min: WhatsAppContactMinAggregateOutputType | null
    _max: WhatsAppContactMaxAggregateOutputType | null
  }

  export type WhatsAppContactAvgAggregateOutputType = {
    id: number | null
  }

  export type WhatsAppContactSumAggregateOutputType = {
    id: bigint | null
  }

  export type WhatsAppContactMinAggregateOutputType = {
    id: bigint | null
    user_id: string | null
    phone: string | null
    name: string | null
    full_name: string | null
    push_name: string | null
    short: string | null
    notify: string | null
    business: boolean | null
    verified: boolean | null
    source: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type WhatsAppContactMaxAggregateOutputType = {
    id: bigint | null
    user_id: string | null
    phone: string | null
    name: string | null
    full_name: string | null
    push_name: string | null
    short: string | null
    notify: string | null
    business: boolean | null
    verified: boolean | null
    source: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type WhatsAppContactCountAggregateOutputType = {
    id: number
    user_id: number
    phone: number
    name: number
    full_name: number
    push_name: number
    short: number
    notify: number
    business: number
    verified: number
    source: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type WhatsAppContactAvgAggregateInputType = {
    id?: true
  }

  export type WhatsAppContactSumAggregateInputType = {
    id?: true
  }

  export type WhatsAppContactMinAggregateInputType = {
    id?: true
    user_id?: true
    phone?: true
    name?: true
    full_name?: true
    push_name?: true
    short?: true
    notify?: true
    business?: true
    verified?: true
    source?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type WhatsAppContactMaxAggregateInputType = {
    id?: true
    user_id?: true
    phone?: true
    name?: true
    full_name?: true
    push_name?: true
    short?: true
    notify?: true
    business?: true
    verified?: true
    source?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type WhatsAppContactCountAggregateInputType = {
    id?: true
    user_id?: true
    phone?: true
    name?: true
    full_name?: true
    push_name?: true
    short?: true
    notify?: true
    business?: true
    verified?: true
    source?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type WhatsAppContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppContact to aggregate.
     */
    where?: WhatsAppContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppContacts to fetch.
     */
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppContacts
    **/
    _count?: true | WhatsAppContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppContactMaxAggregateInputType
  }

  export type GetWhatsAppContactAggregateType<T extends WhatsAppContactAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppContact[P]>
      : GetScalarType<T[P], AggregateWhatsAppContact[P]>
  }




  export type WhatsAppContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppContactWhereInput
    orderBy?: WhatsAppContactOrderByWithAggregationInput | WhatsAppContactOrderByWithAggregationInput[]
    by: WhatsAppContactScalarFieldEnum[] | WhatsAppContactScalarFieldEnum
    having?: WhatsAppContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppContactCountAggregateInputType | true
    _avg?: WhatsAppContactAvgAggregateInputType
    _sum?: WhatsAppContactSumAggregateInputType
    _min?: WhatsAppContactMinAggregateInputType
    _max?: WhatsAppContactMaxAggregateInputType
  }

  export type WhatsAppContactGroupByOutputType = {
    id: bigint
    user_id: string
    phone: string
    name: string | null
    full_name: string | null
    push_name: string | null
    short: string | null
    notify: string | null
    business: boolean | null
    verified: boolean | null
    source: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    _count: WhatsAppContactCountAggregateOutputType | null
    _avg: WhatsAppContactAvgAggregateOutputType | null
    _sum: WhatsAppContactSumAggregateOutputType | null
    _min: WhatsAppContactMinAggregateOutputType | null
    _max: WhatsAppContactMaxAggregateOutputType | null
  }

  type GetWhatsAppContactGroupByPayload<T extends WhatsAppContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppContactGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppContactGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    phone?: boolean
    name?: boolean
    full_name?: boolean
    push_name?: boolean
    short?: boolean
    notify?: boolean
    business?: boolean
    verified?: boolean
    source?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppContact"]>

  export type WhatsAppContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    phone?: boolean
    name?: boolean
    full_name?: boolean
    push_name?: boolean
    short?: boolean
    notify?: boolean
    business?: boolean
    verified?: boolean
    source?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppContact"]>

  export type WhatsAppContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    phone?: boolean
    name?: boolean
    full_name?: boolean
    push_name?: boolean
    short?: boolean
    notify?: boolean
    business?: boolean
    verified?: boolean
    source?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppContact"]>

  export type WhatsAppContactSelectScalar = {
    id?: boolean
    user_id?: boolean
    phone?: boolean
    name?: boolean
    full_name?: boolean
    push_name?: boolean
    short?: boolean
    notify?: boolean
    business?: boolean
    verified?: boolean
    source?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type WhatsAppContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "phone" | "name" | "full_name" | "push_name" | "short" | "notify" | "business" | "verified" | "source" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["whatsAppContact"]>
  export type WhatsAppContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhatsAppContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhatsAppContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WhatsAppContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppContact"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: string
      phone: string
      name: string | null
      full_name: string | null
      push_name: string | null
      short: string | null
      notify: string | null
      business: boolean | null
      verified: boolean | null
      source: string | null
      created_at: Date | null
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["whatsAppContact"]>
    composites: {}
  }

  type WhatsAppContactGetPayload<S extends boolean | null | undefined | WhatsAppContactDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppContactPayload, S>

  type WhatsAppContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppContactCountAggregateInputType | true
    }

  export interface WhatsAppContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppContact'], meta: { name: 'WhatsAppContact' } }
    /**
     * Find zero or one WhatsAppContact that matches the filter.
     * @param {WhatsAppContactFindUniqueArgs} args - Arguments to find a WhatsAppContact
     * @example
     * // Get one WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppContactFindUniqueArgs>(args: SelectSubset<T, WhatsAppContactFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppContactFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppContact
     * @example
     * // Get one WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppContactFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactFindFirstArgs} args - Arguments to find a WhatsAppContact
     * @example
     * // Get one WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppContactFindFirstArgs>(args?: SelectSubset<T, WhatsAppContactFindFirstArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactFindFirstOrThrowArgs} args - Arguments to find a WhatsAppContact
     * @example
     * // Get one WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppContactFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppContacts
     * const whatsAppContacts = await prisma.whatsAppContact.findMany()
     * 
     * // Get first 10 WhatsAppContacts
     * const whatsAppContacts = await prisma.whatsAppContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppContactWithIdOnly = await prisma.whatsAppContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppContactFindManyArgs>(args?: SelectSubset<T, WhatsAppContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppContact.
     * @param {WhatsAppContactCreateArgs} args - Arguments to create a WhatsAppContact.
     * @example
     * // Create one WhatsAppContact
     * const WhatsAppContact = await prisma.whatsAppContact.create({
     *   data: {
     *     // ... data to create a WhatsAppContact
     *   }
     * })
     * 
     */
    create<T extends WhatsAppContactCreateArgs>(args: SelectSubset<T, WhatsAppContactCreateArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppContacts.
     * @param {WhatsAppContactCreateManyArgs} args - Arguments to create many WhatsAppContacts.
     * @example
     * // Create many WhatsAppContacts
     * const whatsAppContact = await prisma.whatsAppContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppContactCreateManyArgs>(args?: SelectSubset<T, WhatsAppContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppContacts and returns the data saved in the database.
     * @param {WhatsAppContactCreateManyAndReturnArgs} args - Arguments to create many WhatsAppContacts.
     * @example
     * // Create many WhatsAppContacts
     * const whatsAppContact = await prisma.whatsAppContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppContacts and only return the `id`
     * const whatsAppContactWithIdOnly = await prisma.whatsAppContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppContactCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppContact.
     * @param {WhatsAppContactDeleteArgs} args - Arguments to delete one WhatsAppContact.
     * @example
     * // Delete one WhatsAppContact
     * const WhatsAppContact = await prisma.whatsAppContact.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppContact
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppContactDeleteArgs>(args: SelectSubset<T, WhatsAppContactDeleteArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppContact.
     * @param {WhatsAppContactUpdateArgs} args - Arguments to update one WhatsAppContact.
     * @example
     * // Update one WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppContactUpdateArgs>(args: SelectSubset<T, WhatsAppContactUpdateArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppContacts.
     * @param {WhatsAppContactDeleteManyArgs} args - Arguments to filter WhatsAppContacts to delete.
     * @example
     * // Delete a few WhatsAppContacts
     * const { count } = await prisma.whatsAppContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppContactDeleteManyArgs>(args?: SelectSubset<T, WhatsAppContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppContacts
     * const whatsAppContact = await prisma.whatsAppContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppContactUpdateManyArgs>(args: SelectSubset<T, WhatsAppContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppContacts and returns the data updated in the database.
     * @param {WhatsAppContactUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppContacts.
     * @example
     * // Update many WhatsAppContacts
     * const whatsAppContact = await prisma.whatsAppContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppContacts and only return the `id`
     * const whatsAppContactWithIdOnly = await prisma.whatsAppContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppContactUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppContact.
     * @param {WhatsAppContactUpsertArgs} args - Arguments to update or create a WhatsAppContact.
     * @example
     * // Update or create a WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.upsert({
     *   create: {
     *     // ... data to create a WhatsAppContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppContact we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppContactUpsertArgs>(args: SelectSubset<T, WhatsAppContactUpsertArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactCountArgs} args - Arguments to filter WhatsAppContacts to count.
     * @example
     * // Count the number of WhatsAppContacts
     * const count = await prisma.whatsAppContact.count({
     *   where: {
     *     // ... the filter for the WhatsAppContacts we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppContactCountArgs>(
      args?: Subset<T, WhatsAppContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppContactAggregateArgs>(args: Subset<T, WhatsAppContactAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppContactAggregateType<T>>

    /**
     * Group by WhatsAppContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppContactGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppContact model
   */
  readonly fields: WhatsAppContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppContact model
   */
  interface WhatsAppContactFieldRefs {
    readonly id: FieldRef<"WhatsAppContact", 'BigInt'>
    readonly user_id: FieldRef<"WhatsAppContact", 'String'>
    readonly phone: FieldRef<"WhatsAppContact", 'String'>
    readonly name: FieldRef<"WhatsAppContact", 'String'>
    readonly full_name: FieldRef<"WhatsAppContact", 'String'>
    readonly push_name: FieldRef<"WhatsAppContact", 'String'>
    readonly short: FieldRef<"WhatsAppContact", 'String'>
    readonly notify: FieldRef<"WhatsAppContact", 'String'>
    readonly business: FieldRef<"WhatsAppContact", 'Boolean'>
    readonly verified: FieldRef<"WhatsAppContact", 'Boolean'>
    readonly source: FieldRef<"WhatsAppContact", 'String'>
    readonly created_at: FieldRef<"WhatsAppContact", 'DateTime'>
    readonly updated_at: FieldRef<"WhatsAppContact", 'DateTime'>
    readonly deleted_at: FieldRef<"WhatsAppContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppContact findUnique
   */
  export type WhatsAppContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppContact to fetch.
     */
    where: WhatsAppContactWhereUniqueInput
  }

  /**
   * WhatsAppContact findUniqueOrThrow
   */
  export type WhatsAppContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppContact to fetch.
     */
    where: WhatsAppContactWhereUniqueInput
  }

  /**
   * WhatsAppContact findFirst
   */
  export type WhatsAppContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppContact to fetch.
     */
    where?: WhatsAppContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppContacts to fetch.
     */
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppContacts.
     */
    cursor?: WhatsAppContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppContacts.
     */
    distinct?: WhatsAppContactScalarFieldEnum | WhatsAppContactScalarFieldEnum[]
  }

  /**
   * WhatsAppContact findFirstOrThrow
   */
  export type WhatsAppContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppContact to fetch.
     */
    where?: WhatsAppContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppContacts to fetch.
     */
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppContacts.
     */
    cursor?: WhatsAppContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppContacts.
     */
    distinct?: WhatsAppContactScalarFieldEnum | WhatsAppContactScalarFieldEnum[]
  }

  /**
   * WhatsAppContact findMany
   */
  export type WhatsAppContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppContacts to fetch.
     */
    where?: WhatsAppContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppContacts to fetch.
     */
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppContacts.
     */
    cursor?: WhatsAppContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppContacts.
     */
    skip?: number
    distinct?: WhatsAppContactScalarFieldEnum | WhatsAppContactScalarFieldEnum[]
  }

  /**
   * WhatsAppContact create
   */
  export type WhatsAppContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppContact.
     */
    data: XOR<WhatsAppContactCreateInput, WhatsAppContactUncheckedCreateInput>
  }

  /**
   * WhatsAppContact createMany
   */
  export type WhatsAppContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppContacts.
     */
    data: WhatsAppContactCreateManyInput | WhatsAppContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppContact createManyAndReturn
   */
  export type WhatsAppContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppContacts.
     */
    data: WhatsAppContactCreateManyInput | WhatsAppContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppContact update
   */
  export type WhatsAppContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppContact.
     */
    data: XOR<WhatsAppContactUpdateInput, WhatsAppContactUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppContact to update.
     */
    where: WhatsAppContactWhereUniqueInput
  }

  /**
   * WhatsAppContact updateMany
   */
  export type WhatsAppContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppContacts.
     */
    data: XOR<WhatsAppContactUpdateManyMutationInput, WhatsAppContactUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppContacts to update
     */
    where?: WhatsAppContactWhereInput
    /**
     * Limit how many WhatsAppContacts to update.
     */
    limit?: number
  }

  /**
   * WhatsAppContact updateManyAndReturn
   */
  export type WhatsAppContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppContacts.
     */
    data: XOR<WhatsAppContactUpdateManyMutationInput, WhatsAppContactUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppContacts to update
     */
    where?: WhatsAppContactWhereInput
    /**
     * Limit how many WhatsAppContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppContact upsert
   */
  export type WhatsAppContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppContact to update in case it exists.
     */
    where: WhatsAppContactWhereUniqueInput
    /**
     * In case the WhatsAppContact found by the `where` argument doesn't exist, create a new WhatsAppContact with this data.
     */
    create: XOR<WhatsAppContactCreateInput, WhatsAppContactUncheckedCreateInput>
    /**
     * In case the WhatsAppContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppContactUpdateInput, WhatsAppContactUncheckedUpdateInput>
  }

  /**
   * WhatsAppContact delete
   */
  export type WhatsAppContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppContact to delete.
     */
    where: WhatsAppContactWhereUniqueInput
  }

  /**
   * WhatsAppContact deleteMany
   */
  export type WhatsAppContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppContacts to delete
     */
    where?: WhatsAppContactWhereInput
    /**
     * Limit how many WhatsAppContacts to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppContact without action
   */
  export type WhatsAppContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppMessageStats
   */

  export type AggregateWhatsAppMessageStats = {
    _count: WhatsAppMessageStatsCountAggregateOutputType | null
    _avg: WhatsAppMessageStatsAvgAggregateOutputType | null
    _sum: WhatsAppMessageStatsSumAggregateOutputType | null
    _min: WhatsAppMessageStatsMinAggregateOutputType | null
    _max: WhatsAppMessageStatsMaxAggregateOutputType | null
  }

  export type WhatsAppMessageStatsAvgAggregateOutputType = {
    totalMessagesSent: number | null
    totalMessagesFailed: number | null
    textMessagesSent: number | null
    textMessagesFailed: number | null
    imageMessagesSent: number | null
    imageMessagesFailed: number | null
    documentMessagesSent: number | null
    documentMessagesFailed: number | null
    audioMessagesSent: number | null
    audioMessagesFailed: number | null
    stickerMessagesSent: number | null
    stickerMessagesFailed: number | null
    videoMessagesSent: number | null
    videoMessagesFailed: number | null
    locationMessagesSent: number | null
    locationMessagesFailed: number | null
    contactMessagesSent: number | null
    contactMessagesFailed: number | null
    templateMessagesSent: number | null
    templateMessagesFailed: number | null
  }

  export type WhatsAppMessageStatsSumAggregateOutputType = {
    totalMessagesSent: number | null
    totalMessagesFailed: number | null
    textMessagesSent: number | null
    textMessagesFailed: number | null
    imageMessagesSent: number | null
    imageMessagesFailed: number | null
    documentMessagesSent: number | null
    documentMessagesFailed: number | null
    audioMessagesSent: number | null
    audioMessagesFailed: number | null
    stickerMessagesSent: number | null
    stickerMessagesFailed: number | null
    videoMessagesSent: number | null
    videoMessagesFailed: number | null
    locationMessagesSent: number | null
    locationMessagesFailed: number | null
    contactMessagesSent: number | null
    contactMessagesFailed: number | null
    templateMessagesSent: number | null
    templateMessagesFailed: number | null
  }

  export type WhatsAppMessageStatsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    totalMessagesSent: number | null
    totalMessagesFailed: number | null
    textMessagesSent: number | null
    textMessagesFailed: number | null
    imageMessagesSent: number | null
    imageMessagesFailed: number | null
    documentMessagesSent: number | null
    documentMessagesFailed: number | null
    audioMessagesSent: number | null
    audioMessagesFailed: number | null
    stickerMessagesSent: number | null
    stickerMessagesFailed: number | null
    videoMessagesSent: number | null
    videoMessagesFailed: number | null
    locationMessagesSent: number | null
    locationMessagesFailed: number | null
    contactMessagesSent: number | null
    contactMessagesFailed: number | null
    templateMessagesSent: number | null
    templateMessagesFailed: number | null
    lastMessageSentAt: Date | null
    lastMessageFailedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppMessageStatsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    totalMessagesSent: number | null
    totalMessagesFailed: number | null
    textMessagesSent: number | null
    textMessagesFailed: number | null
    imageMessagesSent: number | null
    imageMessagesFailed: number | null
    documentMessagesSent: number | null
    documentMessagesFailed: number | null
    audioMessagesSent: number | null
    audioMessagesFailed: number | null
    stickerMessagesSent: number | null
    stickerMessagesFailed: number | null
    videoMessagesSent: number | null
    videoMessagesFailed: number | null
    locationMessagesSent: number | null
    locationMessagesFailed: number | null
    contactMessagesSent: number | null
    contactMessagesFailed: number | null
    templateMessagesSent: number | null
    templateMessagesFailed: number | null
    lastMessageSentAt: Date | null
    lastMessageFailedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppMessageStatsCountAggregateOutputType = {
    id: number
    userId: number
    sessionId: number
    totalMessagesSent: number
    totalMessagesFailed: number
    textMessagesSent: number
    textMessagesFailed: number
    imageMessagesSent: number
    imageMessagesFailed: number
    documentMessagesSent: number
    documentMessagesFailed: number
    audioMessagesSent: number
    audioMessagesFailed: number
    stickerMessagesSent: number
    stickerMessagesFailed: number
    videoMessagesSent: number
    videoMessagesFailed: number
    locationMessagesSent: number
    locationMessagesFailed: number
    contactMessagesSent: number
    contactMessagesFailed: number
    templateMessagesSent: number
    templateMessagesFailed: number
    lastMessageSentAt: number
    lastMessageFailedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsAppMessageStatsAvgAggregateInputType = {
    totalMessagesSent?: true
    totalMessagesFailed?: true
    textMessagesSent?: true
    textMessagesFailed?: true
    imageMessagesSent?: true
    imageMessagesFailed?: true
    documentMessagesSent?: true
    documentMessagesFailed?: true
    audioMessagesSent?: true
    audioMessagesFailed?: true
    stickerMessagesSent?: true
    stickerMessagesFailed?: true
    videoMessagesSent?: true
    videoMessagesFailed?: true
    locationMessagesSent?: true
    locationMessagesFailed?: true
    contactMessagesSent?: true
    contactMessagesFailed?: true
    templateMessagesSent?: true
    templateMessagesFailed?: true
  }

  export type WhatsAppMessageStatsSumAggregateInputType = {
    totalMessagesSent?: true
    totalMessagesFailed?: true
    textMessagesSent?: true
    textMessagesFailed?: true
    imageMessagesSent?: true
    imageMessagesFailed?: true
    documentMessagesSent?: true
    documentMessagesFailed?: true
    audioMessagesSent?: true
    audioMessagesFailed?: true
    stickerMessagesSent?: true
    stickerMessagesFailed?: true
    videoMessagesSent?: true
    videoMessagesFailed?: true
    locationMessagesSent?: true
    locationMessagesFailed?: true
    contactMessagesSent?: true
    contactMessagesFailed?: true
    templateMessagesSent?: true
    templateMessagesFailed?: true
  }

  export type WhatsAppMessageStatsMinAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    totalMessagesSent?: true
    totalMessagesFailed?: true
    textMessagesSent?: true
    textMessagesFailed?: true
    imageMessagesSent?: true
    imageMessagesFailed?: true
    documentMessagesSent?: true
    documentMessagesFailed?: true
    audioMessagesSent?: true
    audioMessagesFailed?: true
    stickerMessagesSent?: true
    stickerMessagesFailed?: true
    videoMessagesSent?: true
    videoMessagesFailed?: true
    locationMessagesSent?: true
    locationMessagesFailed?: true
    contactMessagesSent?: true
    contactMessagesFailed?: true
    templateMessagesSent?: true
    templateMessagesFailed?: true
    lastMessageSentAt?: true
    lastMessageFailedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppMessageStatsMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    totalMessagesSent?: true
    totalMessagesFailed?: true
    textMessagesSent?: true
    textMessagesFailed?: true
    imageMessagesSent?: true
    imageMessagesFailed?: true
    documentMessagesSent?: true
    documentMessagesFailed?: true
    audioMessagesSent?: true
    audioMessagesFailed?: true
    stickerMessagesSent?: true
    stickerMessagesFailed?: true
    videoMessagesSent?: true
    videoMessagesFailed?: true
    locationMessagesSent?: true
    locationMessagesFailed?: true
    contactMessagesSent?: true
    contactMessagesFailed?: true
    templateMessagesSent?: true
    templateMessagesFailed?: true
    lastMessageSentAt?: true
    lastMessageFailedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppMessageStatsCountAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    totalMessagesSent?: true
    totalMessagesFailed?: true
    textMessagesSent?: true
    textMessagesFailed?: true
    imageMessagesSent?: true
    imageMessagesFailed?: true
    documentMessagesSent?: true
    documentMessagesFailed?: true
    audioMessagesSent?: true
    audioMessagesFailed?: true
    stickerMessagesSent?: true
    stickerMessagesFailed?: true
    videoMessagesSent?: true
    videoMessagesFailed?: true
    locationMessagesSent?: true
    locationMessagesFailed?: true
    contactMessagesSent?: true
    contactMessagesFailed?: true
    templateMessagesSent?: true
    templateMessagesFailed?: true
    lastMessageSentAt?: true
    lastMessageFailedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsAppMessageStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppMessageStats to aggregate.
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessageStats to fetch.
     */
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessageStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppMessageStats
    **/
    _count?: true | WhatsAppMessageStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppMessageStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppMessageStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppMessageStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppMessageStatsMaxAggregateInputType
  }

  export type GetWhatsAppMessageStatsAggregateType<T extends WhatsAppMessageStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppMessageStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppMessageStats[P]>
      : GetScalarType<T[P], AggregateWhatsAppMessageStats[P]>
  }




  export type WhatsAppMessageStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageStatsWhereInput
    orderBy?: WhatsAppMessageStatsOrderByWithAggregationInput | WhatsAppMessageStatsOrderByWithAggregationInput[]
    by: WhatsAppMessageStatsScalarFieldEnum[] | WhatsAppMessageStatsScalarFieldEnum
    having?: WhatsAppMessageStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppMessageStatsCountAggregateInputType | true
    _avg?: WhatsAppMessageStatsAvgAggregateInputType
    _sum?: WhatsAppMessageStatsSumAggregateInputType
    _min?: WhatsAppMessageStatsMinAggregateInputType
    _max?: WhatsAppMessageStatsMaxAggregateInputType
  }

  export type WhatsAppMessageStatsGroupByOutputType = {
    id: string
    userId: string
    sessionId: string
    totalMessagesSent: number
    totalMessagesFailed: number
    textMessagesSent: number
    textMessagesFailed: number
    imageMessagesSent: number
    imageMessagesFailed: number
    documentMessagesSent: number
    documentMessagesFailed: number
    audioMessagesSent: number
    audioMessagesFailed: number
    stickerMessagesSent: number
    stickerMessagesFailed: number
    videoMessagesSent: number
    videoMessagesFailed: number
    locationMessagesSent: number
    locationMessagesFailed: number
    contactMessagesSent: number
    contactMessagesFailed: number
    templateMessagesSent: number
    templateMessagesFailed: number
    lastMessageSentAt: Date | null
    lastMessageFailedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WhatsAppMessageStatsCountAggregateOutputType | null
    _avg: WhatsAppMessageStatsAvgAggregateOutputType | null
    _sum: WhatsAppMessageStatsSumAggregateOutputType | null
    _min: WhatsAppMessageStatsMinAggregateOutputType | null
    _max: WhatsAppMessageStatsMaxAggregateOutputType | null
  }

  type GetWhatsAppMessageStatsGroupByPayload<T extends WhatsAppMessageStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppMessageStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppMessageStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppMessageStatsGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppMessageStatsGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppMessageStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    totalMessagesSent?: boolean
    totalMessagesFailed?: boolean
    textMessagesSent?: boolean
    textMessagesFailed?: boolean
    imageMessagesSent?: boolean
    imageMessagesFailed?: boolean
    documentMessagesSent?: boolean
    documentMessagesFailed?: boolean
    audioMessagesSent?: boolean
    audioMessagesFailed?: boolean
    stickerMessagesSent?: boolean
    stickerMessagesFailed?: boolean
    videoMessagesSent?: boolean
    videoMessagesFailed?: boolean
    locationMessagesSent?: boolean
    locationMessagesFailed?: boolean
    contactMessagesSent?: boolean
    contactMessagesFailed?: boolean
    templateMessagesSent?: boolean
    templateMessagesFailed?: boolean
    lastMessageSentAt?: boolean
    lastMessageFailedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppMessageStats"]>

  export type WhatsAppMessageStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    totalMessagesSent?: boolean
    totalMessagesFailed?: boolean
    textMessagesSent?: boolean
    textMessagesFailed?: boolean
    imageMessagesSent?: boolean
    imageMessagesFailed?: boolean
    documentMessagesSent?: boolean
    documentMessagesFailed?: boolean
    audioMessagesSent?: boolean
    audioMessagesFailed?: boolean
    stickerMessagesSent?: boolean
    stickerMessagesFailed?: boolean
    videoMessagesSent?: boolean
    videoMessagesFailed?: boolean
    locationMessagesSent?: boolean
    locationMessagesFailed?: boolean
    contactMessagesSent?: boolean
    contactMessagesFailed?: boolean
    templateMessagesSent?: boolean
    templateMessagesFailed?: boolean
    lastMessageSentAt?: boolean
    lastMessageFailedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppMessageStats"]>

  export type WhatsAppMessageStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    totalMessagesSent?: boolean
    totalMessagesFailed?: boolean
    textMessagesSent?: boolean
    textMessagesFailed?: boolean
    imageMessagesSent?: boolean
    imageMessagesFailed?: boolean
    documentMessagesSent?: boolean
    documentMessagesFailed?: boolean
    audioMessagesSent?: boolean
    audioMessagesFailed?: boolean
    stickerMessagesSent?: boolean
    stickerMessagesFailed?: boolean
    videoMessagesSent?: boolean
    videoMessagesFailed?: boolean
    locationMessagesSent?: boolean
    locationMessagesFailed?: boolean
    contactMessagesSent?: boolean
    contactMessagesFailed?: boolean
    templateMessagesSent?: boolean
    templateMessagesFailed?: boolean
    lastMessageSentAt?: boolean
    lastMessageFailedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppMessageStats"]>

  export type WhatsAppMessageStatsSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    totalMessagesSent?: boolean
    totalMessagesFailed?: boolean
    textMessagesSent?: boolean
    textMessagesFailed?: boolean
    imageMessagesSent?: boolean
    imageMessagesFailed?: boolean
    documentMessagesSent?: boolean
    documentMessagesFailed?: boolean
    audioMessagesSent?: boolean
    audioMessagesFailed?: boolean
    stickerMessagesSent?: boolean
    stickerMessagesFailed?: boolean
    videoMessagesSent?: boolean
    videoMessagesFailed?: boolean
    locationMessagesSent?: boolean
    locationMessagesFailed?: boolean
    contactMessagesSent?: boolean
    contactMessagesFailed?: boolean
    templateMessagesSent?: boolean
    templateMessagesFailed?: boolean
    lastMessageSentAt?: boolean
    lastMessageFailedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsAppMessageStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionId" | "totalMessagesSent" | "totalMessagesFailed" | "textMessagesSent" | "textMessagesFailed" | "imageMessagesSent" | "imageMessagesFailed" | "documentMessagesSent" | "documentMessagesFailed" | "audioMessagesSent" | "audioMessagesFailed" | "stickerMessagesSent" | "stickerMessagesFailed" | "videoMessagesSent" | "videoMessagesFailed" | "locationMessagesSent" | "locationMessagesFailed" | "contactMessagesSent" | "contactMessagesFailed" | "templateMessagesSent" | "templateMessagesFailed" | "lastMessageSentAt" | "lastMessageFailedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsAppMessageStats"]>
  export type WhatsAppMessageStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }
  export type WhatsAppMessageStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }
  export type WhatsAppMessageStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }

  export type $WhatsAppMessageStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppMessageStats"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      session: Prisma.$WhatsAppSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionId: string
      totalMessagesSent: number
      totalMessagesFailed: number
      textMessagesSent: number
      textMessagesFailed: number
      imageMessagesSent: number
      imageMessagesFailed: number
      documentMessagesSent: number
      documentMessagesFailed: number
      audioMessagesSent: number
      audioMessagesFailed: number
      stickerMessagesSent: number
      stickerMessagesFailed: number
      videoMessagesSent: number
      videoMessagesFailed: number
      locationMessagesSent: number
      locationMessagesFailed: number
      contactMessagesSent: number
      contactMessagesFailed: number
      templateMessagesSent: number
      templateMessagesFailed: number
      lastMessageSentAt: Date | null
      lastMessageFailedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsAppMessageStats"]>
    composites: {}
  }

  type WhatsAppMessageStatsGetPayload<S extends boolean | null | undefined | WhatsAppMessageStatsDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppMessageStatsPayload, S>

  type WhatsAppMessageStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppMessageStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppMessageStatsCountAggregateInputType | true
    }

  export interface WhatsAppMessageStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppMessageStats'], meta: { name: 'WhatsAppMessageStats' } }
    /**
     * Find zero or one WhatsAppMessageStats that matches the filter.
     * @param {WhatsAppMessageStatsFindUniqueArgs} args - Arguments to find a WhatsAppMessageStats
     * @example
     * // Get one WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppMessageStatsFindUniqueArgs>(args: SelectSubset<T, WhatsAppMessageStatsFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppMessageStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppMessageStatsFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppMessageStats
     * @example
     * // Get one WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppMessageStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppMessageStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppMessageStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsFindFirstArgs} args - Arguments to find a WhatsAppMessageStats
     * @example
     * // Get one WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppMessageStatsFindFirstArgs>(args?: SelectSubset<T, WhatsAppMessageStatsFindFirstArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppMessageStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsFindFirstOrThrowArgs} args - Arguments to find a WhatsAppMessageStats
     * @example
     * // Get one WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppMessageStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppMessageStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppMessageStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findMany()
     * 
     * // Get first 10 WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppMessageStatsWithIdOnly = await prisma.whatsAppMessageStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppMessageStatsFindManyArgs>(args?: SelectSubset<T, WhatsAppMessageStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsCreateArgs} args - Arguments to create a WhatsAppMessageStats.
     * @example
     * // Create one WhatsAppMessageStats
     * const WhatsAppMessageStats = await prisma.whatsAppMessageStats.create({
     *   data: {
     *     // ... data to create a WhatsAppMessageStats
     *   }
     * })
     * 
     */
    create<T extends WhatsAppMessageStatsCreateArgs>(args: SelectSubset<T, WhatsAppMessageStatsCreateArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsCreateManyArgs} args - Arguments to create many WhatsAppMessageStats.
     * @example
     * // Create many WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppMessageStatsCreateManyArgs>(args?: SelectSubset<T, WhatsAppMessageStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppMessageStats and returns the data saved in the database.
     * @param {WhatsAppMessageStatsCreateManyAndReturnArgs} args - Arguments to create many WhatsAppMessageStats.
     * @example
     * // Create many WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppMessageStats and only return the `id`
     * const whatsAppMessageStatsWithIdOnly = await prisma.whatsAppMessageStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppMessageStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppMessageStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsDeleteArgs} args - Arguments to delete one WhatsAppMessageStats.
     * @example
     * // Delete one WhatsAppMessageStats
     * const WhatsAppMessageStats = await prisma.whatsAppMessageStats.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppMessageStats
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppMessageStatsDeleteArgs>(args: SelectSubset<T, WhatsAppMessageStatsDeleteArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsUpdateArgs} args - Arguments to update one WhatsAppMessageStats.
     * @example
     * // Update one WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppMessageStatsUpdateArgs>(args: SelectSubset<T, WhatsAppMessageStatsUpdateArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsDeleteManyArgs} args - Arguments to filter WhatsAppMessageStats to delete.
     * @example
     * // Delete a few WhatsAppMessageStats
     * const { count } = await prisma.whatsAppMessageStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppMessageStatsDeleteManyArgs>(args?: SelectSubset<T, WhatsAppMessageStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppMessageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppMessageStatsUpdateManyArgs>(args: SelectSubset<T, WhatsAppMessageStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppMessageStats and returns the data updated in the database.
     * @param {WhatsAppMessageStatsUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppMessageStats.
     * @example
     * // Update many WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppMessageStats and only return the `id`
     * const whatsAppMessageStatsWithIdOnly = await prisma.whatsAppMessageStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppMessageStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppMessageStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsUpsertArgs} args - Arguments to update or create a WhatsAppMessageStats.
     * @example
     * // Update or create a WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.upsert({
     *   create: {
     *     // ... data to create a WhatsAppMessageStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppMessageStats we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppMessageStatsUpsertArgs>(args: SelectSubset<T, WhatsAppMessageStatsUpsertArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppMessageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsCountArgs} args - Arguments to filter WhatsAppMessageStats to count.
     * @example
     * // Count the number of WhatsAppMessageStats
     * const count = await prisma.whatsAppMessageStats.count({
     *   where: {
     *     // ... the filter for the WhatsAppMessageStats we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppMessageStatsCountArgs>(
      args?: Subset<T, WhatsAppMessageStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppMessageStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppMessageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppMessageStatsAggregateArgs>(args: Subset<T, WhatsAppMessageStatsAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppMessageStatsAggregateType<T>>

    /**
     * Group by WhatsAppMessageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppMessageStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppMessageStatsGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppMessageStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppMessageStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppMessageStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppMessageStats model
   */
  readonly fields: WhatsAppMessageStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppMessageStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppMessageStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends WhatsAppSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppSessionDefaultArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppMessageStats model
   */
  interface WhatsAppMessageStatsFieldRefs {
    readonly id: FieldRef<"WhatsAppMessageStats", 'String'>
    readonly userId: FieldRef<"WhatsAppMessageStats", 'String'>
    readonly sessionId: FieldRef<"WhatsAppMessageStats", 'String'>
    readonly totalMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly totalMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly textMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly textMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly imageMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly imageMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly documentMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly documentMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly audioMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly audioMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly stickerMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly stickerMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly videoMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly videoMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly locationMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly locationMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly contactMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly contactMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly templateMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly templateMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly lastMessageSentAt: FieldRef<"WhatsAppMessageStats", 'DateTime'>
    readonly lastMessageFailedAt: FieldRef<"WhatsAppMessageStats", 'DateTime'>
    readonly createdAt: FieldRef<"WhatsAppMessageStats", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppMessageStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppMessageStats findUnique
   */
  export type WhatsAppMessageStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessageStats to fetch.
     */
    where: WhatsAppMessageStatsWhereUniqueInput
  }

  /**
   * WhatsAppMessageStats findUniqueOrThrow
   */
  export type WhatsAppMessageStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessageStats to fetch.
     */
    where: WhatsAppMessageStatsWhereUniqueInput
  }

  /**
   * WhatsAppMessageStats findFirst
   */
  export type WhatsAppMessageStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessageStats to fetch.
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessageStats to fetch.
     */
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppMessageStats.
     */
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessageStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppMessageStats.
     */
    distinct?: WhatsAppMessageStatsScalarFieldEnum | WhatsAppMessageStatsScalarFieldEnum[]
  }

  /**
   * WhatsAppMessageStats findFirstOrThrow
   */
  export type WhatsAppMessageStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessageStats to fetch.
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessageStats to fetch.
     */
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppMessageStats.
     */
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessageStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppMessageStats.
     */
    distinct?: WhatsAppMessageStatsScalarFieldEnum | WhatsAppMessageStatsScalarFieldEnum[]
  }

  /**
   * WhatsAppMessageStats findMany
   */
  export type WhatsAppMessageStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessageStats to fetch.
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessageStats to fetch.
     */
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppMessageStats.
     */
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessageStats.
     */
    skip?: number
    distinct?: WhatsAppMessageStatsScalarFieldEnum | WhatsAppMessageStatsScalarFieldEnum[]
  }

  /**
   * WhatsAppMessageStats create
   */
  export type WhatsAppMessageStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppMessageStats.
     */
    data: XOR<WhatsAppMessageStatsCreateInput, WhatsAppMessageStatsUncheckedCreateInput>
  }

  /**
   * WhatsAppMessageStats createMany
   */
  export type WhatsAppMessageStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppMessageStats.
     */
    data: WhatsAppMessageStatsCreateManyInput | WhatsAppMessageStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppMessageStats createManyAndReturn
   */
  export type WhatsAppMessageStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppMessageStats.
     */
    data: WhatsAppMessageStatsCreateManyInput | WhatsAppMessageStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppMessageStats update
   */
  export type WhatsAppMessageStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppMessageStats.
     */
    data: XOR<WhatsAppMessageStatsUpdateInput, WhatsAppMessageStatsUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppMessageStats to update.
     */
    where: WhatsAppMessageStatsWhereUniqueInput
  }

  /**
   * WhatsAppMessageStats updateMany
   */
  export type WhatsAppMessageStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppMessageStats.
     */
    data: XOR<WhatsAppMessageStatsUpdateManyMutationInput, WhatsAppMessageStatsUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppMessageStats to update
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * Limit how many WhatsAppMessageStats to update.
     */
    limit?: number
  }

  /**
   * WhatsAppMessageStats updateManyAndReturn
   */
  export type WhatsAppMessageStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppMessageStats.
     */
    data: XOR<WhatsAppMessageStatsUpdateManyMutationInput, WhatsAppMessageStatsUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppMessageStats to update
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * Limit how many WhatsAppMessageStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppMessageStats upsert
   */
  export type WhatsAppMessageStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppMessageStats to update in case it exists.
     */
    where: WhatsAppMessageStatsWhereUniqueInput
    /**
     * In case the WhatsAppMessageStats found by the `where` argument doesn't exist, create a new WhatsAppMessageStats with this data.
     */
    create: XOR<WhatsAppMessageStatsCreateInput, WhatsAppMessageStatsUncheckedCreateInput>
    /**
     * In case the WhatsAppMessageStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppMessageStatsUpdateInput, WhatsAppMessageStatsUncheckedUpdateInput>
  }

  /**
   * WhatsAppMessageStats delete
   */
  export type WhatsAppMessageStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppMessageStats to delete.
     */
    where: WhatsAppMessageStatsWhereUniqueInput
  }

  /**
   * WhatsAppMessageStats deleteMany
   */
  export type WhatsAppMessageStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppMessageStats to delete
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * Limit how many WhatsAppMessageStats to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppMessageStats without action
   */
  export type WhatsAppMessageStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppAIBot
   */

  export type AggregateWhatsAppAIBot = {
    _count: WhatsAppAIBotCountAggregateOutputType | null
    _min: WhatsAppAIBotMinAggregateOutputType | null
    _max: WhatsAppAIBotMaxAggregateOutputType | null
  }

  export type WhatsAppAIBotMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    isActive: boolean | null
    systemPrompt: string | null
    fallbackText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppAIBotMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    isActive: boolean | null
    systemPrompt: string | null
    fallbackText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppAIBotCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    isActive: number
    systemPrompt: number
    fallbackText: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsAppAIBotMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    isActive?: true
    systemPrompt?: true
    fallbackText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppAIBotMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    isActive?: true
    systemPrompt?: true
    fallbackText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppAIBotCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    isActive?: true
    systemPrompt?: true
    fallbackText?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsAppAIBotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppAIBot to aggregate.
     */
    where?: WhatsAppAIBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppAIBots to fetch.
     */
    orderBy?: WhatsAppAIBotOrderByWithRelationInput | WhatsAppAIBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppAIBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppAIBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppAIBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppAIBots
    **/
    _count?: true | WhatsAppAIBotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppAIBotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppAIBotMaxAggregateInputType
  }

  export type GetWhatsAppAIBotAggregateType<T extends WhatsAppAIBotAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppAIBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppAIBot[P]>
      : GetScalarType<T[P], AggregateWhatsAppAIBot[P]>
  }




  export type WhatsAppAIBotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppAIBotWhereInput
    orderBy?: WhatsAppAIBotOrderByWithAggregationInput | WhatsAppAIBotOrderByWithAggregationInput[]
    by: WhatsAppAIBotScalarFieldEnum[] | WhatsAppAIBotScalarFieldEnum
    having?: WhatsAppAIBotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppAIBotCountAggregateInputType | true
    _min?: WhatsAppAIBotMinAggregateInputType
    _max?: WhatsAppAIBotMaxAggregateInputType
  }

  export type WhatsAppAIBotGroupByOutputType = {
    id: string
    userId: string
    name: string
    isActive: boolean
    systemPrompt: string | null
    fallbackText: string | null
    createdAt: Date
    updatedAt: Date
    _count: WhatsAppAIBotCountAggregateOutputType | null
    _min: WhatsAppAIBotMinAggregateOutputType | null
    _max: WhatsAppAIBotMaxAggregateOutputType | null
  }

  type GetWhatsAppAIBotGroupByPayload<T extends WhatsAppAIBotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppAIBotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppAIBotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppAIBotGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppAIBotGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppAIBotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    isActive?: boolean
    systemPrompt?: boolean
    fallbackText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiBotSessionBindings?: boolean | WhatsAppAIBot$aiBotSessionBindingsArgs<ExtArgs>
    botKnowledgeBindings?: boolean | WhatsAppAIBot$botKnowledgeBindingsArgs<ExtArgs>
    _count?: boolean | WhatsAppAIBotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppAIBot"]>

  export type WhatsAppAIBotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    isActive?: boolean
    systemPrompt?: boolean
    fallbackText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppAIBot"]>

  export type WhatsAppAIBotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    isActive?: boolean
    systemPrompt?: boolean
    fallbackText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppAIBot"]>

  export type WhatsAppAIBotSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    isActive?: boolean
    systemPrompt?: boolean
    fallbackText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsAppAIBotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "isActive" | "systemPrompt" | "fallbackText" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsAppAIBot"]>
  export type WhatsAppAIBotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    aiBotSessionBindings?: boolean | WhatsAppAIBot$aiBotSessionBindingsArgs<ExtArgs>
    botKnowledgeBindings?: boolean | WhatsAppAIBot$botKnowledgeBindingsArgs<ExtArgs>
    _count?: boolean | WhatsAppAIBotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppAIBotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhatsAppAIBotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WhatsAppAIBotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppAIBot"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      aiBotSessionBindings: Prisma.$AIBotSessionBindingPayload<ExtArgs>[]
      botKnowledgeBindings: Prisma.$BotKnowledgeBindingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      isActive: boolean
      systemPrompt: string | null
      fallbackText: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsAppAIBot"]>
    composites: {}
  }

  type WhatsAppAIBotGetPayload<S extends boolean | null | undefined | WhatsAppAIBotDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppAIBotPayload, S>

  type WhatsAppAIBotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppAIBotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppAIBotCountAggregateInputType | true
    }

  export interface WhatsAppAIBotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppAIBot'], meta: { name: 'WhatsAppAIBot' } }
    /**
     * Find zero or one WhatsAppAIBot that matches the filter.
     * @param {WhatsAppAIBotFindUniqueArgs} args - Arguments to find a WhatsAppAIBot
     * @example
     * // Get one WhatsAppAIBot
     * const whatsAppAIBot = await prisma.whatsAppAIBot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppAIBotFindUniqueArgs>(args: SelectSubset<T, WhatsAppAIBotFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppAIBotClient<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppAIBot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppAIBotFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppAIBot
     * @example
     * // Get one WhatsAppAIBot
     * const whatsAppAIBot = await prisma.whatsAppAIBot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppAIBotFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppAIBotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppAIBotClient<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppAIBot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppAIBotFindFirstArgs} args - Arguments to find a WhatsAppAIBot
     * @example
     * // Get one WhatsAppAIBot
     * const whatsAppAIBot = await prisma.whatsAppAIBot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppAIBotFindFirstArgs>(args?: SelectSubset<T, WhatsAppAIBotFindFirstArgs<ExtArgs>>): Prisma__WhatsAppAIBotClient<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppAIBot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppAIBotFindFirstOrThrowArgs} args - Arguments to find a WhatsAppAIBot
     * @example
     * // Get one WhatsAppAIBot
     * const whatsAppAIBot = await prisma.whatsAppAIBot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppAIBotFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppAIBotFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppAIBotClient<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppAIBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppAIBotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppAIBots
     * const whatsAppAIBots = await prisma.whatsAppAIBot.findMany()
     * 
     * // Get first 10 WhatsAppAIBots
     * const whatsAppAIBots = await prisma.whatsAppAIBot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppAIBotWithIdOnly = await prisma.whatsAppAIBot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppAIBotFindManyArgs>(args?: SelectSubset<T, WhatsAppAIBotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppAIBot.
     * @param {WhatsAppAIBotCreateArgs} args - Arguments to create a WhatsAppAIBot.
     * @example
     * // Create one WhatsAppAIBot
     * const WhatsAppAIBot = await prisma.whatsAppAIBot.create({
     *   data: {
     *     // ... data to create a WhatsAppAIBot
     *   }
     * })
     * 
     */
    create<T extends WhatsAppAIBotCreateArgs>(args: SelectSubset<T, WhatsAppAIBotCreateArgs<ExtArgs>>): Prisma__WhatsAppAIBotClient<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppAIBots.
     * @param {WhatsAppAIBotCreateManyArgs} args - Arguments to create many WhatsAppAIBots.
     * @example
     * // Create many WhatsAppAIBots
     * const whatsAppAIBot = await prisma.whatsAppAIBot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppAIBotCreateManyArgs>(args?: SelectSubset<T, WhatsAppAIBotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppAIBots and returns the data saved in the database.
     * @param {WhatsAppAIBotCreateManyAndReturnArgs} args - Arguments to create many WhatsAppAIBots.
     * @example
     * // Create many WhatsAppAIBots
     * const whatsAppAIBot = await prisma.whatsAppAIBot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppAIBots and only return the `id`
     * const whatsAppAIBotWithIdOnly = await prisma.whatsAppAIBot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppAIBotCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppAIBotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppAIBot.
     * @param {WhatsAppAIBotDeleteArgs} args - Arguments to delete one WhatsAppAIBot.
     * @example
     * // Delete one WhatsAppAIBot
     * const WhatsAppAIBot = await prisma.whatsAppAIBot.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppAIBot
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppAIBotDeleteArgs>(args: SelectSubset<T, WhatsAppAIBotDeleteArgs<ExtArgs>>): Prisma__WhatsAppAIBotClient<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppAIBot.
     * @param {WhatsAppAIBotUpdateArgs} args - Arguments to update one WhatsAppAIBot.
     * @example
     * // Update one WhatsAppAIBot
     * const whatsAppAIBot = await prisma.whatsAppAIBot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppAIBotUpdateArgs>(args: SelectSubset<T, WhatsAppAIBotUpdateArgs<ExtArgs>>): Prisma__WhatsAppAIBotClient<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppAIBots.
     * @param {WhatsAppAIBotDeleteManyArgs} args - Arguments to filter WhatsAppAIBots to delete.
     * @example
     * // Delete a few WhatsAppAIBots
     * const { count } = await prisma.whatsAppAIBot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppAIBotDeleteManyArgs>(args?: SelectSubset<T, WhatsAppAIBotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppAIBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppAIBotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppAIBots
     * const whatsAppAIBot = await prisma.whatsAppAIBot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppAIBotUpdateManyArgs>(args: SelectSubset<T, WhatsAppAIBotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppAIBots and returns the data updated in the database.
     * @param {WhatsAppAIBotUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppAIBots.
     * @example
     * // Update many WhatsAppAIBots
     * const whatsAppAIBot = await prisma.whatsAppAIBot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppAIBots and only return the `id`
     * const whatsAppAIBotWithIdOnly = await prisma.whatsAppAIBot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppAIBotUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppAIBotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppAIBot.
     * @param {WhatsAppAIBotUpsertArgs} args - Arguments to update or create a WhatsAppAIBot.
     * @example
     * // Update or create a WhatsAppAIBot
     * const whatsAppAIBot = await prisma.whatsAppAIBot.upsert({
     *   create: {
     *     // ... data to create a WhatsAppAIBot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppAIBot we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppAIBotUpsertArgs>(args: SelectSubset<T, WhatsAppAIBotUpsertArgs<ExtArgs>>): Prisma__WhatsAppAIBotClient<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppAIBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppAIBotCountArgs} args - Arguments to filter WhatsAppAIBots to count.
     * @example
     * // Count the number of WhatsAppAIBots
     * const count = await prisma.whatsAppAIBot.count({
     *   where: {
     *     // ... the filter for the WhatsAppAIBots we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppAIBotCountArgs>(
      args?: Subset<T, WhatsAppAIBotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppAIBotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppAIBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppAIBotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppAIBotAggregateArgs>(args: Subset<T, WhatsAppAIBotAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppAIBotAggregateType<T>>

    /**
     * Group by WhatsAppAIBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppAIBotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppAIBotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppAIBotGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppAIBotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppAIBotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppAIBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppAIBot model
   */
  readonly fields: WhatsAppAIBotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppAIBot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppAIBotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    aiBotSessionBindings<T extends WhatsAppAIBot$aiBotSessionBindingsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppAIBot$aiBotSessionBindingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    botKnowledgeBindings<T extends WhatsAppAIBot$botKnowledgeBindingsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppAIBot$botKnowledgeBindingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppAIBot model
   */
  interface WhatsAppAIBotFieldRefs {
    readonly id: FieldRef<"WhatsAppAIBot", 'String'>
    readonly userId: FieldRef<"WhatsAppAIBot", 'String'>
    readonly name: FieldRef<"WhatsAppAIBot", 'String'>
    readonly isActive: FieldRef<"WhatsAppAIBot", 'Boolean'>
    readonly systemPrompt: FieldRef<"WhatsAppAIBot", 'String'>
    readonly fallbackText: FieldRef<"WhatsAppAIBot", 'String'>
    readonly createdAt: FieldRef<"WhatsAppAIBot", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppAIBot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppAIBot findUnique
   */
  export type WhatsAppAIBotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppAIBot to fetch.
     */
    where: WhatsAppAIBotWhereUniqueInput
  }

  /**
   * WhatsAppAIBot findUniqueOrThrow
   */
  export type WhatsAppAIBotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppAIBot to fetch.
     */
    where: WhatsAppAIBotWhereUniqueInput
  }

  /**
   * WhatsAppAIBot findFirst
   */
  export type WhatsAppAIBotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppAIBot to fetch.
     */
    where?: WhatsAppAIBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppAIBots to fetch.
     */
    orderBy?: WhatsAppAIBotOrderByWithRelationInput | WhatsAppAIBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppAIBots.
     */
    cursor?: WhatsAppAIBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppAIBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppAIBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppAIBots.
     */
    distinct?: WhatsAppAIBotScalarFieldEnum | WhatsAppAIBotScalarFieldEnum[]
  }

  /**
   * WhatsAppAIBot findFirstOrThrow
   */
  export type WhatsAppAIBotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppAIBot to fetch.
     */
    where?: WhatsAppAIBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppAIBots to fetch.
     */
    orderBy?: WhatsAppAIBotOrderByWithRelationInput | WhatsAppAIBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppAIBots.
     */
    cursor?: WhatsAppAIBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppAIBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppAIBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppAIBots.
     */
    distinct?: WhatsAppAIBotScalarFieldEnum | WhatsAppAIBotScalarFieldEnum[]
  }

  /**
   * WhatsAppAIBot findMany
   */
  export type WhatsAppAIBotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppAIBots to fetch.
     */
    where?: WhatsAppAIBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppAIBots to fetch.
     */
    orderBy?: WhatsAppAIBotOrderByWithRelationInput | WhatsAppAIBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppAIBots.
     */
    cursor?: WhatsAppAIBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppAIBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppAIBots.
     */
    skip?: number
    distinct?: WhatsAppAIBotScalarFieldEnum | WhatsAppAIBotScalarFieldEnum[]
  }

  /**
   * WhatsAppAIBot create
   */
  export type WhatsAppAIBotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppAIBot.
     */
    data: XOR<WhatsAppAIBotCreateInput, WhatsAppAIBotUncheckedCreateInput>
  }

  /**
   * WhatsAppAIBot createMany
   */
  export type WhatsAppAIBotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppAIBots.
     */
    data: WhatsAppAIBotCreateManyInput | WhatsAppAIBotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppAIBot createManyAndReturn
   */
  export type WhatsAppAIBotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppAIBots.
     */
    data: WhatsAppAIBotCreateManyInput | WhatsAppAIBotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppAIBot update
   */
  export type WhatsAppAIBotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppAIBot.
     */
    data: XOR<WhatsAppAIBotUpdateInput, WhatsAppAIBotUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppAIBot to update.
     */
    where: WhatsAppAIBotWhereUniqueInput
  }

  /**
   * WhatsAppAIBot updateMany
   */
  export type WhatsAppAIBotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppAIBots.
     */
    data: XOR<WhatsAppAIBotUpdateManyMutationInput, WhatsAppAIBotUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppAIBots to update
     */
    where?: WhatsAppAIBotWhereInput
    /**
     * Limit how many WhatsAppAIBots to update.
     */
    limit?: number
  }

  /**
   * WhatsAppAIBot updateManyAndReturn
   */
  export type WhatsAppAIBotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppAIBots.
     */
    data: XOR<WhatsAppAIBotUpdateManyMutationInput, WhatsAppAIBotUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppAIBots to update
     */
    where?: WhatsAppAIBotWhereInput
    /**
     * Limit how many WhatsAppAIBots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppAIBot upsert
   */
  export type WhatsAppAIBotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppAIBot to update in case it exists.
     */
    where: WhatsAppAIBotWhereUniqueInput
    /**
     * In case the WhatsAppAIBot found by the `where` argument doesn't exist, create a new WhatsAppAIBot with this data.
     */
    create: XOR<WhatsAppAIBotCreateInput, WhatsAppAIBotUncheckedCreateInput>
    /**
     * In case the WhatsAppAIBot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppAIBotUpdateInput, WhatsAppAIBotUncheckedUpdateInput>
  }

  /**
   * WhatsAppAIBot delete
   */
  export type WhatsAppAIBotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppAIBot to delete.
     */
    where: WhatsAppAIBotWhereUniqueInput
  }

  /**
   * WhatsAppAIBot deleteMany
   */
  export type WhatsAppAIBotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppAIBots to delete
     */
    where?: WhatsAppAIBotWhereInput
    /**
     * Limit how many WhatsAppAIBots to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppAIBot.aiBotSessionBindings
   */
  export type WhatsAppAIBot$aiBotSessionBindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    where?: AIBotSessionBindingWhereInput
    orderBy?: AIBotSessionBindingOrderByWithRelationInput | AIBotSessionBindingOrderByWithRelationInput[]
    cursor?: AIBotSessionBindingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIBotSessionBindingScalarFieldEnum | AIBotSessionBindingScalarFieldEnum[]
  }

  /**
   * WhatsAppAIBot.botKnowledgeBindings
   */
  export type WhatsAppAIBot$botKnowledgeBindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    where?: BotKnowledgeBindingWhereInput
    orderBy?: BotKnowledgeBindingOrderByWithRelationInput | BotKnowledgeBindingOrderByWithRelationInput[]
    cursor?: BotKnowledgeBindingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotKnowledgeBindingScalarFieldEnum | BotKnowledgeBindingScalarFieldEnum[]
  }

  /**
   * WhatsAppAIBot without action
   */
  export type WhatsAppAIBotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppAIBot
     */
    select?: WhatsAppAIBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppAIBot
     */
    omit?: WhatsAppAIBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppAIBotInclude<ExtArgs> | null
  }


  /**
   * Model AIDocument
   */

  export type AggregateAIDocument = {
    _count: AIDocumentCountAggregateOutputType | null
    _min: AIDocumentMinAggregateOutputType | null
    _max: AIDocumentMaxAggregateOutputType | null
  }

  export type AIDocumentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    kind: string | null
    content: string | null
    embeddingId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIDocumentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    kind: string | null
    content: string | null
    embeddingId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIDocumentCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    kind: number
    content: number
    embeddingId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIDocumentMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    kind?: true
    content?: true
    embeddingId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIDocumentMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    kind?: true
    content?: true
    embeddingId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIDocumentCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    kind?: true
    content?: true
    embeddingId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIDocument to aggregate.
     */
    where?: AIDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDocuments to fetch.
     */
    orderBy?: AIDocumentOrderByWithRelationInput | AIDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIDocuments
    **/
    _count?: true | AIDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIDocumentMaxAggregateInputType
  }

  export type GetAIDocumentAggregateType<T extends AIDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateAIDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIDocument[P]>
      : GetScalarType<T[P], AggregateAIDocument[P]>
  }




  export type AIDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIDocumentWhereInput
    orderBy?: AIDocumentOrderByWithAggregationInput | AIDocumentOrderByWithAggregationInput[]
    by: AIDocumentScalarFieldEnum[] | AIDocumentScalarFieldEnum
    having?: AIDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIDocumentCountAggregateInputType | true
    _min?: AIDocumentMinAggregateInputType
    _max?: AIDocumentMaxAggregateInputType
  }

  export type AIDocumentGroupByOutputType = {
    id: string
    userId: string
    title: string
    kind: string
    content: string
    embeddingId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AIDocumentCountAggregateOutputType | null
    _min: AIDocumentMinAggregateOutputType | null
    _max: AIDocumentMaxAggregateOutputType | null
  }

  type GetAIDocumentGroupByPayload<T extends AIDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], AIDocumentGroupByOutputType[P]>
        }
      >
    >


  export type AIDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    kind?: boolean
    content?: boolean
    embeddingId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    botKnowledgeBindings?: boolean | AIDocument$botKnowledgeBindingsArgs<ExtArgs>
    _count?: boolean | AIDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIDocument"]>

  export type AIDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    kind?: boolean
    content?: boolean
    embeddingId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIDocument"]>

  export type AIDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    kind?: boolean
    content?: boolean
    embeddingId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIDocument"]>

  export type AIDocumentSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    kind?: boolean
    content?: boolean
    embeddingId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "kind" | "content" | "embeddingId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["aIDocument"]>
  export type AIDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    botKnowledgeBindings?: boolean | AIDocument$botKnowledgeBindingsArgs<ExtArgs>
    _count?: boolean | AIDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AIDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIDocument"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      botKnowledgeBindings: Prisma.$BotKnowledgeBindingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      kind: string
      content: string
      embeddingId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIDocument"]>
    composites: {}
  }

  type AIDocumentGetPayload<S extends boolean | null | undefined | AIDocumentDefaultArgs> = $Result.GetResult<Prisma.$AIDocumentPayload, S>

  type AIDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIDocumentCountAggregateInputType | true
    }

  export interface AIDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIDocument'], meta: { name: 'AIDocument' } }
    /**
     * Find zero or one AIDocument that matches the filter.
     * @param {AIDocumentFindUniqueArgs} args - Arguments to find a AIDocument
     * @example
     * // Get one AIDocument
     * const aIDocument = await prisma.aIDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIDocumentFindUniqueArgs>(args: SelectSubset<T, AIDocumentFindUniqueArgs<ExtArgs>>): Prisma__AIDocumentClient<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIDocumentFindUniqueOrThrowArgs} args - Arguments to find a AIDocument
     * @example
     * // Get one AIDocument
     * const aIDocument = await prisma.aIDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, AIDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIDocumentClient<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDocumentFindFirstArgs} args - Arguments to find a AIDocument
     * @example
     * // Get one AIDocument
     * const aIDocument = await prisma.aIDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIDocumentFindFirstArgs>(args?: SelectSubset<T, AIDocumentFindFirstArgs<ExtArgs>>): Prisma__AIDocumentClient<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDocumentFindFirstOrThrowArgs} args - Arguments to find a AIDocument
     * @example
     * // Get one AIDocument
     * const aIDocument = await prisma.aIDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, AIDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIDocumentClient<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIDocuments
     * const aIDocuments = await prisma.aIDocument.findMany()
     * 
     * // Get first 10 AIDocuments
     * const aIDocuments = await prisma.aIDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIDocumentWithIdOnly = await prisma.aIDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIDocumentFindManyArgs>(args?: SelectSubset<T, AIDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIDocument.
     * @param {AIDocumentCreateArgs} args - Arguments to create a AIDocument.
     * @example
     * // Create one AIDocument
     * const AIDocument = await prisma.aIDocument.create({
     *   data: {
     *     // ... data to create a AIDocument
     *   }
     * })
     * 
     */
    create<T extends AIDocumentCreateArgs>(args: SelectSubset<T, AIDocumentCreateArgs<ExtArgs>>): Prisma__AIDocumentClient<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIDocuments.
     * @param {AIDocumentCreateManyArgs} args - Arguments to create many AIDocuments.
     * @example
     * // Create many AIDocuments
     * const aIDocument = await prisma.aIDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIDocumentCreateManyArgs>(args?: SelectSubset<T, AIDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIDocuments and returns the data saved in the database.
     * @param {AIDocumentCreateManyAndReturnArgs} args - Arguments to create many AIDocuments.
     * @example
     * // Create many AIDocuments
     * const aIDocument = await prisma.aIDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIDocuments and only return the `id`
     * const aIDocumentWithIdOnly = await prisma.aIDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, AIDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIDocument.
     * @param {AIDocumentDeleteArgs} args - Arguments to delete one AIDocument.
     * @example
     * // Delete one AIDocument
     * const AIDocument = await prisma.aIDocument.delete({
     *   where: {
     *     // ... filter to delete one AIDocument
     *   }
     * })
     * 
     */
    delete<T extends AIDocumentDeleteArgs>(args: SelectSubset<T, AIDocumentDeleteArgs<ExtArgs>>): Prisma__AIDocumentClient<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIDocument.
     * @param {AIDocumentUpdateArgs} args - Arguments to update one AIDocument.
     * @example
     * // Update one AIDocument
     * const aIDocument = await prisma.aIDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIDocumentUpdateArgs>(args: SelectSubset<T, AIDocumentUpdateArgs<ExtArgs>>): Prisma__AIDocumentClient<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIDocuments.
     * @param {AIDocumentDeleteManyArgs} args - Arguments to filter AIDocuments to delete.
     * @example
     * // Delete a few AIDocuments
     * const { count } = await prisma.aIDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIDocumentDeleteManyArgs>(args?: SelectSubset<T, AIDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIDocuments
     * const aIDocument = await prisma.aIDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIDocumentUpdateManyArgs>(args: SelectSubset<T, AIDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIDocuments and returns the data updated in the database.
     * @param {AIDocumentUpdateManyAndReturnArgs} args - Arguments to update many AIDocuments.
     * @example
     * // Update many AIDocuments
     * const aIDocument = await prisma.aIDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIDocuments and only return the `id`
     * const aIDocumentWithIdOnly = await prisma.aIDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, AIDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIDocument.
     * @param {AIDocumentUpsertArgs} args - Arguments to update or create a AIDocument.
     * @example
     * // Update or create a AIDocument
     * const aIDocument = await prisma.aIDocument.upsert({
     *   create: {
     *     // ... data to create a AIDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIDocument we want to update
     *   }
     * })
     */
    upsert<T extends AIDocumentUpsertArgs>(args: SelectSubset<T, AIDocumentUpsertArgs<ExtArgs>>): Prisma__AIDocumentClient<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDocumentCountArgs} args - Arguments to filter AIDocuments to count.
     * @example
     * // Count the number of AIDocuments
     * const count = await prisma.aIDocument.count({
     *   where: {
     *     // ... the filter for the AIDocuments we want to count
     *   }
     * })
    **/
    count<T extends AIDocumentCountArgs>(
      args?: Subset<T, AIDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIDocumentAggregateArgs>(args: Subset<T, AIDocumentAggregateArgs>): Prisma.PrismaPromise<GetAIDocumentAggregateType<T>>

    /**
     * Group by AIDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIDocumentGroupByArgs['orderBy'] }
        : { orderBy?: AIDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIDocument model
   */
  readonly fields: AIDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    botKnowledgeBindings<T extends AIDocument$botKnowledgeBindingsArgs<ExtArgs> = {}>(args?: Subset<T, AIDocument$botKnowledgeBindingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIDocument model
   */
  interface AIDocumentFieldRefs {
    readonly id: FieldRef<"AIDocument", 'String'>
    readonly userId: FieldRef<"AIDocument", 'String'>
    readonly title: FieldRef<"AIDocument", 'String'>
    readonly kind: FieldRef<"AIDocument", 'String'>
    readonly content: FieldRef<"AIDocument", 'String'>
    readonly embeddingId: FieldRef<"AIDocument", 'String'>
    readonly isActive: FieldRef<"AIDocument", 'Boolean'>
    readonly createdAt: FieldRef<"AIDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"AIDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIDocument findUnique
   */
  export type AIDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AIDocument to fetch.
     */
    where: AIDocumentWhereUniqueInput
  }

  /**
   * AIDocument findUniqueOrThrow
   */
  export type AIDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AIDocument to fetch.
     */
    where: AIDocumentWhereUniqueInput
  }

  /**
   * AIDocument findFirst
   */
  export type AIDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AIDocument to fetch.
     */
    where?: AIDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDocuments to fetch.
     */
    orderBy?: AIDocumentOrderByWithRelationInput | AIDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIDocuments.
     */
    cursor?: AIDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIDocuments.
     */
    distinct?: AIDocumentScalarFieldEnum | AIDocumentScalarFieldEnum[]
  }

  /**
   * AIDocument findFirstOrThrow
   */
  export type AIDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AIDocument to fetch.
     */
    where?: AIDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDocuments to fetch.
     */
    orderBy?: AIDocumentOrderByWithRelationInput | AIDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIDocuments.
     */
    cursor?: AIDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIDocuments.
     */
    distinct?: AIDocumentScalarFieldEnum | AIDocumentScalarFieldEnum[]
  }

  /**
   * AIDocument findMany
   */
  export type AIDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AIDocuments to fetch.
     */
    where?: AIDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDocuments to fetch.
     */
    orderBy?: AIDocumentOrderByWithRelationInput | AIDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIDocuments.
     */
    cursor?: AIDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDocuments.
     */
    skip?: number
    distinct?: AIDocumentScalarFieldEnum | AIDocumentScalarFieldEnum[]
  }

  /**
   * AIDocument create
   */
  export type AIDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a AIDocument.
     */
    data: XOR<AIDocumentCreateInput, AIDocumentUncheckedCreateInput>
  }

  /**
   * AIDocument createMany
   */
  export type AIDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIDocuments.
     */
    data: AIDocumentCreateManyInput | AIDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIDocument createManyAndReturn
   */
  export type AIDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many AIDocuments.
     */
    data: AIDocumentCreateManyInput | AIDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIDocument update
   */
  export type AIDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a AIDocument.
     */
    data: XOR<AIDocumentUpdateInput, AIDocumentUncheckedUpdateInput>
    /**
     * Choose, which AIDocument to update.
     */
    where: AIDocumentWhereUniqueInput
  }

  /**
   * AIDocument updateMany
   */
  export type AIDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIDocuments.
     */
    data: XOR<AIDocumentUpdateManyMutationInput, AIDocumentUncheckedUpdateManyInput>
    /**
     * Filter which AIDocuments to update
     */
    where?: AIDocumentWhereInput
    /**
     * Limit how many AIDocuments to update.
     */
    limit?: number
  }

  /**
   * AIDocument updateManyAndReturn
   */
  export type AIDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * The data used to update AIDocuments.
     */
    data: XOR<AIDocumentUpdateManyMutationInput, AIDocumentUncheckedUpdateManyInput>
    /**
     * Filter which AIDocuments to update
     */
    where?: AIDocumentWhereInput
    /**
     * Limit how many AIDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIDocument upsert
   */
  export type AIDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the AIDocument to update in case it exists.
     */
    where: AIDocumentWhereUniqueInput
    /**
     * In case the AIDocument found by the `where` argument doesn't exist, create a new AIDocument with this data.
     */
    create: XOR<AIDocumentCreateInput, AIDocumentUncheckedCreateInput>
    /**
     * In case the AIDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIDocumentUpdateInput, AIDocumentUncheckedUpdateInput>
  }

  /**
   * AIDocument delete
   */
  export type AIDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
    /**
     * Filter which AIDocument to delete.
     */
    where: AIDocumentWhereUniqueInput
  }

  /**
   * AIDocument deleteMany
   */
  export type AIDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIDocuments to delete
     */
    where?: AIDocumentWhereInput
    /**
     * Limit how many AIDocuments to delete.
     */
    limit?: number
  }

  /**
   * AIDocument.botKnowledgeBindings
   */
  export type AIDocument$botKnowledgeBindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    where?: BotKnowledgeBindingWhereInput
    orderBy?: BotKnowledgeBindingOrderByWithRelationInput | BotKnowledgeBindingOrderByWithRelationInput[]
    cursor?: BotKnowledgeBindingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotKnowledgeBindingScalarFieldEnum | BotKnowledgeBindingScalarFieldEnum[]
  }

  /**
   * AIDocument without action
   */
  export type AIDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDocument
     */
    select?: AIDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDocument
     */
    omit?: AIDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDocumentInclude<ExtArgs> | null
  }


  /**
   * Model AIUsageLog
   */

  export type AggregateAIUsageLog = {
    _count: AIUsageLogCountAggregateOutputType | null
    _avg: AIUsageLogAvgAggregateOutputType | null
    _sum: AIUsageLogSumAggregateOutputType | null
    _min: AIUsageLogMinAggregateOutputType | null
    _max: AIUsageLogMaxAggregateOutputType | null
  }

  export type AIUsageLogAvgAggregateOutputType = {
    inputTokens: number | null
    outputTokens: number | null
    totalTokens: number | null
    latencyMs: number | null
  }

  export type AIUsageLogSumAggregateOutputType = {
    inputTokens: number | null
    outputTokens: number | null
    totalTokens: number | null
    latencyMs: number | null
  }

  export type AIUsageLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    inputTokens: number | null
    outputTokens: number | null
    totalTokens: number | null
    latencyMs: number | null
    status: string | null
    errorReason: string | null
    createdAt: Date | null
  }

  export type AIUsageLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    inputTokens: number | null
    outputTokens: number | null
    totalTokens: number | null
    latencyMs: number | null
    status: string | null
    errorReason: string | null
    createdAt: Date | null
  }

  export type AIUsageLogCountAggregateOutputType = {
    id: number
    userId: number
    sessionId: number
    inputTokens: number
    outputTokens: number
    totalTokens: number
    latencyMs: number
    status: number
    errorReason: number
    createdAt: number
    _all: number
  }


  export type AIUsageLogAvgAggregateInputType = {
    inputTokens?: true
    outputTokens?: true
    totalTokens?: true
    latencyMs?: true
  }

  export type AIUsageLogSumAggregateInputType = {
    inputTokens?: true
    outputTokens?: true
    totalTokens?: true
    latencyMs?: true
  }

  export type AIUsageLogMinAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    inputTokens?: true
    outputTokens?: true
    totalTokens?: true
    latencyMs?: true
    status?: true
    errorReason?: true
    createdAt?: true
  }

  export type AIUsageLogMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    inputTokens?: true
    outputTokens?: true
    totalTokens?: true
    latencyMs?: true
    status?: true
    errorReason?: true
    createdAt?: true
  }

  export type AIUsageLogCountAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    inputTokens?: true
    outputTokens?: true
    totalTokens?: true
    latencyMs?: true
    status?: true
    errorReason?: true
    createdAt?: true
    _all?: true
  }

  export type AIUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageLog to aggregate.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIUsageLogs
    **/
    _count?: true | AIUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIUsageLogMaxAggregateInputType
  }

  export type GetAIUsageLogAggregateType<T extends AIUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAIUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIUsageLog[P]>
      : GetScalarType<T[P], AggregateAIUsageLog[P]>
  }




  export type AIUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageLogWhereInput
    orderBy?: AIUsageLogOrderByWithAggregationInput | AIUsageLogOrderByWithAggregationInput[]
    by: AIUsageLogScalarFieldEnum[] | AIUsageLogScalarFieldEnum
    having?: AIUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIUsageLogCountAggregateInputType | true
    _avg?: AIUsageLogAvgAggregateInputType
    _sum?: AIUsageLogSumAggregateInputType
    _min?: AIUsageLogMinAggregateInputType
    _max?: AIUsageLogMaxAggregateInputType
  }

  export type AIUsageLogGroupByOutputType = {
    id: string
    userId: string
    sessionId: string | null
    inputTokens: number
    outputTokens: number
    totalTokens: number
    latencyMs: number
    status: string
    errorReason: string | null
    createdAt: Date
    _count: AIUsageLogCountAggregateOutputType | null
    _avg: AIUsageLogAvgAggregateOutputType | null
    _sum: AIUsageLogSumAggregateOutputType | null
    _min: AIUsageLogMinAggregateOutputType | null
    _max: AIUsageLogMaxAggregateOutputType | null
  }

  type GetAIUsageLogGroupByPayload<T extends AIUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], AIUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type AIUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    totalTokens?: boolean
    latencyMs?: boolean
    status?: boolean
    errorReason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    totalTokens?: boolean
    latencyMs?: boolean
    status?: boolean
    errorReason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    totalTokens?: boolean
    latencyMs?: boolean
    status?: boolean
    errorReason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    totalTokens?: boolean
    latencyMs?: boolean
    status?: boolean
    errorReason?: boolean
    createdAt?: boolean
  }

  export type AIUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionId" | "inputTokens" | "outputTokens" | "totalTokens" | "latencyMs" | "status" | "errorReason" | "createdAt", ExtArgs["result"]["aIUsageLog"]>
  export type AIUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AIUsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AIUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIUsageLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionId: string | null
      inputTokens: number
      outputTokens: number
      totalTokens: number
      latencyMs: number
      status: string
      errorReason: string | null
      createdAt: Date
    }, ExtArgs["result"]["aIUsageLog"]>
    composites: {}
  }

  type AIUsageLogGetPayload<S extends boolean | null | undefined | AIUsageLogDefaultArgs> = $Result.GetResult<Prisma.$AIUsageLogPayload, S>

  type AIUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIUsageLogCountAggregateInputType | true
    }

  export interface AIUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIUsageLog'], meta: { name: 'AIUsageLog' } }
    /**
     * Find zero or one AIUsageLog that matches the filter.
     * @param {AIUsageLogFindUniqueArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIUsageLogFindUniqueArgs>(args: SelectSubset<T, AIUsageLogFindUniqueArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIUsageLogFindUniqueOrThrowArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AIUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindFirstArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIUsageLogFindFirstArgs>(args?: SelectSubset<T, AIUsageLogFindFirstArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindFirstOrThrowArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AIUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIUsageLogs
     * const aIUsageLogs = await prisma.aIUsageLog.findMany()
     * 
     * // Get first 10 AIUsageLogs
     * const aIUsageLogs = await prisma.aIUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIUsageLogFindManyArgs>(args?: SelectSubset<T, AIUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIUsageLog.
     * @param {AIUsageLogCreateArgs} args - Arguments to create a AIUsageLog.
     * @example
     * // Create one AIUsageLog
     * const AIUsageLog = await prisma.aIUsageLog.create({
     *   data: {
     *     // ... data to create a AIUsageLog
     *   }
     * })
     * 
     */
    create<T extends AIUsageLogCreateArgs>(args: SelectSubset<T, AIUsageLogCreateArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIUsageLogs.
     * @param {AIUsageLogCreateManyArgs} args - Arguments to create many AIUsageLogs.
     * @example
     * // Create many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIUsageLogCreateManyArgs>(args?: SelectSubset<T, AIUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIUsageLogs and returns the data saved in the database.
     * @param {AIUsageLogCreateManyAndReturnArgs} args - Arguments to create many AIUsageLogs.
     * @example
     * // Create many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIUsageLogs and only return the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AIUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIUsageLog.
     * @param {AIUsageLogDeleteArgs} args - Arguments to delete one AIUsageLog.
     * @example
     * // Delete one AIUsageLog
     * const AIUsageLog = await prisma.aIUsageLog.delete({
     *   where: {
     *     // ... filter to delete one AIUsageLog
     *   }
     * })
     * 
     */
    delete<T extends AIUsageLogDeleteArgs>(args: SelectSubset<T, AIUsageLogDeleteArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIUsageLog.
     * @param {AIUsageLogUpdateArgs} args - Arguments to update one AIUsageLog.
     * @example
     * // Update one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIUsageLogUpdateArgs>(args: SelectSubset<T, AIUsageLogUpdateArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIUsageLogs.
     * @param {AIUsageLogDeleteManyArgs} args - Arguments to filter AIUsageLogs to delete.
     * @example
     * // Delete a few AIUsageLogs
     * const { count } = await prisma.aIUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIUsageLogDeleteManyArgs>(args?: SelectSubset<T, AIUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIUsageLogUpdateManyArgs>(args: SelectSubset<T, AIUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageLogs and returns the data updated in the database.
     * @param {AIUsageLogUpdateManyAndReturnArgs} args - Arguments to update many AIUsageLogs.
     * @example
     * // Update many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIUsageLogs and only return the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AIUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIUsageLog.
     * @param {AIUsageLogUpsertArgs} args - Arguments to update or create a AIUsageLog.
     * @example
     * // Update or create a AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.upsert({
     *   create: {
     *     // ... data to create a AIUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends AIUsageLogUpsertArgs>(args: SelectSubset<T, AIUsageLogUpsertArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogCountArgs} args - Arguments to filter AIUsageLogs to count.
     * @example
     * // Count the number of AIUsageLogs
     * const count = await prisma.aIUsageLog.count({
     *   where: {
     *     // ... the filter for the AIUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends AIUsageLogCountArgs>(
      args?: Subset<T, AIUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIUsageLogAggregateArgs>(args: Subset<T, AIUsageLogAggregateArgs>): Prisma.PrismaPromise<GetAIUsageLogAggregateType<T>>

    /**
     * Group by AIUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: AIUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIUsageLog model
   */
  readonly fields: AIUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIUsageLog model
   */
  interface AIUsageLogFieldRefs {
    readonly id: FieldRef<"AIUsageLog", 'String'>
    readonly userId: FieldRef<"AIUsageLog", 'String'>
    readonly sessionId: FieldRef<"AIUsageLog", 'String'>
    readonly inputTokens: FieldRef<"AIUsageLog", 'Int'>
    readonly outputTokens: FieldRef<"AIUsageLog", 'Int'>
    readonly totalTokens: FieldRef<"AIUsageLog", 'Int'>
    readonly latencyMs: FieldRef<"AIUsageLog", 'Int'>
    readonly status: FieldRef<"AIUsageLog", 'String'>
    readonly errorReason: FieldRef<"AIUsageLog", 'String'>
    readonly createdAt: FieldRef<"AIUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIUsageLog findUnique
   */
  export type AIUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog findUniqueOrThrow
   */
  export type AIUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog findFirst
   */
  export type AIUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageLogs.
     */
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog findFirstOrThrow
   */
  export type AIUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageLogs.
     */
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog findMany
   */
  export type AIUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which AIUsageLogs to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog create
   */
  export type AIUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AIUsageLog.
     */
    data: XOR<AIUsageLogCreateInput, AIUsageLogUncheckedCreateInput>
  }

  /**
   * AIUsageLog createMany
   */
  export type AIUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIUsageLogs.
     */
    data: AIUsageLogCreateManyInput | AIUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIUsageLog createManyAndReturn
   */
  export type AIUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many AIUsageLogs.
     */
    data: AIUsageLogCreateManyInput | AIUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIUsageLog update
   */
  export type AIUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AIUsageLog.
     */
    data: XOR<AIUsageLogUpdateInput, AIUsageLogUncheckedUpdateInput>
    /**
     * Choose, which AIUsageLog to update.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog updateMany
   */
  export type AIUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIUsageLogs.
     */
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageLogs to update
     */
    where?: AIUsageLogWhereInput
    /**
     * Limit how many AIUsageLogs to update.
     */
    limit?: number
  }

  /**
   * AIUsageLog updateManyAndReturn
   */
  export type AIUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update AIUsageLogs.
     */
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageLogs to update
     */
    where?: AIUsageLogWhereInput
    /**
     * Limit how many AIUsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIUsageLog upsert
   */
  export type AIUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AIUsageLog to update in case it exists.
     */
    where: AIUsageLogWhereUniqueInput
    /**
     * In case the AIUsageLog found by the `where` argument doesn't exist, create a new AIUsageLog with this data.
     */
    create: XOR<AIUsageLogCreateInput, AIUsageLogUncheckedCreateInput>
    /**
     * In case the AIUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIUsageLogUpdateInput, AIUsageLogUncheckedUpdateInput>
  }

  /**
   * AIUsageLog delete
   */
  export type AIUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
    /**
     * Filter which AIUsageLog to delete.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog deleteMany
   */
  export type AIUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageLogs to delete
     */
    where?: AIUsageLogWhereInput
    /**
     * Limit how many AIUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * AIUsageLog without action
   */
  export type AIUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model AIBotSessionBinding
   */

  export type AggregateAIBotSessionBinding = {
    _count: AIBotSessionBindingCountAggregateOutputType | null
    _min: AIBotSessionBindingMinAggregateOutputType | null
    _max: AIBotSessionBindingMaxAggregateOutputType | null
  }

  export type AIBotSessionBindingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    botId: string | null
    sessionId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIBotSessionBindingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    botId: string | null
    sessionId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIBotSessionBindingCountAggregateOutputType = {
    id: number
    userId: number
    botId: number
    sessionId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIBotSessionBindingMinAggregateInputType = {
    id?: true
    userId?: true
    botId?: true
    sessionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIBotSessionBindingMaxAggregateInputType = {
    id?: true
    userId?: true
    botId?: true
    sessionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIBotSessionBindingCountAggregateInputType = {
    id?: true
    userId?: true
    botId?: true
    sessionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIBotSessionBindingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIBotSessionBinding to aggregate.
     */
    where?: AIBotSessionBindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIBotSessionBindings to fetch.
     */
    orderBy?: AIBotSessionBindingOrderByWithRelationInput | AIBotSessionBindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIBotSessionBindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIBotSessionBindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIBotSessionBindings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIBotSessionBindings
    **/
    _count?: true | AIBotSessionBindingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIBotSessionBindingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIBotSessionBindingMaxAggregateInputType
  }

  export type GetAIBotSessionBindingAggregateType<T extends AIBotSessionBindingAggregateArgs> = {
        [P in keyof T & keyof AggregateAIBotSessionBinding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIBotSessionBinding[P]>
      : GetScalarType<T[P], AggregateAIBotSessionBinding[P]>
  }




  export type AIBotSessionBindingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIBotSessionBindingWhereInput
    orderBy?: AIBotSessionBindingOrderByWithAggregationInput | AIBotSessionBindingOrderByWithAggregationInput[]
    by: AIBotSessionBindingScalarFieldEnum[] | AIBotSessionBindingScalarFieldEnum
    having?: AIBotSessionBindingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIBotSessionBindingCountAggregateInputType | true
    _min?: AIBotSessionBindingMinAggregateInputType
    _max?: AIBotSessionBindingMaxAggregateInputType
  }

  export type AIBotSessionBindingGroupByOutputType = {
    id: string
    userId: string
    botId: string
    sessionId: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AIBotSessionBindingCountAggregateOutputType | null
    _min: AIBotSessionBindingMinAggregateOutputType | null
    _max: AIBotSessionBindingMaxAggregateOutputType | null
  }

  type GetAIBotSessionBindingGroupByPayload<T extends AIBotSessionBindingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIBotSessionBindingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIBotSessionBindingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIBotSessionBindingGroupByOutputType[P]>
            : GetScalarType<T[P], AIBotSessionBindingGroupByOutputType[P]>
        }
      >
    >


  export type AIBotSessionBindingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    botId?: boolean
    sessionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIBotSessionBinding"]>

  export type AIBotSessionBindingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    botId?: boolean
    sessionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIBotSessionBinding"]>

  export type AIBotSessionBindingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    botId?: boolean
    sessionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIBotSessionBinding"]>

  export type AIBotSessionBindingSelectScalar = {
    id?: boolean
    userId?: boolean
    botId?: boolean
    sessionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIBotSessionBindingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "botId" | "sessionId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["aIBotSessionBinding"]>
  export type AIBotSessionBindingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }
  export type AIBotSessionBindingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }
  export type AIBotSessionBindingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }

  export type $AIBotSessionBindingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIBotSessionBinding"
    objects: {
      bot: Prisma.$WhatsAppAIBotPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      session: Prisma.$WhatsAppSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      botId: string
      sessionId: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIBotSessionBinding"]>
    composites: {}
  }

  type AIBotSessionBindingGetPayload<S extends boolean | null | undefined | AIBotSessionBindingDefaultArgs> = $Result.GetResult<Prisma.$AIBotSessionBindingPayload, S>

  type AIBotSessionBindingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIBotSessionBindingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIBotSessionBindingCountAggregateInputType | true
    }

  export interface AIBotSessionBindingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIBotSessionBinding'], meta: { name: 'AIBotSessionBinding' } }
    /**
     * Find zero or one AIBotSessionBinding that matches the filter.
     * @param {AIBotSessionBindingFindUniqueArgs} args - Arguments to find a AIBotSessionBinding
     * @example
     * // Get one AIBotSessionBinding
     * const aIBotSessionBinding = await prisma.aIBotSessionBinding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIBotSessionBindingFindUniqueArgs>(args: SelectSubset<T, AIBotSessionBindingFindUniqueArgs<ExtArgs>>): Prisma__AIBotSessionBindingClient<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIBotSessionBinding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIBotSessionBindingFindUniqueOrThrowArgs} args - Arguments to find a AIBotSessionBinding
     * @example
     * // Get one AIBotSessionBinding
     * const aIBotSessionBinding = await prisma.aIBotSessionBinding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIBotSessionBindingFindUniqueOrThrowArgs>(args: SelectSubset<T, AIBotSessionBindingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIBotSessionBindingClient<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIBotSessionBinding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIBotSessionBindingFindFirstArgs} args - Arguments to find a AIBotSessionBinding
     * @example
     * // Get one AIBotSessionBinding
     * const aIBotSessionBinding = await prisma.aIBotSessionBinding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIBotSessionBindingFindFirstArgs>(args?: SelectSubset<T, AIBotSessionBindingFindFirstArgs<ExtArgs>>): Prisma__AIBotSessionBindingClient<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIBotSessionBinding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIBotSessionBindingFindFirstOrThrowArgs} args - Arguments to find a AIBotSessionBinding
     * @example
     * // Get one AIBotSessionBinding
     * const aIBotSessionBinding = await prisma.aIBotSessionBinding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIBotSessionBindingFindFirstOrThrowArgs>(args?: SelectSubset<T, AIBotSessionBindingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIBotSessionBindingClient<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIBotSessionBindings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIBotSessionBindingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIBotSessionBindings
     * const aIBotSessionBindings = await prisma.aIBotSessionBinding.findMany()
     * 
     * // Get first 10 AIBotSessionBindings
     * const aIBotSessionBindings = await prisma.aIBotSessionBinding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIBotSessionBindingWithIdOnly = await prisma.aIBotSessionBinding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIBotSessionBindingFindManyArgs>(args?: SelectSubset<T, AIBotSessionBindingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIBotSessionBinding.
     * @param {AIBotSessionBindingCreateArgs} args - Arguments to create a AIBotSessionBinding.
     * @example
     * // Create one AIBotSessionBinding
     * const AIBotSessionBinding = await prisma.aIBotSessionBinding.create({
     *   data: {
     *     // ... data to create a AIBotSessionBinding
     *   }
     * })
     * 
     */
    create<T extends AIBotSessionBindingCreateArgs>(args: SelectSubset<T, AIBotSessionBindingCreateArgs<ExtArgs>>): Prisma__AIBotSessionBindingClient<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIBotSessionBindings.
     * @param {AIBotSessionBindingCreateManyArgs} args - Arguments to create many AIBotSessionBindings.
     * @example
     * // Create many AIBotSessionBindings
     * const aIBotSessionBinding = await prisma.aIBotSessionBinding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIBotSessionBindingCreateManyArgs>(args?: SelectSubset<T, AIBotSessionBindingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIBotSessionBindings and returns the data saved in the database.
     * @param {AIBotSessionBindingCreateManyAndReturnArgs} args - Arguments to create many AIBotSessionBindings.
     * @example
     * // Create many AIBotSessionBindings
     * const aIBotSessionBinding = await prisma.aIBotSessionBinding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIBotSessionBindings and only return the `id`
     * const aIBotSessionBindingWithIdOnly = await prisma.aIBotSessionBinding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIBotSessionBindingCreateManyAndReturnArgs>(args?: SelectSubset<T, AIBotSessionBindingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIBotSessionBinding.
     * @param {AIBotSessionBindingDeleteArgs} args - Arguments to delete one AIBotSessionBinding.
     * @example
     * // Delete one AIBotSessionBinding
     * const AIBotSessionBinding = await prisma.aIBotSessionBinding.delete({
     *   where: {
     *     // ... filter to delete one AIBotSessionBinding
     *   }
     * })
     * 
     */
    delete<T extends AIBotSessionBindingDeleteArgs>(args: SelectSubset<T, AIBotSessionBindingDeleteArgs<ExtArgs>>): Prisma__AIBotSessionBindingClient<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIBotSessionBinding.
     * @param {AIBotSessionBindingUpdateArgs} args - Arguments to update one AIBotSessionBinding.
     * @example
     * // Update one AIBotSessionBinding
     * const aIBotSessionBinding = await prisma.aIBotSessionBinding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIBotSessionBindingUpdateArgs>(args: SelectSubset<T, AIBotSessionBindingUpdateArgs<ExtArgs>>): Prisma__AIBotSessionBindingClient<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIBotSessionBindings.
     * @param {AIBotSessionBindingDeleteManyArgs} args - Arguments to filter AIBotSessionBindings to delete.
     * @example
     * // Delete a few AIBotSessionBindings
     * const { count } = await prisma.aIBotSessionBinding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIBotSessionBindingDeleteManyArgs>(args?: SelectSubset<T, AIBotSessionBindingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIBotSessionBindings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIBotSessionBindingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIBotSessionBindings
     * const aIBotSessionBinding = await prisma.aIBotSessionBinding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIBotSessionBindingUpdateManyArgs>(args: SelectSubset<T, AIBotSessionBindingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIBotSessionBindings and returns the data updated in the database.
     * @param {AIBotSessionBindingUpdateManyAndReturnArgs} args - Arguments to update many AIBotSessionBindings.
     * @example
     * // Update many AIBotSessionBindings
     * const aIBotSessionBinding = await prisma.aIBotSessionBinding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIBotSessionBindings and only return the `id`
     * const aIBotSessionBindingWithIdOnly = await prisma.aIBotSessionBinding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIBotSessionBindingUpdateManyAndReturnArgs>(args: SelectSubset<T, AIBotSessionBindingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIBotSessionBinding.
     * @param {AIBotSessionBindingUpsertArgs} args - Arguments to update or create a AIBotSessionBinding.
     * @example
     * // Update or create a AIBotSessionBinding
     * const aIBotSessionBinding = await prisma.aIBotSessionBinding.upsert({
     *   create: {
     *     // ... data to create a AIBotSessionBinding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIBotSessionBinding we want to update
     *   }
     * })
     */
    upsert<T extends AIBotSessionBindingUpsertArgs>(args: SelectSubset<T, AIBotSessionBindingUpsertArgs<ExtArgs>>): Prisma__AIBotSessionBindingClient<$Result.GetResult<Prisma.$AIBotSessionBindingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIBotSessionBindings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIBotSessionBindingCountArgs} args - Arguments to filter AIBotSessionBindings to count.
     * @example
     * // Count the number of AIBotSessionBindings
     * const count = await prisma.aIBotSessionBinding.count({
     *   where: {
     *     // ... the filter for the AIBotSessionBindings we want to count
     *   }
     * })
    **/
    count<T extends AIBotSessionBindingCountArgs>(
      args?: Subset<T, AIBotSessionBindingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIBotSessionBindingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIBotSessionBinding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIBotSessionBindingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIBotSessionBindingAggregateArgs>(args: Subset<T, AIBotSessionBindingAggregateArgs>): Prisma.PrismaPromise<GetAIBotSessionBindingAggregateType<T>>

    /**
     * Group by AIBotSessionBinding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIBotSessionBindingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIBotSessionBindingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIBotSessionBindingGroupByArgs['orderBy'] }
        : { orderBy?: AIBotSessionBindingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIBotSessionBindingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIBotSessionBindingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIBotSessionBinding model
   */
  readonly fields: AIBotSessionBindingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIBotSessionBinding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIBotSessionBindingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends WhatsAppAIBotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppAIBotDefaultArgs<ExtArgs>>): Prisma__WhatsAppAIBotClient<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends WhatsAppSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppSessionDefaultArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIBotSessionBinding model
   */
  interface AIBotSessionBindingFieldRefs {
    readonly id: FieldRef<"AIBotSessionBinding", 'String'>
    readonly userId: FieldRef<"AIBotSessionBinding", 'String'>
    readonly botId: FieldRef<"AIBotSessionBinding", 'String'>
    readonly sessionId: FieldRef<"AIBotSessionBinding", 'String'>
    readonly isActive: FieldRef<"AIBotSessionBinding", 'Boolean'>
    readonly createdAt: FieldRef<"AIBotSessionBinding", 'DateTime'>
    readonly updatedAt: FieldRef<"AIBotSessionBinding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIBotSessionBinding findUnique
   */
  export type AIBotSessionBindingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    /**
     * Filter, which AIBotSessionBinding to fetch.
     */
    where: AIBotSessionBindingWhereUniqueInput
  }

  /**
   * AIBotSessionBinding findUniqueOrThrow
   */
  export type AIBotSessionBindingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    /**
     * Filter, which AIBotSessionBinding to fetch.
     */
    where: AIBotSessionBindingWhereUniqueInput
  }

  /**
   * AIBotSessionBinding findFirst
   */
  export type AIBotSessionBindingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    /**
     * Filter, which AIBotSessionBinding to fetch.
     */
    where?: AIBotSessionBindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIBotSessionBindings to fetch.
     */
    orderBy?: AIBotSessionBindingOrderByWithRelationInput | AIBotSessionBindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIBotSessionBindings.
     */
    cursor?: AIBotSessionBindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIBotSessionBindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIBotSessionBindings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIBotSessionBindings.
     */
    distinct?: AIBotSessionBindingScalarFieldEnum | AIBotSessionBindingScalarFieldEnum[]
  }

  /**
   * AIBotSessionBinding findFirstOrThrow
   */
  export type AIBotSessionBindingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    /**
     * Filter, which AIBotSessionBinding to fetch.
     */
    where?: AIBotSessionBindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIBotSessionBindings to fetch.
     */
    orderBy?: AIBotSessionBindingOrderByWithRelationInput | AIBotSessionBindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIBotSessionBindings.
     */
    cursor?: AIBotSessionBindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIBotSessionBindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIBotSessionBindings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIBotSessionBindings.
     */
    distinct?: AIBotSessionBindingScalarFieldEnum | AIBotSessionBindingScalarFieldEnum[]
  }

  /**
   * AIBotSessionBinding findMany
   */
  export type AIBotSessionBindingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    /**
     * Filter, which AIBotSessionBindings to fetch.
     */
    where?: AIBotSessionBindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIBotSessionBindings to fetch.
     */
    orderBy?: AIBotSessionBindingOrderByWithRelationInput | AIBotSessionBindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIBotSessionBindings.
     */
    cursor?: AIBotSessionBindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIBotSessionBindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIBotSessionBindings.
     */
    skip?: number
    distinct?: AIBotSessionBindingScalarFieldEnum | AIBotSessionBindingScalarFieldEnum[]
  }

  /**
   * AIBotSessionBinding create
   */
  export type AIBotSessionBindingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    /**
     * The data needed to create a AIBotSessionBinding.
     */
    data: XOR<AIBotSessionBindingCreateInput, AIBotSessionBindingUncheckedCreateInput>
  }

  /**
   * AIBotSessionBinding createMany
   */
  export type AIBotSessionBindingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIBotSessionBindings.
     */
    data: AIBotSessionBindingCreateManyInput | AIBotSessionBindingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIBotSessionBinding createManyAndReturn
   */
  export type AIBotSessionBindingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * The data used to create many AIBotSessionBindings.
     */
    data: AIBotSessionBindingCreateManyInput | AIBotSessionBindingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIBotSessionBinding update
   */
  export type AIBotSessionBindingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    /**
     * The data needed to update a AIBotSessionBinding.
     */
    data: XOR<AIBotSessionBindingUpdateInput, AIBotSessionBindingUncheckedUpdateInput>
    /**
     * Choose, which AIBotSessionBinding to update.
     */
    where: AIBotSessionBindingWhereUniqueInput
  }

  /**
   * AIBotSessionBinding updateMany
   */
  export type AIBotSessionBindingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIBotSessionBindings.
     */
    data: XOR<AIBotSessionBindingUpdateManyMutationInput, AIBotSessionBindingUncheckedUpdateManyInput>
    /**
     * Filter which AIBotSessionBindings to update
     */
    where?: AIBotSessionBindingWhereInput
    /**
     * Limit how many AIBotSessionBindings to update.
     */
    limit?: number
  }

  /**
   * AIBotSessionBinding updateManyAndReturn
   */
  export type AIBotSessionBindingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * The data used to update AIBotSessionBindings.
     */
    data: XOR<AIBotSessionBindingUpdateManyMutationInput, AIBotSessionBindingUncheckedUpdateManyInput>
    /**
     * Filter which AIBotSessionBindings to update
     */
    where?: AIBotSessionBindingWhereInput
    /**
     * Limit how many AIBotSessionBindings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIBotSessionBinding upsert
   */
  export type AIBotSessionBindingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    /**
     * The filter to search for the AIBotSessionBinding to update in case it exists.
     */
    where: AIBotSessionBindingWhereUniqueInput
    /**
     * In case the AIBotSessionBinding found by the `where` argument doesn't exist, create a new AIBotSessionBinding with this data.
     */
    create: XOR<AIBotSessionBindingCreateInput, AIBotSessionBindingUncheckedCreateInput>
    /**
     * In case the AIBotSessionBinding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIBotSessionBindingUpdateInput, AIBotSessionBindingUncheckedUpdateInput>
  }

  /**
   * AIBotSessionBinding delete
   */
  export type AIBotSessionBindingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
    /**
     * Filter which AIBotSessionBinding to delete.
     */
    where: AIBotSessionBindingWhereUniqueInput
  }

  /**
   * AIBotSessionBinding deleteMany
   */
  export type AIBotSessionBindingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIBotSessionBindings to delete
     */
    where?: AIBotSessionBindingWhereInput
    /**
     * Limit how many AIBotSessionBindings to delete.
     */
    limit?: number
  }

  /**
   * AIBotSessionBinding without action
   */
  export type AIBotSessionBindingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIBotSessionBinding
     */
    select?: AIBotSessionBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIBotSessionBinding
     */
    omit?: AIBotSessionBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIBotSessionBindingInclude<ExtArgs> | null
  }


  /**
   * Model BotKnowledgeBinding
   */

  export type AggregateBotKnowledgeBinding = {
    _count: BotKnowledgeBindingCountAggregateOutputType | null
    _min: BotKnowledgeBindingMinAggregateOutputType | null
    _max: BotKnowledgeBindingMaxAggregateOutputType | null
  }

  export type BotKnowledgeBindingMinAggregateOutputType = {
    id: string | null
    botId: string | null
    documentId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotKnowledgeBindingMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    documentId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotKnowledgeBindingCountAggregateOutputType = {
    id: number
    botId: number
    documentId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BotKnowledgeBindingMinAggregateInputType = {
    id?: true
    botId?: true
    documentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotKnowledgeBindingMaxAggregateInputType = {
    id?: true
    botId?: true
    documentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotKnowledgeBindingCountAggregateInputType = {
    id?: true
    botId?: true
    documentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BotKnowledgeBindingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotKnowledgeBinding to aggregate.
     */
    where?: BotKnowledgeBindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotKnowledgeBindings to fetch.
     */
    orderBy?: BotKnowledgeBindingOrderByWithRelationInput | BotKnowledgeBindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotKnowledgeBindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotKnowledgeBindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotKnowledgeBindings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotKnowledgeBindings
    **/
    _count?: true | BotKnowledgeBindingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotKnowledgeBindingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotKnowledgeBindingMaxAggregateInputType
  }

  export type GetBotKnowledgeBindingAggregateType<T extends BotKnowledgeBindingAggregateArgs> = {
        [P in keyof T & keyof AggregateBotKnowledgeBinding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotKnowledgeBinding[P]>
      : GetScalarType<T[P], AggregateBotKnowledgeBinding[P]>
  }




  export type BotKnowledgeBindingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotKnowledgeBindingWhereInput
    orderBy?: BotKnowledgeBindingOrderByWithAggregationInput | BotKnowledgeBindingOrderByWithAggregationInput[]
    by: BotKnowledgeBindingScalarFieldEnum[] | BotKnowledgeBindingScalarFieldEnum
    having?: BotKnowledgeBindingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotKnowledgeBindingCountAggregateInputType | true
    _min?: BotKnowledgeBindingMinAggregateInputType
    _max?: BotKnowledgeBindingMaxAggregateInputType
  }

  export type BotKnowledgeBindingGroupByOutputType = {
    id: string
    botId: string
    documentId: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BotKnowledgeBindingCountAggregateOutputType | null
    _min: BotKnowledgeBindingMinAggregateOutputType | null
    _max: BotKnowledgeBindingMaxAggregateOutputType | null
  }

  type GetBotKnowledgeBindingGroupByPayload<T extends BotKnowledgeBindingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotKnowledgeBindingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotKnowledgeBindingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotKnowledgeBindingGroupByOutputType[P]>
            : GetScalarType<T[P], BotKnowledgeBindingGroupByOutputType[P]>
        }
      >
    >


  export type BotKnowledgeBindingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    documentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    document?: boolean | AIDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botKnowledgeBinding"]>

  export type BotKnowledgeBindingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    documentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    document?: boolean | AIDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botKnowledgeBinding"]>

  export type BotKnowledgeBindingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    documentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    document?: boolean | AIDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botKnowledgeBinding"]>

  export type BotKnowledgeBindingSelectScalar = {
    id?: boolean
    botId?: boolean
    documentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BotKnowledgeBindingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "documentId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["botKnowledgeBinding"]>
  export type BotKnowledgeBindingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    document?: boolean | AIDocumentDefaultArgs<ExtArgs>
  }
  export type BotKnowledgeBindingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    document?: boolean | AIDocumentDefaultArgs<ExtArgs>
  }
  export type BotKnowledgeBindingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | WhatsAppAIBotDefaultArgs<ExtArgs>
    document?: boolean | AIDocumentDefaultArgs<ExtArgs>
  }

  export type $BotKnowledgeBindingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotKnowledgeBinding"
    objects: {
      bot: Prisma.$WhatsAppAIBotPayload<ExtArgs>
      document: Prisma.$AIDocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botId: string
      documentId: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["botKnowledgeBinding"]>
    composites: {}
  }

  type BotKnowledgeBindingGetPayload<S extends boolean | null | undefined | BotKnowledgeBindingDefaultArgs> = $Result.GetResult<Prisma.$BotKnowledgeBindingPayload, S>

  type BotKnowledgeBindingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotKnowledgeBindingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotKnowledgeBindingCountAggregateInputType | true
    }

  export interface BotKnowledgeBindingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotKnowledgeBinding'], meta: { name: 'BotKnowledgeBinding' } }
    /**
     * Find zero or one BotKnowledgeBinding that matches the filter.
     * @param {BotKnowledgeBindingFindUniqueArgs} args - Arguments to find a BotKnowledgeBinding
     * @example
     * // Get one BotKnowledgeBinding
     * const botKnowledgeBinding = await prisma.botKnowledgeBinding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotKnowledgeBindingFindUniqueArgs>(args: SelectSubset<T, BotKnowledgeBindingFindUniqueArgs<ExtArgs>>): Prisma__BotKnowledgeBindingClient<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BotKnowledgeBinding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotKnowledgeBindingFindUniqueOrThrowArgs} args - Arguments to find a BotKnowledgeBinding
     * @example
     * // Get one BotKnowledgeBinding
     * const botKnowledgeBinding = await prisma.botKnowledgeBinding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotKnowledgeBindingFindUniqueOrThrowArgs>(args: SelectSubset<T, BotKnowledgeBindingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotKnowledgeBindingClient<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotKnowledgeBinding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotKnowledgeBindingFindFirstArgs} args - Arguments to find a BotKnowledgeBinding
     * @example
     * // Get one BotKnowledgeBinding
     * const botKnowledgeBinding = await prisma.botKnowledgeBinding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotKnowledgeBindingFindFirstArgs>(args?: SelectSubset<T, BotKnowledgeBindingFindFirstArgs<ExtArgs>>): Prisma__BotKnowledgeBindingClient<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotKnowledgeBinding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotKnowledgeBindingFindFirstOrThrowArgs} args - Arguments to find a BotKnowledgeBinding
     * @example
     * // Get one BotKnowledgeBinding
     * const botKnowledgeBinding = await prisma.botKnowledgeBinding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotKnowledgeBindingFindFirstOrThrowArgs>(args?: SelectSubset<T, BotKnowledgeBindingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotKnowledgeBindingClient<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BotKnowledgeBindings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotKnowledgeBindingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotKnowledgeBindings
     * const botKnowledgeBindings = await prisma.botKnowledgeBinding.findMany()
     * 
     * // Get first 10 BotKnowledgeBindings
     * const botKnowledgeBindings = await prisma.botKnowledgeBinding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botKnowledgeBindingWithIdOnly = await prisma.botKnowledgeBinding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotKnowledgeBindingFindManyArgs>(args?: SelectSubset<T, BotKnowledgeBindingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BotKnowledgeBinding.
     * @param {BotKnowledgeBindingCreateArgs} args - Arguments to create a BotKnowledgeBinding.
     * @example
     * // Create one BotKnowledgeBinding
     * const BotKnowledgeBinding = await prisma.botKnowledgeBinding.create({
     *   data: {
     *     // ... data to create a BotKnowledgeBinding
     *   }
     * })
     * 
     */
    create<T extends BotKnowledgeBindingCreateArgs>(args: SelectSubset<T, BotKnowledgeBindingCreateArgs<ExtArgs>>): Prisma__BotKnowledgeBindingClient<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BotKnowledgeBindings.
     * @param {BotKnowledgeBindingCreateManyArgs} args - Arguments to create many BotKnowledgeBindings.
     * @example
     * // Create many BotKnowledgeBindings
     * const botKnowledgeBinding = await prisma.botKnowledgeBinding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotKnowledgeBindingCreateManyArgs>(args?: SelectSubset<T, BotKnowledgeBindingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BotKnowledgeBindings and returns the data saved in the database.
     * @param {BotKnowledgeBindingCreateManyAndReturnArgs} args - Arguments to create many BotKnowledgeBindings.
     * @example
     * // Create many BotKnowledgeBindings
     * const botKnowledgeBinding = await prisma.botKnowledgeBinding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BotKnowledgeBindings and only return the `id`
     * const botKnowledgeBindingWithIdOnly = await prisma.botKnowledgeBinding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotKnowledgeBindingCreateManyAndReturnArgs>(args?: SelectSubset<T, BotKnowledgeBindingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BotKnowledgeBinding.
     * @param {BotKnowledgeBindingDeleteArgs} args - Arguments to delete one BotKnowledgeBinding.
     * @example
     * // Delete one BotKnowledgeBinding
     * const BotKnowledgeBinding = await prisma.botKnowledgeBinding.delete({
     *   where: {
     *     // ... filter to delete one BotKnowledgeBinding
     *   }
     * })
     * 
     */
    delete<T extends BotKnowledgeBindingDeleteArgs>(args: SelectSubset<T, BotKnowledgeBindingDeleteArgs<ExtArgs>>): Prisma__BotKnowledgeBindingClient<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BotKnowledgeBinding.
     * @param {BotKnowledgeBindingUpdateArgs} args - Arguments to update one BotKnowledgeBinding.
     * @example
     * // Update one BotKnowledgeBinding
     * const botKnowledgeBinding = await prisma.botKnowledgeBinding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotKnowledgeBindingUpdateArgs>(args: SelectSubset<T, BotKnowledgeBindingUpdateArgs<ExtArgs>>): Prisma__BotKnowledgeBindingClient<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BotKnowledgeBindings.
     * @param {BotKnowledgeBindingDeleteManyArgs} args - Arguments to filter BotKnowledgeBindings to delete.
     * @example
     * // Delete a few BotKnowledgeBindings
     * const { count } = await prisma.botKnowledgeBinding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotKnowledgeBindingDeleteManyArgs>(args?: SelectSubset<T, BotKnowledgeBindingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotKnowledgeBindings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotKnowledgeBindingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotKnowledgeBindings
     * const botKnowledgeBinding = await prisma.botKnowledgeBinding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotKnowledgeBindingUpdateManyArgs>(args: SelectSubset<T, BotKnowledgeBindingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotKnowledgeBindings and returns the data updated in the database.
     * @param {BotKnowledgeBindingUpdateManyAndReturnArgs} args - Arguments to update many BotKnowledgeBindings.
     * @example
     * // Update many BotKnowledgeBindings
     * const botKnowledgeBinding = await prisma.botKnowledgeBinding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BotKnowledgeBindings and only return the `id`
     * const botKnowledgeBindingWithIdOnly = await prisma.botKnowledgeBinding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotKnowledgeBindingUpdateManyAndReturnArgs>(args: SelectSubset<T, BotKnowledgeBindingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BotKnowledgeBinding.
     * @param {BotKnowledgeBindingUpsertArgs} args - Arguments to update or create a BotKnowledgeBinding.
     * @example
     * // Update or create a BotKnowledgeBinding
     * const botKnowledgeBinding = await prisma.botKnowledgeBinding.upsert({
     *   create: {
     *     // ... data to create a BotKnowledgeBinding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotKnowledgeBinding we want to update
     *   }
     * })
     */
    upsert<T extends BotKnowledgeBindingUpsertArgs>(args: SelectSubset<T, BotKnowledgeBindingUpsertArgs<ExtArgs>>): Prisma__BotKnowledgeBindingClient<$Result.GetResult<Prisma.$BotKnowledgeBindingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BotKnowledgeBindings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotKnowledgeBindingCountArgs} args - Arguments to filter BotKnowledgeBindings to count.
     * @example
     * // Count the number of BotKnowledgeBindings
     * const count = await prisma.botKnowledgeBinding.count({
     *   where: {
     *     // ... the filter for the BotKnowledgeBindings we want to count
     *   }
     * })
    **/
    count<T extends BotKnowledgeBindingCountArgs>(
      args?: Subset<T, BotKnowledgeBindingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotKnowledgeBindingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotKnowledgeBinding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotKnowledgeBindingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotKnowledgeBindingAggregateArgs>(args: Subset<T, BotKnowledgeBindingAggregateArgs>): Prisma.PrismaPromise<GetBotKnowledgeBindingAggregateType<T>>

    /**
     * Group by BotKnowledgeBinding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotKnowledgeBindingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotKnowledgeBindingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotKnowledgeBindingGroupByArgs['orderBy'] }
        : { orderBy?: BotKnowledgeBindingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotKnowledgeBindingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotKnowledgeBindingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotKnowledgeBinding model
   */
  readonly fields: BotKnowledgeBindingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotKnowledgeBinding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotKnowledgeBindingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends WhatsAppAIBotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppAIBotDefaultArgs<ExtArgs>>): Prisma__WhatsAppAIBotClient<$Result.GetResult<Prisma.$WhatsAppAIBotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    document<T extends AIDocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIDocumentDefaultArgs<ExtArgs>>): Prisma__AIDocumentClient<$Result.GetResult<Prisma.$AIDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BotKnowledgeBinding model
   */
  interface BotKnowledgeBindingFieldRefs {
    readonly id: FieldRef<"BotKnowledgeBinding", 'String'>
    readonly botId: FieldRef<"BotKnowledgeBinding", 'String'>
    readonly documentId: FieldRef<"BotKnowledgeBinding", 'String'>
    readonly isActive: FieldRef<"BotKnowledgeBinding", 'Boolean'>
    readonly createdAt: FieldRef<"BotKnowledgeBinding", 'DateTime'>
    readonly updatedAt: FieldRef<"BotKnowledgeBinding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BotKnowledgeBinding findUnique
   */
  export type BotKnowledgeBindingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    /**
     * Filter, which BotKnowledgeBinding to fetch.
     */
    where: BotKnowledgeBindingWhereUniqueInput
  }

  /**
   * BotKnowledgeBinding findUniqueOrThrow
   */
  export type BotKnowledgeBindingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    /**
     * Filter, which BotKnowledgeBinding to fetch.
     */
    where: BotKnowledgeBindingWhereUniqueInput
  }

  /**
   * BotKnowledgeBinding findFirst
   */
  export type BotKnowledgeBindingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    /**
     * Filter, which BotKnowledgeBinding to fetch.
     */
    where?: BotKnowledgeBindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotKnowledgeBindings to fetch.
     */
    orderBy?: BotKnowledgeBindingOrderByWithRelationInput | BotKnowledgeBindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotKnowledgeBindings.
     */
    cursor?: BotKnowledgeBindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotKnowledgeBindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotKnowledgeBindings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotKnowledgeBindings.
     */
    distinct?: BotKnowledgeBindingScalarFieldEnum | BotKnowledgeBindingScalarFieldEnum[]
  }

  /**
   * BotKnowledgeBinding findFirstOrThrow
   */
  export type BotKnowledgeBindingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    /**
     * Filter, which BotKnowledgeBinding to fetch.
     */
    where?: BotKnowledgeBindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotKnowledgeBindings to fetch.
     */
    orderBy?: BotKnowledgeBindingOrderByWithRelationInput | BotKnowledgeBindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotKnowledgeBindings.
     */
    cursor?: BotKnowledgeBindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotKnowledgeBindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotKnowledgeBindings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotKnowledgeBindings.
     */
    distinct?: BotKnowledgeBindingScalarFieldEnum | BotKnowledgeBindingScalarFieldEnum[]
  }

  /**
   * BotKnowledgeBinding findMany
   */
  export type BotKnowledgeBindingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    /**
     * Filter, which BotKnowledgeBindings to fetch.
     */
    where?: BotKnowledgeBindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotKnowledgeBindings to fetch.
     */
    orderBy?: BotKnowledgeBindingOrderByWithRelationInput | BotKnowledgeBindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotKnowledgeBindings.
     */
    cursor?: BotKnowledgeBindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BotKnowledgeBindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotKnowledgeBindings.
     */
    skip?: number
    distinct?: BotKnowledgeBindingScalarFieldEnum | BotKnowledgeBindingScalarFieldEnum[]
  }

  /**
   * BotKnowledgeBinding create
   */
  export type BotKnowledgeBindingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    /**
     * The data needed to create a BotKnowledgeBinding.
     */
    data: XOR<BotKnowledgeBindingCreateInput, BotKnowledgeBindingUncheckedCreateInput>
  }

  /**
   * BotKnowledgeBinding createMany
   */
  export type BotKnowledgeBindingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotKnowledgeBindings.
     */
    data: BotKnowledgeBindingCreateManyInput | BotKnowledgeBindingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BotKnowledgeBinding createManyAndReturn
   */
  export type BotKnowledgeBindingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * The data used to create many BotKnowledgeBindings.
     */
    data: BotKnowledgeBindingCreateManyInput | BotKnowledgeBindingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotKnowledgeBinding update
   */
  export type BotKnowledgeBindingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    /**
     * The data needed to update a BotKnowledgeBinding.
     */
    data: XOR<BotKnowledgeBindingUpdateInput, BotKnowledgeBindingUncheckedUpdateInput>
    /**
     * Choose, which BotKnowledgeBinding to update.
     */
    where: BotKnowledgeBindingWhereUniqueInput
  }

  /**
   * BotKnowledgeBinding updateMany
   */
  export type BotKnowledgeBindingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotKnowledgeBindings.
     */
    data: XOR<BotKnowledgeBindingUpdateManyMutationInput, BotKnowledgeBindingUncheckedUpdateManyInput>
    /**
     * Filter which BotKnowledgeBindings to update
     */
    where?: BotKnowledgeBindingWhereInput
    /**
     * Limit how many BotKnowledgeBindings to update.
     */
    limit?: number
  }

  /**
   * BotKnowledgeBinding updateManyAndReturn
   */
  export type BotKnowledgeBindingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * The data used to update BotKnowledgeBindings.
     */
    data: XOR<BotKnowledgeBindingUpdateManyMutationInput, BotKnowledgeBindingUncheckedUpdateManyInput>
    /**
     * Filter which BotKnowledgeBindings to update
     */
    where?: BotKnowledgeBindingWhereInput
    /**
     * Limit how many BotKnowledgeBindings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotKnowledgeBinding upsert
   */
  export type BotKnowledgeBindingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    /**
     * The filter to search for the BotKnowledgeBinding to update in case it exists.
     */
    where: BotKnowledgeBindingWhereUniqueInput
    /**
     * In case the BotKnowledgeBinding found by the `where` argument doesn't exist, create a new BotKnowledgeBinding with this data.
     */
    create: XOR<BotKnowledgeBindingCreateInput, BotKnowledgeBindingUncheckedCreateInput>
    /**
     * In case the BotKnowledgeBinding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotKnowledgeBindingUpdateInput, BotKnowledgeBindingUncheckedUpdateInput>
  }

  /**
   * BotKnowledgeBinding delete
   */
  export type BotKnowledgeBindingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
    /**
     * Filter which BotKnowledgeBinding to delete.
     */
    where: BotKnowledgeBindingWhereUniqueInput
  }

  /**
   * BotKnowledgeBinding deleteMany
   */
  export type BotKnowledgeBindingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotKnowledgeBindings to delete
     */
    where?: BotKnowledgeBindingWhereInput
    /**
     * Limit how many BotKnowledgeBindings to delete.
     */
    limit?: number
  }

  /**
   * BotKnowledgeBinding without action
   */
  export type BotKnowledgeBindingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotKnowledgeBinding
     */
    select?: BotKnowledgeBindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotKnowledgeBinding
     */
    omit?: BotKnowledgeBindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotKnowledgeBindingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    otp: 'otp',
    otpExpires: 'otpExpires',
    otpVerificationDeadline: 'otpVerificationDeadline',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    image: 'image',
    emailVerificationToken: 'emailVerificationToken',
    emailVerificationTokenExpires: 'emailVerificationTokenExpires',
    role: 'role',
    apiKey: 'apiKey',
    updatedAt: 'updatedAt',
    emailOtp: 'emailOtp',
    emailOtpExpires: 'emailOtpExpires',
    resetPasswordOtp: 'resetPasswordOtp',
    resetPasswordOtpExpires: 'resetPasswordOtpExpires',
    resetPasswordLastRequestAt: 'resetPasswordLastRequestAt',
    ssoOtp: 'ssoOtp',
    ssoOtpExpires: 'ssoOtpExpires',
    ssoLastRequestAt: 'ssoLastRequestAt',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WhatsAppSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    message: 'message',
    sessionName: 'sessionName',
    connected: 'connected',
    events: 'events',
    expiration: 'expiration',
    isSystemSession: 'isSystemSession',
    jid: 'jid',
    loggedIn: 'loggedIn',
    proxyEnabled: 'proxyEnabled',
    proxyUrl: 'proxyUrl',
    qrcode: 'qrcode',
    s3AccessKey: 's3AccessKey',
    s3Bucket: 's3Bucket',
    s3Enabled: 's3Enabled',
    s3Endpoint: 's3Endpoint',
    s3MediaDelivery: 's3MediaDelivery',
    s3PathStyle: 's3PathStyle',
    s3PublicUrl: 's3PublicUrl',
    s3Region: 's3Region',
    s3RetentionDays: 's3RetentionDays',
    s3SecretKey: 's3SecretKey',
    token: 'token',
    webhook: 'webhook',
    autoReadMessages: 'autoReadMessages',
    typingIndicator: 'typingIndicator'
  };

  export type WhatsAppSessionScalarFieldEnum = (typeof WhatsAppSessionScalarFieldEnum)[keyof typeof WhatsAppSessionScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    transactionDate: 'transactionDate',
    status: 'status',
    amount: 'amount',
    createdAt: 'createdAt',
    type: 'type',
    updatedAt: 'updatedAt',
    discountAmount: 'discountAmount',
    originalAmount: 'originalAmount',
    voucherId: 'voucherId',
    notes: 'notes',
    currency: 'currency',
    finalAmount: 'finalAmount',
    serviceFeeAmount: 'serviceFeeAmount',
    totalAfterDiscount: 'totalAfterDiscount',
    expiresAt: 'expiresAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TransactionWhatsappServiceScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    whatsappPackageId: 'whatsappPackageId',
    duration: 'duration',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type TransactionWhatsappServiceScalarFieldEnum = (typeof TransactionWhatsappServiceScalarFieldEnum)[keyof typeof TransactionWhatsappServiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    amount: 'amount',
    method: 'method',
    status: 'status',
    paymentDate: 'paymentDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt',
    externalId: 'externalId',
    paymentUrl: 'paymentUrl',
    serviceFee: 'serviceFee',
    adminNotes: 'adminNotes',
    adminAction: 'adminAction',
    adminUserId: 'adminUserId',
    actionDate: 'actionDate',
    gatewayProvider: 'gatewayProvider',
    gatewayResponse: 'gatewayResponse'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const WhatsappApiPackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    priceMonth: 'priceMonth',
    priceYear: 'priceYear',
    maxSession: 'maxSession',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsappApiPackageScalarFieldEnum = (typeof WhatsappApiPackageScalarFieldEnum)[keyof typeof WhatsappApiPackageScalarFieldEnum]


  export const ServicesWhatsappCustomersScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    packageId: 'packageId',
    status: 'status',
    expiredAt: 'expiredAt',
    activatedAt: 'activatedAt',
    updatedAt: 'updatedAt',
    lastSubscriptionAt: 'lastSubscriptionAt'
  };

  export type ServicesWhatsappCustomersScalarFieldEnum = (typeof ServicesWhatsappCustomersScalarFieldEnum)[keyof typeof ServicesWhatsappCustomersScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    userId: 'userId',
    token: 'token',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    isActive: 'isActive',
    lastUsed: 'lastUsed',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const VoucherScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    type: 'type',
    discountType: 'discountType',
    value: 'value',
    minAmount: 'minAmount',
    maxDiscount: 'maxDiscount',
    maxUses: 'maxUses',
    usedCount: 'usedCount',
    allowMultipleUsePerUser: 'allowMultipleUsePerUser',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


  export const VoucherUsageScalarFieldEnum: {
    id: 'id',
    voucherId: 'voucherId',
    userId: 'userId',
    transactionId: 'transactionId',
    usedAt: 'usedAt',
    discountAmount: 'discountAmount'
  };

  export type VoucherUsageScalarFieldEnum = (typeof VoucherUsageScalarFieldEnum)[keyof typeof VoucherUsageScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    type: 'type',
    isActive: 'isActive',
    isSystem: 'isSystem',
    gatewayProvider: 'gatewayProvider',
    gatewayCode: 'gatewayCode',
    gatewayImageUrl: 'gatewayImageUrl',
    isGatewayMethod: 'isGatewayMethod',
    bankDetailId: 'bankDetailId',
    feeType: 'feeType',
    feeValue: 'feeValue',
    minFee: 'minFee',
    maxFee: 'maxFee',
    requiresManualApproval: 'requiresManualApproval',
    paymentInstructions: 'paymentInstructions',
    instructionType: 'instructionType',
    instructionImageUrl: 'instructionImageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const BankDetailScalarFieldEnum: {
    id: 'id',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    accountName: 'accountName',
    swiftCode: 'swiftCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankDetailScalarFieldEnum = (typeof BankDetailScalarFieldEnum)[keyof typeof BankDetailScalarFieldEnum]


  export const WhatsAppCampaignScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    type: 'type',
    status: 'status',
    message_body: 'message_body',
    image_url: 'image_url',
    image_base64: 'image_base64',
    caption: 'caption',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type WhatsAppCampaignScalarFieldEnum = (typeof WhatsAppCampaignScalarFieldEnum)[keyof typeof WhatsAppCampaignScalarFieldEnum]


  export const WhatsAppBulkCampaignScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    campaign_id: 'campaign_id',
    name: 'name',
    type: 'type',
    message_body: 'message_body',
    image_url: 'image_url',
    image_base64: 'image_base64',
    caption: 'caption',
    status: 'status',
    total_count: 'total_count',
    sent_count: 'sent_count',
    failed_count: 'failed_count',
    scheduled_at: 'scheduled_at',
    timezone: 'timezone',
    processed_at: 'processed_at',
    completed_at: 'completed_at',
    error_message: 'error_message',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type WhatsAppBulkCampaignScalarFieldEnum = (typeof WhatsAppBulkCampaignScalarFieldEnum)[keyof typeof WhatsAppBulkCampaignScalarFieldEnum]


  export const WhatsAppBulkCampaignItemScalarFieldEnum: {
    id: 'id',
    bulk_campaign_id: 'bulk_campaign_id',
    phone: 'phone',
    status: 'status',
    message_id: 'message_id',
    error_message: 'error_message',
    sent_at: 'sent_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type WhatsAppBulkCampaignItemScalarFieldEnum = (typeof WhatsAppBulkCampaignItemScalarFieldEnum)[keyof typeof WhatsAppBulkCampaignItemScalarFieldEnum]


  export const WhatsAppContactScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    phone: 'phone',
    name: 'name',
    full_name: 'full_name',
    push_name: 'push_name',
    short: 'short',
    notify: 'notify',
    business: 'business',
    verified: 'verified',
    source: 'source',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type WhatsAppContactScalarFieldEnum = (typeof WhatsAppContactScalarFieldEnum)[keyof typeof WhatsAppContactScalarFieldEnum]


  export const WhatsAppMessageStatsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionId: 'sessionId',
    totalMessagesSent: 'totalMessagesSent',
    totalMessagesFailed: 'totalMessagesFailed',
    textMessagesSent: 'textMessagesSent',
    textMessagesFailed: 'textMessagesFailed',
    imageMessagesSent: 'imageMessagesSent',
    imageMessagesFailed: 'imageMessagesFailed',
    documentMessagesSent: 'documentMessagesSent',
    documentMessagesFailed: 'documentMessagesFailed',
    audioMessagesSent: 'audioMessagesSent',
    audioMessagesFailed: 'audioMessagesFailed',
    stickerMessagesSent: 'stickerMessagesSent',
    stickerMessagesFailed: 'stickerMessagesFailed',
    videoMessagesSent: 'videoMessagesSent',
    videoMessagesFailed: 'videoMessagesFailed',
    locationMessagesSent: 'locationMessagesSent',
    locationMessagesFailed: 'locationMessagesFailed',
    contactMessagesSent: 'contactMessagesSent',
    contactMessagesFailed: 'contactMessagesFailed',
    templateMessagesSent: 'templateMessagesSent',
    templateMessagesFailed: 'templateMessagesFailed',
    lastMessageSentAt: 'lastMessageSentAt',
    lastMessageFailedAt: 'lastMessageFailedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsAppMessageStatsScalarFieldEnum = (typeof WhatsAppMessageStatsScalarFieldEnum)[keyof typeof WhatsAppMessageStatsScalarFieldEnum]


  export const WhatsAppAIBotScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    isActive: 'isActive',
    systemPrompt: 'systemPrompt',
    fallbackText: 'fallbackText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsAppAIBotScalarFieldEnum = (typeof WhatsAppAIBotScalarFieldEnum)[keyof typeof WhatsAppAIBotScalarFieldEnum]


  export const AIDocumentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    kind: 'kind',
    content: 'content',
    embeddingId: 'embeddingId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIDocumentScalarFieldEnum = (typeof AIDocumentScalarFieldEnum)[keyof typeof AIDocumentScalarFieldEnum]


  export const AIUsageLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionId: 'sessionId',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    totalTokens: 'totalTokens',
    latencyMs: 'latencyMs',
    status: 'status',
    errorReason: 'errorReason',
    createdAt: 'createdAt'
  };

  export type AIUsageLogScalarFieldEnum = (typeof AIUsageLogScalarFieldEnum)[keyof typeof AIUsageLogScalarFieldEnum]


  export const AIBotSessionBindingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    botId: 'botId',
    sessionId: 'sessionId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIBotSessionBindingScalarFieldEnum = (typeof AIBotSessionBindingScalarFieldEnum)[keyof typeof AIBotSessionBindingScalarFieldEnum]


  export const BotKnowledgeBindingScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    documentId: 'documentId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BotKnowledgeBindingScalarFieldEnum = (typeof BotKnowledgeBindingScalarFieldEnum)[keyof typeof BotKnowledgeBindingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    otpVerificationDeadline?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    emailVerificationTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: StringFilter<"User"> | string
    apiKey?: StringNullableFilter<"User"> | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailOtp?: StringNullableFilter<"User"> | string | null
    emailOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordOtp?: StringNullableFilter<"User"> | string | null
    resetPasswordOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordLastRequestAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoOtp?: StringNullableFilter<"User"> | string | null
    ssoOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoLastRequestAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersListRelationFilter
    transactions?: TransactionListRelationFilter
    userSessions?: UserSessionListRelationFilter
    voucherUsage?: VoucherUsageListRelationFilter
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignListRelationFilter
    WhatsAppCampaigns?: WhatsAppCampaignListRelationFilter
    WhatsAppContact?: WhatsAppContactListRelationFilter
    whatsAppSessions?: WhatsAppSessionListRelationFilter
    whatsAppMessageStats?: WhatsAppMessageStatsListRelationFilter
    whatsAppAIBots?: WhatsAppAIBotListRelationFilter
    aiDocuments?: AIDocumentListRelationFilter
    aiUsageLogs?: AIUsageLogListRelationFilter
    aiBotSessionBindings?: AIBotSessionBindingListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    otpVerificationDeadline?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationTokenExpires?: SortOrderInput | SortOrder
    role?: SortOrder
    apiKey?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    emailOtp?: SortOrderInput | SortOrder
    emailOtpExpires?: SortOrderInput | SortOrder
    resetPasswordOtp?: SortOrderInput | SortOrder
    resetPasswordOtpExpires?: SortOrderInput | SortOrder
    resetPasswordLastRequestAt?: SortOrderInput | SortOrder
    ssoOtp?: SortOrderInput | SortOrder
    ssoOtpExpires?: SortOrderInput | SortOrder
    ssoLastRequestAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    whatsappCustomers?: ServicesWhatsappCustomersOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    userSessions?: UserSessionOrderByRelationAggregateInput
    voucherUsage?: VoucherUsageOrderByRelationAggregateInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignOrderByRelationAggregateInput
    WhatsAppCampaigns?: WhatsAppCampaignOrderByRelationAggregateInput
    WhatsAppContact?: WhatsAppContactOrderByRelationAggregateInput
    whatsAppSessions?: WhatsAppSessionOrderByRelationAggregateInput
    whatsAppMessageStats?: WhatsAppMessageStatsOrderByRelationAggregateInput
    whatsAppAIBots?: WhatsAppAIBotOrderByRelationAggregateInput
    aiDocuments?: AIDocumentOrderByRelationAggregateInput
    aiUsageLogs?: AIUsageLogOrderByRelationAggregateInput
    aiBotSessionBindings?: AIBotSessionBindingOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    emailVerificationToken?: string
    apiKey?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    otpVerificationDeadline?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    emailVerificationTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: StringFilter<"User"> | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailOtp?: StringNullableFilter<"User"> | string | null
    emailOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordOtp?: StringNullableFilter<"User"> | string | null
    resetPasswordOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordLastRequestAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoOtp?: StringNullableFilter<"User"> | string | null
    ssoOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoLastRequestAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersListRelationFilter
    transactions?: TransactionListRelationFilter
    userSessions?: UserSessionListRelationFilter
    voucherUsage?: VoucherUsageListRelationFilter
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignListRelationFilter
    WhatsAppCampaigns?: WhatsAppCampaignListRelationFilter
    WhatsAppContact?: WhatsAppContactListRelationFilter
    whatsAppSessions?: WhatsAppSessionListRelationFilter
    whatsAppMessageStats?: WhatsAppMessageStatsListRelationFilter
    whatsAppAIBots?: WhatsAppAIBotListRelationFilter
    aiDocuments?: AIDocumentListRelationFilter
    aiUsageLogs?: AIUsageLogListRelationFilter
    aiBotSessionBindings?: AIBotSessionBindingListRelationFilter
  }, "id" | "email" | "phone" | "emailVerificationToken" | "apiKey">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    otpVerificationDeadline?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationTokenExpires?: SortOrderInput | SortOrder
    role?: SortOrder
    apiKey?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    emailOtp?: SortOrderInput | SortOrder
    emailOtpExpires?: SortOrderInput | SortOrder
    resetPasswordOtp?: SortOrderInput | SortOrder
    resetPasswordOtpExpires?: SortOrderInput | SortOrder
    resetPasswordLastRequestAt?: SortOrderInput | SortOrder
    ssoOtp?: SortOrderInput | SortOrder
    ssoOtpExpires?: SortOrderInput | SortOrder
    ssoLastRequestAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    otp?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    otpVerificationDeadline?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationTokenExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    apiKey?: StringNullableWithAggregatesFilter<"User"> | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailOtp?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailOtpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetPasswordOtp?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetPasswordOtpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetPasswordLastRequestAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    ssoOtp?: StringNullableWithAggregatesFilter<"User"> | string | null
    ssoOtpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    ssoLastRequestAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type WhatsAppSessionWhereInput = {
    AND?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    OR?: WhatsAppSessionWhereInput[]
    NOT?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    id?: StringFilter<"WhatsAppSession"> | string
    sessionId?: StringFilter<"WhatsAppSession"> | string
    userId?: StringNullableFilter<"WhatsAppSession"> | string | null
    status?: StringFilter<"WhatsAppSession"> | string
    createdAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    message?: StringNullableFilter<"WhatsAppSession"> | string | null
    sessionName?: StringFilter<"WhatsAppSession"> | string
    connected?: BoolFilter<"WhatsAppSession"> | boolean
    events?: StringNullableFilter<"WhatsAppSession"> | string | null
    expiration?: IntFilter<"WhatsAppSession"> | number
    isSystemSession?: BoolFilter<"WhatsAppSession"> | boolean
    jid?: StringNullableFilter<"WhatsAppSession"> | string | null
    loggedIn?: BoolFilter<"WhatsAppSession"> | boolean
    proxyEnabled?: BoolFilter<"WhatsAppSession"> | boolean
    proxyUrl?: StringNullableFilter<"WhatsAppSession"> | string | null
    qrcode?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3AccessKey?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3Bucket?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3Enabled?: BoolFilter<"WhatsAppSession"> | boolean
    s3Endpoint?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3MediaDelivery?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3PathStyle?: BoolFilter<"WhatsAppSession"> | boolean
    s3PublicUrl?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3Region?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3RetentionDays?: IntFilter<"WhatsAppSession"> | number
    s3SecretKey?: StringNullableFilter<"WhatsAppSession"> | string | null
    token?: StringFilter<"WhatsAppSession"> | string
    webhook?: StringNullableFilter<"WhatsAppSession"> | string | null
    autoReadMessages?: BoolFilter<"WhatsAppSession"> | boolean
    typingIndicator?: BoolFilter<"WhatsAppSession"> | boolean
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    whatsAppMessageStats?: WhatsAppMessageStatsListRelationFilter
    aiBotSessionBindings?: AIBotSessionBindingListRelationFilter
  }

  export type WhatsAppSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    message?: SortOrderInput | SortOrder
    sessionName?: SortOrder
    connected?: SortOrder
    events?: SortOrderInput | SortOrder
    expiration?: SortOrder
    isSystemSession?: SortOrder
    jid?: SortOrderInput | SortOrder
    loggedIn?: SortOrder
    proxyEnabled?: SortOrder
    proxyUrl?: SortOrderInput | SortOrder
    qrcode?: SortOrderInput | SortOrder
    s3AccessKey?: SortOrderInput | SortOrder
    s3Bucket?: SortOrderInput | SortOrder
    s3Enabled?: SortOrder
    s3Endpoint?: SortOrderInput | SortOrder
    s3MediaDelivery?: SortOrderInput | SortOrder
    s3PathStyle?: SortOrder
    s3PublicUrl?: SortOrderInput | SortOrder
    s3Region?: SortOrderInput | SortOrder
    s3RetentionDays?: SortOrder
    s3SecretKey?: SortOrderInput | SortOrder
    token?: SortOrder
    webhook?: SortOrderInput | SortOrder
    autoReadMessages?: SortOrder
    typingIndicator?: SortOrder
    user?: UserOrderByWithRelationInput
    whatsAppMessageStats?: WhatsAppMessageStatsOrderByRelationAggregateInput
    aiBotSessionBindings?: AIBotSessionBindingOrderByRelationAggregateInput
  }

  export type WhatsAppSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    token?: string
    AND?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    OR?: WhatsAppSessionWhereInput[]
    NOT?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    userId?: StringNullableFilter<"WhatsAppSession"> | string | null
    status?: StringFilter<"WhatsAppSession"> | string
    createdAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    message?: StringNullableFilter<"WhatsAppSession"> | string | null
    sessionName?: StringFilter<"WhatsAppSession"> | string
    connected?: BoolFilter<"WhatsAppSession"> | boolean
    events?: StringNullableFilter<"WhatsAppSession"> | string | null
    expiration?: IntFilter<"WhatsAppSession"> | number
    isSystemSession?: BoolFilter<"WhatsAppSession"> | boolean
    jid?: StringNullableFilter<"WhatsAppSession"> | string | null
    loggedIn?: BoolFilter<"WhatsAppSession"> | boolean
    proxyEnabled?: BoolFilter<"WhatsAppSession"> | boolean
    proxyUrl?: StringNullableFilter<"WhatsAppSession"> | string | null
    qrcode?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3AccessKey?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3Bucket?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3Enabled?: BoolFilter<"WhatsAppSession"> | boolean
    s3Endpoint?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3MediaDelivery?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3PathStyle?: BoolFilter<"WhatsAppSession"> | boolean
    s3PublicUrl?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3Region?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3RetentionDays?: IntFilter<"WhatsAppSession"> | number
    s3SecretKey?: StringNullableFilter<"WhatsAppSession"> | string | null
    webhook?: StringNullableFilter<"WhatsAppSession"> | string | null
    autoReadMessages?: BoolFilter<"WhatsAppSession"> | boolean
    typingIndicator?: BoolFilter<"WhatsAppSession"> | boolean
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    whatsAppMessageStats?: WhatsAppMessageStatsListRelationFilter
    aiBotSessionBindings?: AIBotSessionBindingListRelationFilter
  }, "id" | "sessionId" | "token">

  export type WhatsAppSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    message?: SortOrderInput | SortOrder
    sessionName?: SortOrder
    connected?: SortOrder
    events?: SortOrderInput | SortOrder
    expiration?: SortOrder
    isSystemSession?: SortOrder
    jid?: SortOrderInput | SortOrder
    loggedIn?: SortOrder
    proxyEnabled?: SortOrder
    proxyUrl?: SortOrderInput | SortOrder
    qrcode?: SortOrderInput | SortOrder
    s3AccessKey?: SortOrderInput | SortOrder
    s3Bucket?: SortOrderInput | SortOrder
    s3Enabled?: SortOrder
    s3Endpoint?: SortOrderInput | SortOrder
    s3MediaDelivery?: SortOrderInput | SortOrder
    s3PathStyle?: SortOrder
    s3PublicUrl?: SortOrderInput | SortOrder
    s3Region?: SortOrderInput | SortOrder
    s3RetentionDays?: SortOrder
    s3SecretKey?: SortOrderInput | SortOrder
    token?: SortOrder
    webhook?: SortOrderInput | SortOrder
    autoReadMessages?: SortOrder
    typingIndicator?: SortOrder
    _count?: WhatsAppSessionCountOrderByAggregateInput
    _avg?: WhatsAppSessionAvgOrderByAggregateInput
    _max?: WhatsAppSessionMaxOrderByAggregateInput
    _min?: WhatsAppSessionMinOrderByAggregateInput
    _sum?: WhatsAppSessionSumOrderByAggregateInput
  }

  export type WhatsAppSessionScalarWhereWithAggregatesInput = {
    AND?: WhatsAppSessionScalarWhereWithAggregatesInput | WhatsAppSessionScalarWhereWithAggregatesInput[]
    OR?: WhatsAppSessionScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppSessionScalarWhereWithAggregatesInput | WhatsAppSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    sessionId?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    userId?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    status?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppSession"> | Date | string
    message?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    sessionName?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    connected?: BoolWithAggregatesFilter<"WhatsAppSession"> | boolean
    events?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    expiration?: IntWithAggregatesFilter<"WhatsAppSession"> | number
    isSystemSession?: BoolWithAggregatesFilter<"WhatsAppSession"> | boolean
    jid?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    loggedIn?: BoolWithAggregatesFilter<"WhatsAppSession"> | boolean
    proxyEnabled?: BoolWithAggregatesFilter<"WhatsAppSession"> | boolean
    proxyUrl?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    qrcode?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    s3AccessKey?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    s3Bucket?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    s3Enabled?: BoolWithAggregatesFilter<"WhatsAppSession"> | boolean
    s3Endpoint?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    s3MediaDelivery?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    s3PathStyle?: BoolWithAggregatesFilter<"WhatsAppSession"> | boolean
    s3PublicUrl?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    s3Region?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    s3RetentionDays?: IntWithAggregatesFilter<"WhatsAppSession"> | number
    s3SecretKey?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    token?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    webhook?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    autoReadMessages?: BoolWithAggregatesFilter<"WhatsAppSession"> | boolean
    typingIndicator?: BoolWithAggregatesFilter<"WhatsAppSession"> | boolean
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    status?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    discountAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    originalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    voucherId?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    currency?: StringFilter<"Transaction"> | string
    finalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    voucher?: XOR<VoucherNullableScalarRelationFilter, VoucherWhereInput> | null
    whatsappTransaction?: XOR<TransactionWhatsappServiceNullableScalarRelationFilter, TransactionWhatsappServiceWhereInput> | null
    voucherUsage?: VoucherUsageListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    discountAmount?: SortOrderInput | SortOrder
    originalAmount?: SortOrderInput | SortOrder
    voucherId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    currency?: SortOrder
    finalAmount?: SortOrderInput | SortOrder
    serviceFeeAmount?: SortOrderInput | SortOrder
    totalAfterDiscount?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    payment?: PaymentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    voucher?: VoucherOrderByWithRelationInput
    whatsappTransaction?: TransactionWhatsappServiceOrderByWithRelationInput
    voucherUsage?: VoucherUsageOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    status?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    discountAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    originalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    voucherId?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    currency?: StringFilter<"Transaction"> | string
    finalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    voucher?: XOR<VoucherNullableScalarRelationFilter, VoucherWhereInput> | null
    whatsappTransaction?: XOR<TransactionWhatsappServiceNullableScalarRelationFilter, TransactionWhatsappServiceWhereInput> | null
    voucherUsage?: VoucherUsageListRelationFilter
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    discountAmount?: SortOrderInput | SortOrder
    originalAmount?: SortOrderInput | SortOrder
    voucherId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    currency?: SortOrder
    finalAmount?: SortOrderInput | SortOrder
    serviceFeeAmount?: SortOrderInput | SortOrder
    totalAfterDiscount?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    transactionDate?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    type?: StringWithAggregatesFilter<"Transaction"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    discountAmount?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    originalAmount?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    voucherId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    finalAmount?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
  }

  export type TransactionWhatsappServiceWhereInput = {
    AND?: TransactionWhatsappServiceWhereInput | TransactionWhatsappServiceWhereInput[]
    OR?: TransactionWhatsappServiceWhereInput[]
    NOT?: TransactionWhatsappServiceWhereInput | TransactionWhatsappServiceWhereInput[]
    id?: StringFilter<"TransactionWhatsappService"> | string
    transactionId?: StringFilter<"TransactionWhatsappService"> | string
    whatsappPackageId?: StringFilter<"TransactionWhatsappService"> | string
    duration?: StringFilter<"TransactionWhatsappService"> | string
    status?: StringFilter<"TransactionWhatsappService"> | string
    startDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    whatsappPackage?: XOR<WhatsappApiPackageScalarRelationFilter, WhatsappApiPackageWhereInput>
  }

  export type TransactionWhatsappServiceOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    whatsappPackageId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    transaction?: TransactionOrderByWithRelationInput
    whatsappPackage?: WhatsappApiPackageOrderByWithRelationInput
  }

  export type TransactionWhatsappServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: TransactionWhatsappServiceWhereInput | TransactionWhatsappServiceWhereInput[]
    OR?: TransactionWhatsappServiceWhereInput[]
    NOT?: TransactionWhatsappServiceWhereInput | TransactionWhatsappServiceWhereInput[]
    whatsappPackageId?: StringFilter<"TransactionWhatsappService"> | string
    duration?: StringFilter<"TransactionWhatsappService"> | string
    status?: StringFilter<"TransactionWhatsappService"> | string
    startDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    whatsappPackage?: XOR<WhatsappApiPackageScalarRelationFilter, WhatsappApiPackageWhereInput>
  }, "id" | "transactionId">

  export type TransactionWhatsappServiceOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    whatsappPackageId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    _count?: TransactionWhatsappServiceCountOrderByAggregateInput
    _max?: TransactionWhatsappServiceMaxOrderByAggregateInput
    _min?: TransactionWhatsappServiceMinOrderByAggregateInput
  }

  export type TransactionWhatsappServiceScalarWhereWithAggregatesInput = {
    AND?: TransactionWhatsappServiceScalarWhereWithAggregatesInput | TransactionWhatsappServiceScalarWhereWithAggregatesInput[]
    OR?: TransactionWhatsappServiceScalarWhereWithAggregatesInput[]
    NOT?: TransactionWhatsappServiceScalarWhereWithAggregatesInput | TransactionWhatsappServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionWhatsappService"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionWhatsappService"> | string
    whatsappPackageId?: StringWithAggregatesFilter<"TransactionWhatsappService"> | string
    duration?: StringWithAggregatesFilter<"TransactionWhatsappService"> | string
    status?: StringWithAggregatesFilter<"TransactionWhatsappService"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"TransactionWhatsappService"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"TransactionWhatsappService"> | Date | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    externalId?: StringNullableFilter<"Payment"> | string | null
    paymentUrl?: StringNullableFilter<"Payment"> | string | null
    serviceFee?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    adminNotes?: StringNullableFilter<"Payment"> | string | null
    adminAction?: StringNullableFilter<"Payment"> | string | null
    adminUserId?: StringNullableFilter<"Payment"> | string | null
    actionDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    gatewayProvider?: StringNullableFilter<"Payment"> | string | null
    gatewayResponse?: JsonNullableFilter<"Payment">
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    paymentUrl?: SortOrderInput | SortOrder
    serviceFee?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    adminAction?: SortOrderInput | SortOrder
    adminUserId?: SortOrderInput | SortOrder
    actionDate?: SortOrderInput | SortOrder
    gatewayProvider?: SortOrderInput | SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    transaction?: TransactionOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    externalId?: StringNullableFilter<"Payment"> | string | null
    paymentUrl?: StringNullableFilter<"Payment"> | string | null
    serviceFee?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    adminNotes?: StringNullableFilter<"Payment"> | string | null
    adminAction?: StringNullableFilter<"Payment"> | string | null
    adminUserId?: StringNullableFilter<"Payment"> | string | null
    actionDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    gatewayProvider?: StringNullableFilter<"Payment"> | string | null
    gatewayResponse?: JsonNullableFilter<"Payment">
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }, "id" | "transactionId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    paymentUrl?: SortOrderInput | SortOrder
    serviceFee?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    adminAction?: SortOrderInput | SortOrder
    adminUserId?: SortOrderInput | SortOrder
    actionDate?: SortOrderInput | SortOrder
    gatewayProvider?: SortOrderInput | SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    paymentDate?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    externalId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paymentUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    serviceFee?: DecimalNullableWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    adminAction?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    adminUserId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    actionDate?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    gatewayProvider?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    gatewayResponse?: JsonNullableWithAggregatesFilter<"Payment">
  }

  export type WhatsappApiPackageWhereInput = {
    AND?: WhatsappApiPackageWhereInput | WhatsappApiPackageWhereInput[]
    OR?: WhatsappApiPackageWhereInput[]
    NOT?: WhatsappApiPackageWhereInput | WhatsappApiPackageWhereInput[]
    id?: StringFilter<"WhatsappApiPackage"> | string
    name?: StringFilter<"WhatsappApiPackage"> | string
    description?: StringNullableFilter<"WhatsappApiPackage"> | string | null
    priceMonth?: IntFilter<"WhatsappApiPackage"> | number
    priceYear?: IntFilter<"WhatsappApiPackage"> | number
    maxSession?: IntFilter<"WhatsappApiPackage"> | number
    createdAt?: DateTimeFilter<"WhatsappApiPackage"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappApiPackage"> | Date | string
    whatsappCustomers?: ServicesWhatsappCustomersListRelationFilter
    whatsappTransactions?: TransactionWhatsappServiceListRelationFilter
  }

  export type WhatsappApiPackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappCustomers?: ServicesWhatsappCustomersOrderByRelationAggregateInput
    whatsappTransactions?: TransactionWhatsappServiceOrderByRelationAggregateInput
  }

  export type WhatsappApiPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsappApiPackageWhereInput | WhatsappApiPackageWhereInput[]
    OR?: WhatsappApiPackageWhereInput[]
    NOT?: WhatsappApiPackageWhereInput | WhatsappApiPackageWhereInput[]
    name?: StringFilter<"WhatsappApiPackage"> | string
    description?: StringNullableFilter<"WhatsappApiPackage"> | string | null
    priceMonth?: IntFilter<"WhatsappApiPackage"> | number
    priceYear?: IntFilter<"WhatsappApiPackage"> | number
    maxSession?: IntFilter<"WhatsappApiPackage"> | number
    createdAt?: DateTimeFilter<"WhatsappApiPackage"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappApiPackage"> | Date | string
    whatsappCustomers?: ServicesWhatsappCustomersListRelationFilter
    whatsappTransactions?: TransactionWhatsappServiceListRelationFilter
  }, "id">

  export type WhatsappApiPackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsappApiPackageCountOrderByAggregateInput
    _avg?: WhatsappApiPackageAvgOrderByAggregateInput
    _max?: WhatsappApiPackageMaxOrderByAggregateInput
    _min?: WhatsappApiPackageMinOrderByAggregateInput
    _sum?: WhatsappApiPackageSumOrderByAggregateInput
  }

  export type WhatsappApiPackageScalarWhereWithAggregatesInput = {
    AND?: WhatsappApiPackageScalarWhereWithAggregatesInput | WhatsappApiPackageScalarWhereWithAggregatesInput[]
    OR?: WhatsappApiPackageScalarWhereWithAggregatesInput[]
    NOT?: WhatsappApiPackageScalarWhereWithAggregatesInput | WhatsappApiPackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsappApiPackage"> | string
    name?: StringWithAggregatesFilter<"WhatsappApiPackage"> | string
    description?: StringNullableWithAggregatesFilter<"WhatsappApiPackage"> | string | null
    priceMonth?: IntWithAggregatesFilter<"WhatsappApiPackage"> | number
    priceYear?: IntWithAggregatesFilter<"WhatsappApiPackage"> | number
    maxSession?: IntWithAggregatesFilter<"WhatsappApiPackage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WhatsappApiPackage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsappApiPackage"> | Date | string
  }

  export type ServicesWhatsappCustomersWhereInput = {
    AND?: ServicesWhatsappCustomersWhereInput | ServicesWhatsappCustomersWhereInput[]
    OR?: ServicesWhatsappCustomersWhereInput[]
    NOT?: ServicesWhatsappCustomersWhereInput | ServicesWhatsappCustomersWhereInput[]
    id?: StringFilter<"ServicesWhatsappCustomers"> | string
    customerId?: StringFilter<"ServicesWhatsappCustomers"> | string
    packageId?: StringFilter<"ServicesWhatsappCustomers"> | string
    status?: StringFilter<"ServicesWhatsappCustomers"> | string
    expiredAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    activatedAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    lastSubscriptionAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    package?: XOR<WhatsappApiPackageScalarRelationFilter, WhatsappApiPackageWhereInput>
  }

  export type ServicesWhatsappCustomersOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    status?: SortOrder
    expiredAt?: SortOrder
    activatedAt?: SortOrder
    updatedAt?: SortOrder
    lastSubscriptionAt?: SortOrder
    customer?: UserOrderByWithRelationInput
    package?: WhatsappApiPackageOrderByWithRelationInput
  }

  export type ServicesWhatsappCustomersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerId_packageId?: ServicesWhatsappCustomersCustomerIdPackageIdCompoundUniqueInput
    AND?: ServicesWhatsappCustomersWhereInput | ServicesWhatsappCustomersWhereInput[]
    OR?: ServicesWhatsappCustomersWhereInput[]
    NOT?: ServicesWhatsappCustomersWhereInput | ServicesWhatsappCustomersWhereInput[]
    customerId?: StringFilter<"ServicesWhatsappCustomers"> | string
    packageId?: StringFilter<"ServicesWhatsappCustomers"> | string
    status?: StringFilter<"ServicesWhatsappCustomers"> | string
    expiredAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    activatedAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    lastSubscriptionAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    package?: XOR<WhatsappApiPackageScalarRelationFilter, WhatsappApiPackageWhereInput>
  }, "id" | "customerId_packageId">

  export type ServicesWhatsappCustomersOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    status?: SortOrder
    expiredAt?: SortOrder
    activatedAt?: SortOrder
    updatedAt?: SortOrder
    lastSubscriptionAt?: SortOrder
    _count?: ServicesWhatsappCustomersCountOrderByAggregateInput
    _max?: ServicesWhatsappCustomersMaxOrderByAggregateInput
    _min?: ServicesWhatsappCustomersMinOrderByAggregateInput
  }

  export type ServicesWhatsappCustomersScalarWhereWithAggregatesInput = {
    AND?: ServicesWhatsappCustomersScalarWhereWithAggregatesInput | ServicesWhatsappCustomersScalarWhereWithAggregatesInput[]
    OR?: ServicesWhatsappCustomersScalarWhereWithAggregatesInput[]
    NOT?: ServicesWhatsappCustomersScalarWhereWithAggregatesInput | ServicesWhatsappCustomersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServicesWhatsappCustomers"> | string
    customerId?: StringWithAggregatesFilter<"ServicesWhatsappCustomers"> | string
    packageId?: StringWithAggregatesFilter<"ServicesWhatsappCustomers"> | string
    status?: StringWithAggregatesFilter<"ServicesWhatsappCustomers"> | string
    expiredAt?: DateTimeWithAggregatesFilter<"ServicesWhatsappCustomers"> | Date | string
    activatedAt?: DateTimeWithAggregatesFilter<"ServicesWhatsappCustomers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServicesWhatsappCustomers"> | Date | string
    lastSubscriptionAt?: DateTimeWithAggregatesFilter<"ServicesWhatsappCustomers"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    lastUsed?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    id?: StringFilter<"UserSession"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    id?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    lastUsed?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type UserSessionOrderByWithAggregationInput = {
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    token?: StringWithAggregatesFilter<"UserSession"> | string
    deviceInfo?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserSession"> | boolean
    lastUsed?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    id?: StringWithAggregatesFilter<"UserSession"> | string
  }

  export type VoucherWhereInput = {
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    id?: StringFilter<"Voucher"> | string
    code?: StringFilter<"Voucher"> | string
    name?: StringFilter<"Voucher"> | string
    description?: StringNullableFilter<"Voucher"> | string | null
    type?: StringFilter<"Voucher"> | string
    discountType?: StringFilter<"Voucher"> | string
    value?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxUses?: IntNullableFilter<"Voucher"> | number | null
    usedCount?: IntFilter<"Voucher"> | number
    allowMultipleUsePerUser?: BoolFilter<"Voucher"> | boolean
    isActive?: BoolFilter<"Voucher"> | boolean
    startDate?: DateTimeFilter<"Voucher"> | Date | string
    endDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    transactions?: TransactionListRelationFilter
    voucherUsage?: VoucherUsageListRelationFilter
  }

  export type VoucherOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    allowMultipleUsePerUser?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    voucherUsage?: VoucherUsageOrderByRelationAggregateInput
  }

  export type VoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    name?: StringFilter<"Voucher"> | string
    description?: StringNullableFilter<"Voucher"> | string | null
    type?: StringFilter<"Voucher"> | string
    discountType?: StringFilter<"Voucher"> | string
    value?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxUses?: IntNullableFilter<"Voucher"> | number | null
    usedCount?: IntFilter<"Voucher"> | number
    allowMultipleUsePerUser?: BoolFilter<"Voucher"> | boolean
    isActive?: BoolFilter<"Voucher"> | boolean
    startDate?: DateTimeFilter<"Voucher"> | Date | string
    endDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    transactions?: TransactionListRelationFilter
    voucherUsage?: VoucherUsageListRelationFilter
  }, "id" | "code">

  export type VoucherOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    allowMultipleUsePerUser?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoucherCountOrderByAggregateInput
    _avg?: VoucherAvgOrderByAggregateInput
    _max?: VoucherMaxOrderByAggregateInput
    _min?: VoucherMinOrderByAggregateInput
    _sum?: VoucherSumOrderByAggregateInput
  }

  export type VoucherScalarWhereWithAggregatesInput = {
    AND?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    OR?: VoucherScalarWhereWithAggregatesInput[]
    NOT?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Voucher"> | string
    code?: StringWithAggregatesFilter<"Voucher"> | string
    name?: StringWithAggregatesFilter<"Voucher"> | string
    description?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    type?: StringWithAggregatesFilter<"Voucher"> | string
    discountType?: StringWithAggregatesFilter<"Voucher"> | string
    value?: DecimalWithAggregatesFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableWithAggregatesFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableWithAggregatesFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxUses?: IntNullableWithAggregatesFilter<"Voucher"> | number | null
    usedCount?: IntWithAggregatesFilter<"Voucher"> | number
    allowMultipleUsePerUser?: BoolWithAggregatesFilter<"Voucher"> | boolean
    isActive?: BoolWithAggregatesFilter<"Voucher"> | boolean
    startDate?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
  }

  export type VoucherUsageWhereInput = {
    AND?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    OR?: VoucherUsageWhereInput[]
    NOT?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    id?: StringFilter<"VoucherUsage"> | string
    voucherId?: StringFilter<"VoucherUsage"> | string
    userId?: StringFilter<"VoucherUsage"> | string
    transactionId?: StringNullableFilter<"VoucherUsage"> | string | null
    usedAt?: DateTimeFilter<"VoucherUsage"> | Date | string
    discountAmount?: DecimalFilter<"VoucherUsage"> | Decimal | DecimalJsLike | number | string
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    voucher?: XOR<VoucherScalarRelationFilter, VoucherWhereInput>
  }

  export type VoucherUsageOrderByWithRelationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    voucher?: VoucherOrderByWithRelationInput
  }

  export type VoucherUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    OR?: VoucherUsageWhereInput[]
    NOT?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    voucherId?: StringFilter<"VoucherUsage"> | string
    userId?: StringFilter<"VoucherUsage"> | string
    transactionId?: StringNullableFilter<"VoucherUsage"> | string | null
    usedAt?: DateTimeFilter<"VoucherUsage"> | Date | string
    discountAmount?: DecimalFilter<"VoucherUsage"> | Decimal | DecimalJsLike | number | string
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    voucher?: XOR<VoucherScalarRelationFilter, VoucherWhereInput>
  }, "id">

  export type VoucherUsageOrderByWithAggregationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
    _count?: VoucherUsageCountOrderByAggregateInput
    _avg?: VoucherUsageAvgOrderByAggregateInput
    _max?: VoucherUsageMaxOrderByAggregateInput
    _min?: VoucherUsageMinOrderByAggregateInput
    _sum?: VoucherUsageSumOrderByAggregateInput
  }

  export type VoucherUsageScalarWhereWithAggregatesInput = {
    AND?: VoucherUsageScalarWhereWithAggregatesInput | VoucherUsageScalarWhereWithAggregatesInput[]
    OR?: VoucherUsageScalarWhereWithAggregatesInput[]
    NOT?: VoucherUsageScalarWhereWithAggregatesInput | VoucherUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VoucherUsage"> | string
    voucherId?: StringWithAggregatesFilter<"VoucherUsage"> | string
    userId?: StringWithAggregatesFilter<"VoucherUsage"> | string
    transactionId?: StringNullableWithAggregatesFilter<"VoucherUsage"> | string | null
    usedAt?: DateTimeWithAggregatesFilter<"VoucherUsage"> | Date | string
    discountAmount?: DecimalWithAggregatesFilter<"VoucherUsage"> | Decimal | DecimalJsLike | number | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    code?: StringFilter<"PaymentMethod"> | string
    name?: StringFilter<"PaymentMethod"> | string
    description?: StringNullableFilter<"PaymentMethod"> | string | null
    type?: StringFilter<"PaymentMethod"> | string
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    isSystem?: BoolFilter<"PaymentMethod"> | boolean
    gatewayProvider?: StringNullableFilter<"PaymentMethod"> | string | null
    gatewayCode?: StringNullableFilter<"PaymentMethod"> | string | null
    gatewayImageUrl?: StringNullableFilter<"PaymentMethod"> | string | null
    isGatewayMethod?: BoolFilter<"PaymentMethod"> | boolean
    bankDetailId?: StringNullableFilter<"PaymentMethod"> | string | null
    feeType?: StringNullableFilter<"PaymentMethod"> | string | null
    feeValue?: DecimalNullableFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    minFee?: DecimalNullableFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    maxFee?: DecimalNullableFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolFilter<"PaymentMethod"> | boolean
    paymentInstructions?: StringNullableFilter<"PaymentMethod"> | string | null
    instructionType?: StringNullableFilter<"PaymentMethod"> | string | null
    instructionImageUrl?: StringNullableFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    bankDetail?: XOR<BankDetailNullableScalarRelationFilter, BankDetailWhereInput> | null
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    gatewayProvider?: SortOrderInput | SortOrder
    gatewayCode?: SortOrderInput | SortOrder
    gatewayImageUrl?: SortOrderInput | SortOrder
    isGatewayMethod?: SortOrder
    bankDetailId?: SortOrderInput | SortOrder
    feeType?: SortOrderInput | SortOrder
    feeValue?: SortOrderInput | SortOrder
    minFee?: SortOrderInput | SortOrder
    maxFee?: SortOrderInput | SortOrder
    requiresManualApproval?: SortOrder
    paymentInstructions?: SortOrderInput | SortOrder
    instructionType?: SortOrderInput | SortOrder
    instructionImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bankDetail?: BankDetailOrderByWithRelationInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    name?: StringFilter<"PaymentMethod"> | string
    description?: StringNullableFilter<"PaymentMethod"> | string | null
    type?: StringFilter<"PaymentMethod"> | string
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    isSystem?: BoolFilter<"PaymentMethod"> | boolean
    gatewayProvider?: StringNullableFilter<"PaymentMethod"> | string | null
    gatewayCode?: StringNullableFilter<"PaymentMethod"> | string | null
    gatewayImageUrl?: StringNullableFilter<"PaymentMethod"> | string | null
    isGatewayMethod?: BoolFilter<"PaymentMethod"> | boolean
    bankDetailId?: StringNullableFilter<"PaymentMethod"> | string | null
    feeType?: StringNullableFilter<"PaymentMethod"> | string | null
    feeValue?: DecimalNullableFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    minFee?: DecimalNullableFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    maxFee?: DecimalNullableFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolFilter<"PaymentMethod"> | boolean
    paymentInstructions?: StringNullableFilter<"PaymentMethod"> | string | null
    instructionType?: StringNullableFilter<"PaymentMethod"> | string | null
    instructionImageUrl?: StringNullableFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    bankDetail?: XOR<BankDetailNullableScalarRelationFilter, BankDetailWhereInput> | null
  }, "id" | "code">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    gatewayProvider?: SortOrderInput | SortOrder
    gatewayCode?: SortOrderInput | SortOrder
    gatewayImageUrl?: SortOrderInput | SortOrder
    isGatewayMethod?: SortOrder
    bankDetailId?: SortOrderInput | SortOrder
    feeType?: SortOrderInput | SortOrder
    feeValue?: SortOrderInput | SortOrder
    minFee?: SortOrderInput | SortOrder
    maxFee?: SortOrderInput | SortOrder
    requiresManualApproval?: SortOrder
    paymentInstructions?: SortOrderInput | SortOrder
    instructionType?: SortOrderInput | SortOrder
    instructionImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    code?: StringWithAggregatesFilter<"PaymentMethod"> | string
    name?: StringWithAggregatesFilter<"PaymentMethod"> | string
    description?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    type?: StringWithAggregatesFilter<"PaymentMethod"> | string
    isActive?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    isSystem?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    gatewayProvider?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    gatewayCode?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    gatewayImageUrl?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    isGatewayMethod?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    bankDetailId?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    feeType?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    feeValue?: DecimalNullableWithAggregatesFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    minFee?: DecimalNullableWithAggregatesFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    maxFee?: DecimalNullableWithAggregatesFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    paymentInstructions?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    instructionType?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    instructionImageUrl?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type BankDetailWhereInput = {
    AND?: BankDetailWhereInput | BankDetailWhereInput[]
    OR?: BankDetailWhereInput[]
    NOT?: BankDetailWhereInput | BankDetailWhereInput[]
    id?: StringFilter<"BankDetail"> | string
    bankName?: StringFilter<"BankDetail"> | string
    accountNumber?: StringFilter<"BankDetail"> | string
    accountName?: StringFilter<"BankDetail"> | string
    swiftCode?: StringNullableFilter<"BankDetail"> | string | null
    isActive?: BoolFilter<"BankDetail"> | boolean
    createdAt?: DateTimeFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetail"> | Date | string
    paymentMethods?: PaymentMethodListRelationFilter
  }

  export type BankDetailOrderByWithRelationInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    swiftCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentMethods?: PaymentMethodOrderByRelationAggregateInput
  }

  export type BankDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankDetailWhereInput | BankDetailWhereInput[]
    OR?: BankDetailWhereInput[]
    NOT?: BankDetailWhereInput | BankDetailWhereInput[]
    bankName?: StringFilter<"BankDetail"> | string
    accountNumber?: StringFilter<"BankDetail"> | string
    accountName?: StringFilter<"BankDetail"> | string
    swiftCode?: StringNullableFilter<"BankDetail"> | string | null
    isActive?: BoolFilter<"BankDetail"> | boolean
    createdAt?: DateTimeFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetail"> | Date | string
    paymentMethods?: PaymentMethodListRelationFilter
  }, "id">

  export type BankDetailOrderByWithAggregationInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    swiftCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankDetailCountOrderByAggregateInput
    _max?: BankDetailMaxOrderByAggregateInput
    _min?: BankDetailMinOrderByAggregateInput
  }

  export type BankDetailScalarWhereWithAggregatesInput = {
    AND?: BankDetailScalarWhereWithAggregatesInput | BankDetailScalarWhereWithAggregatesInput[]
    OR?: BankDetailScalarWhereWithAggregatesInput[]
    NOT?: BankDetailScalarWhereWithAggregatesInput | BankDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankDetail"> | string
    bankName?: StringWithAggregatesFilter<"BankDetail"> | string
    accountNumber?: StringWithAggregatesFilter<"BankDetail"> | string
    accountName?: StringWithAggregatesFilter<"BankDetail"> | string
    swiftCode?: StringNullableWithAggregatesFilter<"BankDetail"> | string | null
    isActive?: BoolWithAggregatesFilter<"BankDetail"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankDetail"> | Date | string
  }

  export type WhatsAppCampaignWhereInput = {
    AND?: WhatsAppCampaignWhereInput | WhatsAppCampaignWhereInput[]
    OR?: WhatsAppCampaignWhereInput[]
    NOT?: WhatsAppCampaignWhereInput | WhatsAppCampaignWhereInput[]
    id?: BigIntFilter<"WhatsAppCampaign"> | bigint | number
    user_id?: StringFilter<"WhatsAppCampaign"> | string
    name?: StringFilter<"WhatsAppCampaign"> | string
    type?: StringFilter<"WhatsAppCampaign"> | string
    status?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    message_body?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    image_url?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    image_base64?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    caption?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WhatsAppCampaignOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrderInput | SortOrder
    message_body?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    image_base64?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type WhatsAppCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: WhatsAppCampaignWhereInput | WhatsAppCampaignWhereInput[]
    OR?: WhatsAppCampaignWhereInput[]
    NOT?: WhatsAppCampaignWhereInput | WhatsAppCampaignWhereInput[]
    user_id?: StringFilter<"WhatsAppCampaign"> | string
    name?: StringFilter<"WhatsAppCampaign"> | string
    type?: StringFilter<"WhatsAppCampaign"> | string
    status?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    message_body?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    image_url?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    image_base64?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    caption?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WhatsAppCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrderInput | SortOrder
    message_body?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    image_base64?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: WhatsAppCampaignCountOrderByAggregateInput
    _avg?: WhatsAppCampaignAvgOrderByAggregateInput
    _max?: WhatsAppCampaignMaxOrderByAggregateInput
    _min?: WhatsAppCampaignMinOrderByAggregateInput
    _sum?: WhatsAppCampaignSumOrderByAggregateInput
  }

  export type WhatsAppCampaignScalarWhereWithAggregatesInput = {
    AND?: WhatsAppCampaignScalarWhereWithAggregatesInput | WhatsAppCampaignScalarWhereWithAggregatesInput[]
    OR?: WhatsAppCampaignScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppCampaignScalarWhereWithAggregatesInput | WhatsAppCampaignScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"WhatsAppCampaign"> | bigint | number
    user_id?: StringWithAggregatesFilter<"WhatsAppCampaign"> | string
    name?: StringWithAggregatesFilter<"WhatsAppCampaign"> | string
    type?: StringWithAggregatesFilter<"WhatsAppCampaign"> | string
    status?: StringNullableWithAggregatesFilter<"WhatsAppCampaign"> | string | null
    message_body?: StringNullableWithAggregatesFilter<"WhatsAppCampaign"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"WhatsAppCampaign"> | string | null
    image_base64?: StringNullableWithAggregatesFilter<"WhatsAppCampaign"> | string | null
    caption?: StringNullableWithAggregatesFilter<"WhatsAppCampaign"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppCampaign"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppCampaign"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppCampaign"> | Date | string | null
  }

  export type WhatsAppBulkCampaignWhereInput = {
    AND?: WhatsAppBulkCampaignWhereInput | WhatsAppBulkCampaignWhereInput[]
    OR?: WhatsAppBulkCampaignWhereInput[]
    NOT?: WhatsAppBulkCampaignWhereInput | WhatsAppBulkCampaignWhereInput[]
    id?: BigIntFilter<"WhatsAppBulkCampaign"> | bigint | number
    user_id?: StringFilter<"WhatsAppBulkCampaign"> | string
    campaign_id?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    name?: StringFilter<"WhatsAppBulkCampaign"> | string
    type?: StringFilter<"WhatsAppBulkCampaign"> | string
    message_body?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    image_url?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    image_base64?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    caption?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    status?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    total_count?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    sent_count?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    failed_count?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    scheduled_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    timezone?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    processed_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    error_message?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    WhatsAppCampaigns?: XOR<WhatsAppCampaignNullableScalarRelationFilter, WhatsAppCampaignWhereInput> | null
  }

  export type WhatsAppBulkCampaignOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    campaign_id?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    message_body?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    image_base64?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    total_count?: SortOrderInput | SortOrder
    sent_count?: SortOrderInput | SortOrder
    failed_count?: SortOrderInput | SortOrder
    scheduled_at?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    processed_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
    WhatsAppCampaigns?: WhatsAppCampaignOrderByWithRelationInput
  }

  export type WhatsAppBulkCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: WhatsAppBulkCampaignWhereInput | WhatsAppBulkCampaignWhereInput[]
    OR?: WhatsAppBulkCampaignWhereInput[]
    NOT?: WhatsAppBulkCampaignWhereInput | WhatsAppBulkCampaignWhereInput[]
    user_id?: StringFilter<"WhatsAppBulkCampaign"> | string
    campaign_id?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    name?: StringFilter<"WhatsAppBulkCampaign"> | string
    type?: StringFilter<"WhatsAppBulkCampaign"> | string
    message_body?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    image_url?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    image_base64?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    caption?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    status?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    total_count?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    sent_count?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    failed_count?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    scheduled_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    timezone?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    processed_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    error_message?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    WhatsAppCampaigns?: XOR<WhatsAppCampaignNullableScalarRelationFilter, WhatsAppCampaignWhereInput> | null
  }, "id">

  export type WhatsAppBulkCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    campaign_id?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    message_body?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    image_base64?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    total_count?: SortOrderInput | SortOrder
    sent_count?: SortOrderInput | SortOrder
    failed_count?: SortOrderInput | SortOrder
    scheduled_at?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    processed_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: WhatsAppBulkCampaignCountOrderByAggregateInput
    _avg?: WhatsAppBulkCampaignAvgOrderByAggregateInput
    _max?: WhatsAppBulkCampaignMaxOrderByAggregateInput
    _min?: WhatsAppBulkCampaignMinOrderByAggregateInput
    _sum?: WhatsAppBulkCampaignSumOrderByAggregateInput
  }

  export type WhatsAppBulkCampaignScalarWhereWithAggregatesInput = {
    AND?: WhatsAppBulkCampaignScalarWhereWithAggregatesInput | WhatsAppBulkCampaignScalarWhereWithAggregatesInput[]
    OR?: WhatsAppBulkCampaignScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppBulkCampaignScalarWhereWithAggregatesInput | WhatsAppBulkCampaignScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"WhatsAppBulkCampaign"> | bigint | number
    user_id?: StringWithAggregatesFilter<"WhatsAppBulkCampaign"> | string
    campaign_id?: BigIntNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    name?: StringWithAggregatesFilter<"WhatsAppBulkCampaign"> | string
    type?: StringWithAggregatesFilter<"WhatsAppBulkCampaign"> | string
    message_body?: StringNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | string | null
    image_base64?: StringNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | string | null
    caption?: StringNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | string | null
    status?: StringNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | string | null
    total_count?: BigIntNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    sent_count?: BigIntNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    failed_count?: BigIntNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    scheduled_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | Date | string | null
    timezone?: StringNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | string | null
    processed_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | Date | string | null
    error_message?: StringNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppBulkCampaign"> | Date | string | null
  }

  export type WhatsAppBulkCampaignItemWhereInput = {
    AND?: WhatsAppBulkCampaignItemWhereInput | WhatsAppBulkCampaignItemWhereInput[]
    OR?: WhatsAppBulkCampaignItemWhereInput[]
    NOT?: WhatsAppBulkCampaignItemWhereInput | WhatsAppBulkCampaignItemWhereInput[]
    id?: BigIntFilter<"WhatsAppBulkCampaignItem"> | bigint | number
    bulk_campaign_id?: BigIntFilter<"WhatsAppBulkCampaignItem"> | bigint | number
    phone?: StringFilter<"WhatsAppBulkCampaignItem"> | string
    status?: StringNullableFilter<"WhatsAppBulkCampaignItem"> | string | null
    message_id?: StringNullableFilter<"WhatsAppBulkCampaignItem"> | string | null
    error_message?: StringNullableFilter<"WhatsAppBulkCampaignItem"> | string | null
    sent_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    WhatsAppBulkCampaigns?: XOR<WhatsAppBulkCampaignScalarRelationFilter, WhatsAppBulkCampaignWhereInput>
  }

  export type WhatsAppBulkCampaignItemOrderByWithRelationInput = {
    id?: SortOrder
    bulk_campaign_id?: SortOrder
    phone?: SortOrder
    status?: SortOrderInput | SortOrder
    message_id?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    sent_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignOrderByWithRelationInput
  }

  export type WhatsAppBulkCampaignItemWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: WhatsAppBulkCampaignItemWhereInput | WhatsAppBulkCampaignItemWhereInput[]
    OR?: WhatsAppBulkCampaignItemWhereInput[]
    NOT?: WhatsAppBulkCampaignItemWhereInput | WhatsAppBulkCampaignItemWhereInput[]
    bulk_campaign_id?: BigIntFilter<"WhatsAppBulkCampaignItem"> | bigint | number
    phone?: StringFilter<"WhatsAppBulkCampaignItem"> | string
    status?: StringNullableFilter<"WhatsAppBulkCampaignItem"> | string | null
    message_id?: StringNullableFilter<"WhatsAppBulkCampaignItem"> | string | null
    error_message?: StringNullableFilter<"WhatsAppBulkCampaignItem"> | string | null
    sent_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    WhatsAppBulkCampaigns?: XOR<WhatsAppBulkCampaignScalarRelationFilter, WhatsAppBulkCampaignWhereInput>
  }, "id">

  export type WhatsAppBulkCampaignItemOrderByWithAggregationInput = {
    id?: SortOrder
    bulk_campaign_id?: SortOrder
    phone?: SortOrder
    status?: SortOrderInput | SortOrder
    message_id?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    sent_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: WhatsAppBulkCampaignItemCountOrderByAggregateInput
    _avg?: WhatsAppBulkCampaignItemAvgOrderByAggregateInput
    _max?: WhatsAppBulkCampaignItemMaxOrderByAggregateInput
    _min?: WhatsAppBulkCampaignItemMinOrderByAggregateInput
    _sum?: WhatsAppBulkCampaignItemSumOrderByAggregateInput
  }

  export type WhatsAppBulkCampaignItemScalarWhereWithAggregatesInput = {
    AND?: WhatsAppBulkCampaignItemScalarWhereWithAggregatesInput | WhatsAppBulkCampaignItemScalarWhereWithAggregatesInput[]
    OR?: WhatsAppBulkCampaignItemScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppBulkCampaignItemScalarWhereWithAggregatesInput | WhatsAppBulkCampaignItemScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"WhatsAppBulkCampaignItem"> | bigint | number
    bulk_campaign_id?: BigIntWithAggregatesFilter<"WhatsAppBulkCampaignItem"> | bigint | number
    phone?: StringWithAggregatesFilter<"WhatsAppBulkCampaignItem"> | string
    status?: StringNullableWithAggregatesFilter<"WhatsAppBulkCampaignItem"> | string | null
    message_id?: StringNullableWithAggregatesFilter<"WhatsAppBulkCampaignItem"> | string | null
    error_message?: StringNullableWithAggregatesFilter<"WhatsAppBulkCampaignItem"> | string | null
    sent_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
  }

  export type WhatsAppContactWhereInput = {
    AND?: WhatsAppContactWhereInput | WhatsAppContactWhereInput[]
    OR?: WhatsAppContactWhereInput[]
    NOT?: WhatsAppContactWhereInput | WhatsAppContactWhereInput[]
    id?: BigIntFilter<"WhatsAppContact"> | bigint | number
    user_id?: StringFilter<"WhatsAppContact"> | string
    phone?: StringFilter<"WhatsAppContact"> | string
    name?: StringNullableFilter<"WhatsAppContact"> | string | null
    full_name?: StringNullableFilter<"WhatsAppContact"> | string | null
    push_name?: StringNullableFilter<"WhatsAppContact"> | string | null
    short?: StringNullableFilter<"WhatsAppContact"> | string | null
    notify?: StringNullableFilter<"WhatsAppContact"> | string | null
    business?: BoolNullableFilter<"WhatsAppContact"> | boolean | null
    verified?: BoolNullableFilter<"WhatsAppContact"> | boolean | null
    source?: StringNullableFilter<"WhatsAppContact"> | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WhatsAppContactOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    phone?: SortOrder
    name?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    push_name?: SortOrderInput | SortOrder
    short?: SortOrderInput | SortOrder
    notify?: SortOrderInput | SortOrder
    business?: SortOrderInput | SortOrder
    verified?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type WhatsAppContactWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: WhatsAppContactWhereInput | WhatsAppContactWhereInput[]
    OR?: WhatsAppContactWhereInput[]
    NOT?: WhatsAppContactWhereInput | WhatsAppContactWhereInput[]
    user_id?: StringFilter<"WhatsAppContact"> | string
    phone?: StringFilter<"WhatsAppContact"> | string
    name?: StringNullableFilter<"WhatsAppContact"> | string | null
    full_name?: StringNullableFilter<"WhatsAppContact"> | string | null
    push_name?: StringNullableFilter<"WhatsAppContact"> | string | null
    short?: StringNullableFilter<"WhatsAppContact"> | string | null
    notify?: StringNullableFilter<"WhatsAppContact"> | string | null
    business?: BoolNullableFilter<"WhatsAppContact"> | boolean | null
    verified?: BoolNullableFilter<"WhatsAppContact"> | boolean | null
    source?: StringNullableFilter<"WhatsAppContact"> | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WhatsAppContactOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    phone?: SortOrder
    name?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    push_name?: SortOrderInput | SortOrder
    short?: SortOrderInput | SortOrder
    notify?: SortOrderInput | SortOrder
    business?: SortOrderInput | SortOrder
    verified?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: WhatsAppContactCountOrderByAggregateInput
    _avg?: WhatsAppContactAvgOrderByAggregateInput
    _max?: WhatsAppContactMaxOrderByAggregateInput
    _min?: WhatsAppContactMinOrderByAggregateInput
    _sum?: WhatsAppContactSumOrderByAggregateInput
  }

  export type WhatsAppContactScalarWhereWithAggregatesInput = {
    AND?: WhatsAppContactScalarWhereWithAggregatesInput | WhatsAppContactScalarWhereWithAggregatesInput[]
    OR?: WhatsAppContactScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppContactScalarWhereWithAggregatesInput | WhatsAppContactScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"WhatsAppContact"> | bigint | number
    user_id?: StringWithAggregatesFilter<"WhatsAppContact"> | string
    phone?: StringWithAggregatesFilter<"WhatsAppContact"> | string
    name?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    full_name?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    push_name?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    short?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    notify?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    business?: BoolNullableWithAggregatesFilter<"WhatsAppContact"> | boolean | null
    verified?: BoolNullableWithAggregatesFilter<"WhatsAppContact"> | boolean | null
    source?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppContact"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppContact"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"WhatsAppContact"> | Date | string | null
  }

  export type WhatsAppMessageStatsWhereInput = {
    AND?: WhatsAppMessageStatsWhereInput | WhatsAppMessageStatsWhereInput[]
    OR?: WhatsAppMessageStatsWhereInput[]
    NOT?: WhatsAppMessageStatsWhereInput | WhatsAppMessageStatsWhereInput[]
    id?: StringFilter<"WhatsAppMessageStats"> | string
    userId?: StringFilter<"WhatsAppMessageStats"> | string
    sessionId?: StringFilter<"WhatsAppMessageStats"> | string
    totalMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    totalMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    textMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    textMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    imageMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    imageMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    documentMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    documentMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    audioMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    audioMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    stickerMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    stickerMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    videoMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    videoMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    locationMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    locationMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    contactMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    contactMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    templateMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    templateMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    lastMessageSentAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    lastMessageFailedAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    session?: XOR<WhatsAppSessionScalarRelationFilter, WhatsAppSessionWhereInput>
  }

  export type WhatsAppMessageStatsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    textMessagesSent?: SortOrder
    textMessagesFailed?: SortOrder
    imageMessagesSent?: SortOrder
    imageMessagesFailed?: SortOrder
    documentMessagesSent?: SortOrder
    documentMessagesFailed?: SortOrder
    audioMessagesSent?: SortOrder
    audioMessagesFailed?: SortOrder
    stickerMessagesSent?: SortOrder
    stickerMessagesFailed?: SortOrder
    videoMessagesSent?: SortOrder
    videoMessagesFailed?: SortOrder
    locationMessagesSent?: SortOrder
    locationMessagesFailed?: SortOrder
    contactMessagesSent?: SortOrder
    contactMessagesFailed?: SortOrder
    templateMessagesSent?: SortOrder
    templateMessagesFailed?: SortOrder
    lastMessageSentAt?: SortOrderInput | SortOrder
    lastMessageFailedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    session?: WhatsAppSessionOrderByWithRelationInput
  }

  export type WhatsAppMessageStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_sessionId?: WhatsAppMessageStatsUserIdSessionIdCompoundUniqueInput
    AND?: WhatsAppMessageStatsWhereInput | WhatsAppMessageStatsWhereInput[]
    OR?: WhatsAppMessageStatsWhereInput[]
    NOT?: WhatsAppMessageStatsWhereInput | WhatsAppMessageStatsWhereInput[]
    userId?: StringFilter<"WhatsAppMessageStats"> | string
    sessionId?: StringFilter<"WhatsAppMessageStats"> | string
    totalMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    totalMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    textMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    textMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    imageMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    imageMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    documentMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    documentMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    audioMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    audioMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    stickerMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    stickerMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    videoMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    videoMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    locationMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    locationMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    contactMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    contactMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    templateMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    templateMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    lastMessageSentAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    lastMessageFailedAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    session?: XOR<WhatsAppSessionScalarRelationFilter, WhatsAppSessionWhereInput>
  }, "id" | "userId_sessionId">

  export type WhatsAppMessageStatsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    textMessagesSent?: SortOrder
    textMessagesFailed?: SortOrder
    imageMessagesSent?: SortOrder
    imageMessagesFailed?: SortOrder
    documentMessagesSent?: SortOrder
    documentMessagesFailed?: SortOrder
    audioMessagesSent?: SortOrder
    audioMessagesFailed?: SortOrder
    stickerMessagesSent?: SortOrder
    stickerMessagesFailed?: SortOrder
    videoMessagesSent?: SortOrder
    videoMessagesFailed?: SortOrder
    locationMessagesSent?: SortOrder
    locationMessagesFailed?: SortOrder
    contactMessagesSent?: SortOrder
    contactMessagesFailed?: SortOrder
    templateMessagesSent?: SortOrder
    templateMessagesFailed?: SortOrder
    lastMessageSentAt?: SortOrderInput | SortOrder
    lastMessageFailedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsAppMessageStatsCountOrderByAggregateInput
    _avg?: WhatsAppMessageStatsAvgOrderByAggregateInput
    _max?: WhatsAppMessageStatsMaxOrderByAggregateInput
    _min?: WhatsAppMessageStatsMinOrderByAggregateInput
    _sum?: WhatsAppMessageStatsSumOrderByAggregateInput
  }

  export type WhatsAppMessageStatsScalarWhereWithAggregatesInput = {
    AND?: WhatsAppMessageStatsScalarWhereWithAggregatesInput | WhatsAppMessageStatsScalarWhereWithAggregatesInput[]
    OR?: WhatsAppMessageStatsScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppMessageStatsScalarWhereWithAggregatesInput | WhatsAppMessageStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppMessageStats"> | string
    userId?: StringWithAggregatesFilter<"WhatsAppMessageStats"> | string
    sessionId?: StringWithAggregatesFilter<"WhatsAppMessageStats"> | string
    totalMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    totalMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    textMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    textMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    imageMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    imageMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    documentMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    documentMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    audioMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    audioMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    stickerMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    stickerMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    videoMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    videoMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    locationMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    locationMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    contactMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    contactMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    templateMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    templateMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    lastMessageSentAt?: DateTimeNullableWithAggregatesFilter<"WhatsAppMessageStats"> | Date | string | null
    lastMessageFailedAt?: DateTimeNullableWithAggregatesFilter<"WhatsAppMessageStats"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppMessageStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppMessageStats"> | Date | string
  }

  export type WhatsAppAIBotWhereInput = {
    AND?: WhatsAppAIBotWhereInput | WhatsAppAIBotWhereInput[]
    OR?: WhatsAppAIBotWhereInput[]
    NOT?: WhatsAppAIBotWhereInput | WhatsAppAIBotWhereInput[]
    id?: StringFilter<"WhatsAppAIBot"> | string
    userId?: StringFilter<"WhatsAppAIBot"> | string
    name?: StringFilter<"WhatsAppAIBot"> | string
    isActive?: BoolFilter<"WhatsAppAIBot"> | boolean
    systemPrompt?: StringNullableFilter<"WhatsAppAIBot"> | string | null
    fallbackText?: StringNullableFilter<"WhatsAppAIBot"> | string | null
    createdAt?: DateTimeFilter<"WhatsAppAIBot"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppAIBot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    aiBotSessionBindings?: AIBotSessionBindingListRelationFilter
    botKnowledgeBindings?: BotKnowledgeBindingListRelationFilter
  }

  export type WhatsAppAIBotOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    systemPrompt?: SortOrderInput | SortOrder
    fallbackText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    aiBotSessionBindings?: AIBotSessionBindingOrderByRelationAggregateInput
    botKnowledgeBindings?: BotKnowledgeBindingOrderByRelationAggregateInput
  }

  export type WhatsAppAIBotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsAppAIBotWhereInput | WhatsAppAIBotWhereInput[]
    OR?: WhatsAppAIBotWhereInput[]
    NOT?: WhatsAppAIBotWhereInput | WhatsAppAIBotWhereInput[]
    userId?: StringFilter<"WhatsAppAIBot"> | string
    name?: StringFilter<"WhatsAppAIBot"> | string
    isActive?: BoolFilter<"WhatsAppAIBot"> | boolean
    systemPrompt?: StringNullableFilter<"WhatsAppAIBot"> | string | null
    fallbackText?: StringNullableFilter<"WhatsAppAIBot"> | string | null
    createdAt?: DateTimeFilter<"WhatsAppAIBot"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppAIBot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    aiBotSessionBindings?: AIBotSessionBindingListRelationFilter
    botKnowledgeBindings?: BotKnowledgeBindingListRelationFilter
  }, "id">

  export type WhatsAppAIBotOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    systemPrompt?: SortOrderInput | SortOrder
    fallbackText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsAppAIBotCountOrderByAggregateInput
    _max?: WhatsAppAIBotMaxOrderByAggregateInput
    _min?: WhatsAppAIBotMinOrderByAggregateInput
  }

  export type WhatsAppAIBotScalarWhereWithAggregatesInput = {
    AND?: WhatsAppAIBotScalarWhereWithAggregatesInput | WhatsAppAIBotScalarWhereWithAggregatesInput[]
    OR?: WhatsAppAIBotScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppAIBotScalarWhereWithAggregatesInput | WhatsAppAIBotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppAIBot"> | string
    userId?: StringWithAggregatesFilter<"WhatsAppAIBot"> | string
    name?: StringWithAggregatesFilter<"WhatsAppAIBot"> | string
    isActive?: BoolWithAggregatesFilter<"WhatsAppAIBot"> | boolean
    systemPrompt?: StringNullableWithAggregatesFilter<"WhatsAppAIBot"> | string | null
    fallbackText?: StringNullableWithAggregatesFilter<"WhatsAppAIBot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppAIBot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppAIBot"> | Date | string
  }

  export type AIDocumentWhereInput = {
    AND?: AIDocumentWhereInput | AIDocumentWhereInput[]
    OR?: AIDocumentWhereInput[]
    NOT?: AIDocumentWhereInput | AIDocumentWhereInput[]
    id?: StringFilter<"AIDocument"> | string
    userId?: StringFilter<"AIDocument"> | string
    title?: StringFilter<"AIDocument"> | string
    kind?: StringFilter<"AIDocument"> | string
    content?: StringFilter<"AIDocument"> | string
    embeddingId?: StringNullableFilter<"AIDocument"> | string | null
    isActive?: BoolFilter<"AIDocument"> | boolean
    createdAt?: DateTimeFilter<"AIDocument"> | Date | string
    updatedAt?: DateTimeFilter<"AIDocument"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    botKnowledgeBindings?: BotKnowledgeBindingListRelationFilter
  }

  export type AIDocumentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    kind?: SortOrder
    content?: SortOrder
    embeddingId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    botKnowledgeBindings?: BotKnowledgeBindingOrderByRelationAggregateInput
  }

  export type AIDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIDocumentWhereInput | AIDocumentWhereInput[]
    OR?: AIDocumentWhereInput[]
    NOT?: AIDocumentWhereInput | AIDocumentWhereInput[]
    userId?: StringFilter<"AIDocument"> | string
    title?: StringFilter<"AIDocument"> | string
    kind?: StringFilter<"AIDocument"> | string
    content?: StringFilter<"AIDocument"> | string
    embeddingId?: StringNullableFilter<"AIDocument"> | string | null
    isActive?: BoolFilter<"AIDocument"> | boolean
    createdAt?: DateTimeFilter<"AIDocument"> | Date | string
    updatedAt?: DateTimeFilter<"AIDocument"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    botKnowledgeBindings?: BotKnowledgeBindingListRelationFilter
  }, "id">

  export type AIDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    kind?: SortOrder
    content?: SortOrder
    embeddingId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIDocumentCountOrderByAggregateInput
    _max?: AIDocumentMaxOrderByAggregateInput
    _min?: AIDocumentMinOrderByAggregateInput
  }

  export type AIDocumentScalarWhereWithAggregatesInput = {
    AND?: AIDocumentScalarWhereWithAggregatesInput | AIDocumentScalarWhereWithAggregatesInput[]
    OR?: AIDocumentScalarWhereWithAggregatesInput[]
    NOT?: AIDocumentScalarWhereWithAggregatesInput | AIDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIDocument"> | string
    userId?: StringWithAggregatesFilter<"AIDocument"> | string
    title?: StringWithAggregatesFilter<"AIDocument"> | string
    kind?: StringWithAggregatesFilter<"AIDocument"> | string
    content?: StringWithAggregatesFilter<"AIDocument"> | string
    embeddingId?: StringNullableWithAggregatesFilter<"AIDocument"> | string | null
    isActive?: BoolWithAggregatesFilter<"AIDocument"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AIDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIDocument"> | Date | string
  }

  export type AIUsageLogWhereInput = {
    AND?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    OR?: AIUsageLogWhereInput[]
    NOT?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    id?: StringFilter<"AIUsageLog"> | string
    userId?: StringFilter<"AIUsageLog"> | string
    sessionId?: StringNullableFilter<"AIUsageLog"> | string | null
    inputTokens?: IntFilter<"AIUsageLog"> | number
    outputTokens?: IntFilter<"AIUsageLog"> | number
    totalTokens?: IntFilter<"AIUsageLog"> | number
    latencyMs?: IntFilter<"AIUsageLog"> | number
    status?: StringFilter<"AIUsageLog"> | string
    errorReason?: StringNullableFilter<"AIUsageLog"> | string | null
    createdAt?: DateTimeFilter<"AIUsageLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AIUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
    status?: SortOrder
    errorReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AIUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    OR?: AIUsageLogWhereInput[]
    NOT?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    userId?: StringFilter<"AIUsageLog"> | string
    sessionId?: StringNullableFilter<"AIUsageLog"> | string | null
    inputTokens?: IntFilter<"AIUsageLog"> | number
    outputTokens?: IntFilter<"AIUsageLog"> | number
    totalTokens?: IntFilter<"AIUsageLog"> | number
    latencyMs?: IntFilter<"AIUsageLog"> | number
    status?: StringFilter<"AIUsageLog"> | string
    errorReason?: StringNullableFilter<"AIUsageLog"> | string | null
    createdAt?: DateTimeFilter<"AIUsageLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AIUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
    status?: SortOrder
    errorReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIUsageLogCountOrderByAggregateInput
    _avg?: AIUsageLogAvgOrderByAggregateInput
    _max?: AIUsageLogMaxOrderByAggregateInput
    _min?: AIUsageLogMinOrderByAggregateInput
    _sum?: AIUsageLogSumOrderByAggregateInput
  }

  export type AIUsageLogScalarWhereWithAggregatesInput = {
    AND?: AIUsageLogScalarWhereWithAggregatesInput | AIUsageLogScalarWhereWithAggregatesInput[]
    OR?: AIUsageLogScalarWhereWithAggregatesInput[]
    NOT?: AIUsageLogScalarWhereWithAggregatesInput | AIUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIUsageLog"> | string
    userId?: StringWithAggregatesFilter<"AIUsageLog"> | string
    sessionId?: StringNullableWithAggregatesFilter<"AIUsageLog"> | string | null
    inputTokens?: IntWithAggregatesFilter<"AIUsageLog"> | number
    outputTokens?: IntWithAggregatesFilter<"AIUsageLog"> | number
    totalTokens?: IntWithAggregatesFilter<"AIUsageLog"> | number
    latencyMs?: IntWithAggregatesFilter<"AIUsageLog"> | number
    status?: StringWithAggregatesFilter<"AIUsageLog"> | string
    errorReason?: StringNullableWithAggregatesFilter<"AIUsageLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIUsageLog"> | Date | string
  }

  export type AIBotSessionBindingWhereInput = {
    AND?: AIBotSessionBindingWhereInput | AIBotSessionBindingWhereInput[]
    OR?: AIBotSessionBindingWhereInput[]
    NOT?: AIBotSessionBindingWhereInput | AIBotSessionBindingWhereInput[]
    id?: StringFilter<"AIBotSessionBinding"> | string
    userId?: StringFilter<"AIBotSessionBinding"> | string
    botId?: StringFilter<"AIBotSessionBinding"> | string
    sessionId?: StringFilter<"AIBotSessionBinding"> | string
    isActive?: BoolFilter<"AIBotSessionBinding"> | boolean
    createdAt?: DateTimeFilter<"AIBotSessionBinding"> | Date | string
    updatedAt?: DateTimeFilter<"AIBotSessionBinding"> | Date | string
    bot?: XOR<WhatsAppAIBotScalarRelationFilter, WhatsAppAIBotWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    session?: XOR<WhatsAppSessionScalarRelationFilter, WhatsAppSessionWhereInput>
  }

  export type AIBotSessionBindingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    sessionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bot?: WhatsAppAIBotOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    session?: WhatsAppSessionOrderByWithRelationInput
  }

  export type AIBotSessionBindingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: AIBotSessionBindingWhereInput | AIBotSessionBindingWhereInput[]
    OR?: AIBotSessionBindingWhereInput[]
    NOT?: AIBotSessionBindingWhereInput | AIBotSessionBindingWhereInput[]
    userId?: StringFilter<"AIBotSessionBinding"> | string
    botId?: StringFilter<"AIBotSessionBinding"> | string
    isActive?: BoolFilter<"AIBotSessionBinding"> | boolean
    createdAt?: DateTimeFilter<"AIBotSessionBinding"> | Date | string
    updatedAt?: DateTimeFilter<"AIBotSessionBinding"> | Date | string
    bot?: XOR<WhatsAppAIBotScalarRelationFilter, WhatsAppAIBotWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    session?: XOR<WhatsAppSessionScalarRelationFilter, WhatsAppSessionWhereInput>
  }, "id" | "sessionId">

  export type AIBotSessionBindingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    sessionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIBotSessionBindingCountOrderByAggregateInput
    _max?: AIBotSessionBindingMaxOrderByAggregateInput
    _min?: AIBotSessionBindingMinOrderByAggregateInput
  }

  export type AIBotSessionBindingScalarWhereWithAggregatesInput = {
    AND?: AIBotSessionBindingScalarWhereWithAggregatesInput | AIBotSessionBindingScalarWhereWithAggregatesInput[]
    OR?: AIBotSessionBindingScalarWhereWithAggregatesInput[]
    NOT?: AIBotSessionBindingScalarWhereWithAggregatesInput | AIBotSessionBindingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIBotSessionBinding"> | string
    userId?: StringWithAggregatesFilter<"AIBotSessionBinding"> | string
    botId?: StringWithAggregatesFilter<"AIBotSessionBinding"> | string
    sessionId?: StringWithAggregatesFilter<"AIBotSessionBinding"> | string
    isActive?: BoolWithAggregatesFilter<"AIBotSessionBinding"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AIBotSessionBinding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIBotSessionBinding"> | Date | string
  }

  export type BotKnowledgeBindingWhereInput = {
    AND?: BotKnowledgeBindingWhereInput | BotKnowledgeBindingWhereInput[]
    OR?: BotKnowledgeBindingWhereInput[]
    NOT?: BotKnowledgeBindingWhereInput | BotKnowledgeBindingWhereInput[]
    id?: StringFilter<"BotKnowledgeBinding"> | string
    botId?: StringFilter<"BotKnowledgeBinding"> | string
    documentId?: StringFilter<"BotKnowledgeBinding"> | string
    isActive?: BoolFilter<"BotKnowledgeBinding"> | boolean
    createdAt?: DateTimeFilter<"BotKnowledgeBinding"> | Date | string
    updatedAt?: DateTimeFilter<"BotKnowledgeBinding"> | Date | string
    bot?: XOR<WhatsAppAIBotScalarRelationFilter, WhatsAppAIBotWhereInput>
    document?: XOR<AIDocumentScalarRelationFilter, AIDocumentWhereInput>
  }

  export type BotKnowledgeBindingOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    documentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bot?: WhatsAppAIBotOrderByWithRelationInput
    document?: AIDocumentOrderByWithRelationInput
  }

  export type BotKnowledgeBindingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    botId_documentId?: BotKnowledgeBindingBotIdDocumentIdCompoundUniqueInput
    AND?: BotKnowledgeBindingWhereInput | BotKnowledgeBindingWhereInput[]
    OR?: BotKnowledgeBindingWhereInput[]
    NOT?: BotKnowledgeBindingWhereInput | BotKnowledgeBindingWhereInput[]
    botId?: StringFilter<"BotKnowledgeBinding"> | string
    documentId?: StringFilter<"BotKnowledgeBinding"> | string
    isActive?: BoolFilter<"BotKnowledgeBinding"> | boolean
    createdAt?: DateTimeFilter<"BotKnowledgeBinding"> | Date | string
    updatedAt?: DateTimeFilter<"BotKnowledgeBinding"> | Date | string
    bot?: XOR<WhatsAppAIBotScalarRelationFilter, WhatsAppAIBotWhereInput>
    document?: XOR<AIDocumentScalarRelationFilter, AIDocumentWhereInput>
  }, "id" | "botId_documentId">

  export type BotKnowledgeBindingOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    documentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BotKnowledgeBindingCountOrderByAggregateInput
    _max?: BotKnowledgeBindingMaxOrderByAggregateInput
    _min?: BotKnowledgeBindingMinOrderByAggregateInput
  }

  export type BotKnowledgeBindingScalarWhereWithAggregatesInput = {
    AND?: BotKnowledgeBindingScalarWhereWithAggregatesInput | BotKnowledgeBindingScalarWhereWithAggregatesInput[]
    OR?: BotKnowledgeBindingScalarWhereWithAggregatesInput[]
    NOT?: BotKnowledgeBindingScalarWhereWithAggregatesInput | BotKnowledgeBindingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BotKnowledgeBinding"> | string
    botId?: StringWithAggregatesFilter<"BotKnowledgeBinding"> | string
    documentId?: StringWithAggregatesFilter<"BotKnowledgeBinding"> | string
    isActive?: BoolWithAggregatesFilter<"BotKnowledgeBinding"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BotKnowledgeBinding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BotKnowledgeBinding"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppSessionCreateInput = {
    id?: string
    sessionId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    sessionName: string
    connected?: boolean
    events?: string | null
    expiration?: number
    isSystemSession?: boolean
    jid?: string | null
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: string | null
    qrcode?: string | null
    s3AccessKey?: string | null
    s3Bucket?: string | null
    s3Enabled?: boolean
    s3Endpoint?: string | null
    s3MediaDelivery?: string | null
    s3PathStyle?: boolean
    s3PublicUrl?: string | null
    s3Region?: string | null
    s3RetentionDays?: number
    s3SecretKey?: string | null
    token: string
    webhook?: string | null
    autoReadMessages?: boolean
    typingIndicator?: boolean
    user?: UserCreateNestedOneWithoutWhatsAppSessionsInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutSessionInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    sessionName: string
    connected?: boolean
    events?: string | null
    expiration?: number
    isSystemSession?: boolean
    jid?: string | null
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: string | null
    qrcode?: string | null
    s3AccessKey?: string | null
    s3Bucket?: string | null
    s3Enabled?: boolean
    s3Endpoint?: string | null
    s3MediaDelivery?: string | null
    s3PathStyle?: boolean
    s3PublicUrl?: string | null
    s3Region?: string | null
    s3RetentionDays?: number
    s3SecretKey?: string | null
    token: string
    webhook?: string | null
    autoReadMessages?: boolean
    typingIndicator?: boolean
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutSessionInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutWhatsAppSessionsNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutSessionNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionCreateManyInput = {
    id?: string
    sessionId: string
    userId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    sessionName: string
    connected?: boolean
    events?: string | null
    expiration?: number
    isSystemSession?: boolean
    jid?: string | null
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: string | null
    qrcode?: string | null
    s3AccessKey?: string | null
    s3Bucket?: string | null
    s3Enabled?: boolean
    s3Endpoint?: string | null
    s3MediaDelivery?: string | null
    s3PathStyle?: boolean
    s3PublicUrl?: string | null
    s3Region?: string | null
    s3RetentionDays?: number
    s3SecretKey?: string | null
    token: string
    webhook?: string | null
    autoReadMessages?: boolean
    typingIndicator?: boolean
  }

  export type WhatsAppSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WhatsAppSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionCreateInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionWhatsappServiceCreateInput = {
    id?: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    transaction: TransactionCreateNestedOneWithoutWhatsappTransactionInput
    whatsappPackage: WhatsappApiPackageCreateNestedOneWithoutWhatsappTransactionsInput
  }

  export type TransactionWhatsappServiceUncheckedCreateInput = {
    id?: string
    transactionId: string
    whatsappPackageId: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionWhatsappServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUpdateOneRequiredWithoutWhatsappTransactionNestedInput
    whatsappPackage?: WhatsappApiPackageUpdateOneRequiredWithoutWhatsappTransactionsNestedInput
  }

  export type TransactionWhatsappServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    whatsappPackageId?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionWhatsappServiceCreateManyInput = {
    id?: string
    transactionId: string
    whatsappPackageId: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionWhatsappServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionWhatsappServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    whatsappPackageId?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    status?: string
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    externalId?: string | null
    paymentUrl?: string | null
    serviceFee?: Decimal | DecimalJsLike | number | string | null
    adminNotes?: string | null
    adminAction?: string | null
    adminUserId?: string | null
    actionDate?: Date | string | null
    gatewayProvider?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    transaction?: TransactionCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    transactionId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: string
    status?: string
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    externalId?: string | null
    paymentUrl?: string | null
    serviceFee?: Decimal | DecimalJsLike | number | string | null
    adminNotes?: string | null
    adminAction?: string | null
    adminUserId?: string | null
    actionDate?: Date | string | null
    gatewayProvider?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    transaction?: TransactionUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateManyInput = {
    id?: string
    transactionId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: string
    status?: string
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    externalId?: string | null
    paymentUrl?: string | null
    serviceFee?: Decimal | DecimalJsLike | number | string | null
    adminNotes?: string | null
    adminAction?: string | null
    adminUserId?: string | null
    actionDate?: Date | string | null
    gatewayProvider?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WhatsappApiPackageCreateInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutPackageInput
    whatsappTransactions?: TransactionWhatsappServiceCreateNestedManyWithoutWhatsappPackageInput
  }

  export type WhatsappApiPackageUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutPackageInput
    whatsappTransactions?: TransactionWhatsappServiceUncheckedCreateNestedManyWithoutWhatsappPackageInput
  }

  export type WhatsappApiPackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutPackageNestedInput
    whatsappTransactions?: TransactionWhatsappServiceUpdateManyWithoutWhatsappPackageNestedInput
  }

  export type WhatsappApiPackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutPackageNestedInput
    whatsappTransactions?: TransactionWhatsappServiceUncheckedUpdateManyWithoutWhatsappPackageNestedInput
  }

  export type WhatsappApiPackageCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappApiPackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappApiPackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersCreateInput = {
    id?: string
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string
    updatedAt?: Date | string
    lastSubscriptionAt?: Date | string
    customer: UserCreateNestedOneWithoutWhatsappCustomersInput
    package: WhatsappApiPackageCreateNestedOneWithoutWhatsappCustomersInput
  }

  export type ServicesWhatsappCustomersUncheckedCreateInput = {
    id?: string
    customerId: string
    packageId: string
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string
    updatedAt?: Date | string
    lastSubscriptionAt?: Date | string
  }

  export type ServicesWhatsappCustomersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSubscriptionAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutWhatsappCustomersNestedInput
    package?: WhatsappApiPackageUpdateOneRequiredWithoutWhatsappCustomersNestedInput
  }

  export type ServicesWhatsappCustomersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSubscriptionAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersCreateManyInput = {
    id?: string
    customerId: string
    packageId: string
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string
    updatedAt?: Date | string
    lastSubscriptionAt?: Date | string
  }

  export type ServicesWhatsappCustomersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSubscriptionAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSubscriptionAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    user: UserCreateNestedOneWithoutUserSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    userId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UserSessionUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionCreateManyInput = {
    userId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UserSessionUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutVoucherInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutVoucherInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutVoucherNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutVoucherNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageCreateInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    transaction?: TransactionCreateNestedOneWithoutVoucherUsageInput
    user: UserCreateNestedOneWithoutVoucherUsageInput
    voucher: VoucherCreateNestedOneWithoutVoucherUsageInput
  }

  export type VoucherUsageUncheckedCreateInput = {
    id?: string
    voucherId: string
    userId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: TransactionUpdateOneWithoutVoucherUsageNestedInput
    user?: UserUpdateOneRequiredWithoutVoucherUsageNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutVoucherUsageNestedInput
  }

  export type VoucherUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageCreateManyInput = {
    id?: string
    voucherId: string
    userId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    isActive?: boolean
    isSystem?: boolean
    gatewayProvider?: string | null
    gatewayCode?: string | null
    gatewayImageUrl?: string | null
    isGatewayMethod?: boolean
    feeType?: string | null
    feeValue?: Decimal | DecimalJsLike | number | string | null
    minFee?: Decimal | DecimalJsLike | number | string | null
    maxFee?: Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: boolean
    paymentInstructions?: string | null
    instructionType?: string | null
    instructionImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bankDetail?: BankDetailCreateNestedOneWithoutPaymentMethodsInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    isActive?: boolean
    isSystem?: boolean
    gatewayProvider?: string | null
    gatewayCode?: string | null
    gatewayImageUrl?: string | null
    isGatewayMethod?: boolean
    bankDetailId?: string | null
    feeType?: string | null
    feeValue?: Decimal | DecimalJsLike | number | string | null
    minFee?: Decimal | DecimalJsLike | number | string | null
    maxFee?: Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: boolean
    paymentInstructions?: string | null
    instructionType?: string | null
    instructionImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayCode?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGatewayMethod?: BoolFieldUpdateOperationsInput | boolean
    feeType?: NullableStringFieldUpdateOperationsInput | string | null
    feeValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankDetail?: BankDetailUpdateOneWithoutPaymentMethodsNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayCode?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGatewayMethod?: BoolFieldUpdateOperationsInput | boolean
    bankDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    feeType?: NullableStringFieldUpdateOperationsInput | string | null
    feeValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    isActive?: boolean
    isSystem?: boolean
    gatewayProvider?: string | null
    gatewayCode?: string | null
    gatewayImageUrl?: string | null
    isGatewayMethod?: boolean
    bankDetailId?: string | null
    feeType?: string | null
    feeValue?: Decimal | DecimalJsLike | number | string | null
    minFee?: Decimal | DecimalJsLike | number | string | null
    maxFee?: Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: boolean
    paymentInstructions?: string | null
    instructionType?: string | null
    instructionImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayCode?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGatewayMethod?: BoolFieldUpdateOperationsInput | boolean
    feeType?: NullableStringFieldUpdateOperationsInput | string | null
    feeValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayCode?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGatewayMethod?: BoolFieldUpdateOperationsInput | boolean
    bankDetailId?: NullableStringFieldUpdateOperationsInput | string | null
    feeType?: NullableStringFieldUpdateOperationsInput | string | null
    feeValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailCreateInput = {
    id?: string
    bankName: string
    accountNumber: string
    accountName: string
    swiftCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodCreateNestedManyWithoutBankDetailInput
  }

  export type BankDetailUncheckedCreateInput = {
    id?: string
    bankName: string
    accountNumber: string
    accountName: string
    swiftCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: PaymentMethodUncheckedCreateNestedManyWithoutBankDetailInput
  }

  export type BankDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodUpdateManyWithoutBankDetailNestedInput
  }

  export type BankDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: PaymentMethodUncheckedUpdateManyWithoutBankDetailNestedInput
  }

  export type BankDetailCreateManyInput = {
    id?: string
    bankName: string
    accountNumber: string
    accountName: string
    swiftCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppCampaignCreateInput = {
    id?: bigint | number
    name: string
    type: string
    status?: string | null
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutWhatsAppCampaignsInput
    User: UserCreateNestedOneWithoutWhatsAppCampaignsInput
  }

  export type WhatsAppCampaignUncheckedCreateInput = {
    id?: bigint | number
    user_id: string
    name: string
    type: string
    status?: string | null
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutWhatsAppCampaignsInput
  }

  export type WhatsAppCampaignUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutWhatsAppCampaignsNestedInput
    User?: UserUpdateOneRequiredWithoutWhatsAppCampaignsNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutWhatsAppCampaignsNestedInput
  }

  export type WhatsAppCampaignCreateManyInput = {
    id?: bigint | number
    user_id: string
    name: string
    type: string
    status?: string | null
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppCampaignUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppCampaignUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppBulkCampaignCreateInput = {
    id?: bigint | number
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemCreateNestedManyWithoutWhatsAppBulkCampaignsInput
    User: UserCreateNestedOneWithoutWhatsAppBulkCampaignsInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedOneWithoutWhatsAppBulkCampaignsInput
  }

  export type WhatsAppBulkCampaignUncheckedCreateInput = {
    id?: bigint | number
    user_id: string
    campaign_id?: bigint | number | null
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemUncheckedCreateNestedManyWithoutWhatsAppBulkCampaignsInput
  }

  export type WhatsAppBulkCampaignUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemUpdateManyWithoutWhatsAppBulkCampaignsNestedInput
    User?: UserUpdateOneRequiredWithoutWhatsAppBulkCampaignsNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateOneWithoutWhatsAppBulkCampaignsNestedInput
  }

  export type WhatsAppBulkCampaignUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemUncheckedUpdateManyWithoutWhatsAppBulkCampaignsNestedInput
  }

  export type WhatsAppBulkCampaignCreateManyInput = {
    id?: bigint | number
    user_id: string
    campaign_id?: bigint | number | null
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppBulkCampaignUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppBulkCampaignUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppBulkCampaignItemCreateInput = {
    id?: bigint | number
    phone: string
    status?: string | null
    message_id?: string | null
    error_message?: string | null
    sent_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaigns: WhatsAppBulkCampaignCreateNestedOneWithoutWhatsAppBulkCampaignItemsInput
  }

  export type WhatsAppBulkCampaignItemUncheckedCreateInput = {
    id?: bigint | number
    bulk_campaign_id: bigint | number
    phone: string
    status?: string | null
    message_id?: string | null
    error_message?: string | null
    sent_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppBulkCampaignItemUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateOneRequiredWithoutWhatsAppBulkCampaignItemsNestedInput
  }

  export type WhatsAppBulkCampaignItemUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    bulk_campaign_id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppBulkCampaignItemCreateManyInput = {
    id?: bigint | number
    bulk_campaign_id: bigint | number
    phone: string
    status?: string | null
    message_id?: string | null
    error_message?: string | null
    sent_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppBulkCampaignItemUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppBulkCampaignItemUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    bulk_campaign_id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppContactCreateInput = {
    id?: bigint | number
    phone: string
    name?: string | null
    full_name?: string | null
    push_name?: string | null
    short?: string | null
    notify?: string | null
    business?: boolean | null
    verified?: boolean | null
    source?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    User: UserCreateNestedOneWithoutWhatsAppContactInput
  }

  export type WhatsAppContactUncheckedCreateInput = {
    id?: bigint | number
    user_id: string
    phone: string
    name?: string | null
    full_name?: string | null
    push_name?: string | null
    short?: string | null
    notify?: string | null
    business?: boolean | null
    verified?: boolean | null
    source?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppContactUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    notify?: NullableStringFieldUpdateOperationsInput | string | null
    business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutWhatsAppContactNestedInput
  }

  export type WhatsAppContactUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    notify?: NullableStringFieldUpdateOperationsInput | string | null
    business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppContactCreateManyInput = {
    id?: bigint | number
    user_id: string
    phone: string
    name?: string | null
    full_name?: string | null
    push_name?: string | null
    short?: string | null
    notify?: string | null
    business?: boolean | null
    verified?: boolean | null
    source?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppContactUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    notify?: NullableStringFieldUpdateOperationsInput | string | null
    business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppContactUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    notify?: NullableStringFieldUpdateOperationsInput | string | null
    business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppMessageStatsCreateInput = {
    id?: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    textMessagesSent?: number
    textMessagesFailed?: number
    imageMessagesSent?: number
    imageMessagesFailed?: number
    documentMessagesSent?: number
    documentMessagesFailed?: number
    audioMessagesSent?: number
    audioMessagesFailed?: number
    stickerMessagesSent?: number
    stickerMessagesFailed?: number
    videoMessagesSent?: number
    videoMessagesFailed?: number
    locationMessagesSent?: number
    locationMessagesFailed?: number
    contactMessagesSent?: number
    contactMessagesFailed?: number
    templateMessagesSent?: number
    templateMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWhatsAppMessageStatsInput
    session: WhatsAppSessionCreateNestedOneWithoutWhatsAppMessageStatsInput
  }

  export type WhatsAppMessageStatsUncheckedCreateInput = {
    id?: string
    userId: string
    sessionId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    textMessagesSent?: number
    textMessagesFailed?: number
    imageMessagesSent?: number
    imageMessagesFailed?: number
    documentMessagesSent?: number
    documentMessagesFailed?: number
    audioMessagesSent?: number
    audioMessagesFailed?: number
    stickerMessagesSent?: number
    stickerMessagesFailed?: number
    videoMessagesSent?: number
    videoMessagesFailed?: number
    locationMessagesSent?: number
    locationMessagesFailed?: number
    contactMessagesSent?: number
    contactMessagesFailed?: number
    templateMessagesSent?: number
    templateMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    textMessagesSent?: IntFieldUpdateOperationsInput | number
    textMessagesFailed?: IntFieldUpdateOperationsInput | number
    imageMessagesSent?: IntFieldUpdateOperationsInput | number
    imageMessagesFailed?: IntFieldUpdateOperationsInput | number
    documentMessagesSent?: IntFieldUpdateOperationsInput | number
    documentMessagesFailed?: IntFieldUpdateOperationsInput | number
    audioMessagesSent?: IntFieldUpdateOperationsInput | number
    audioMessagesFailed?: IntFieldUpdateOperationsInput | number
    stickerMessagesSent?: IntFieldUpdateOperationsInput | number
    stickerMessagesFailed?: IntFieldUpdateOperationsInput | number
    videoMessagesSent?: IntFieldUpdateOperationsInput | number
    videoMessagesFailed?: IntFieldUpdateOperationsInput | number
    locationMessagesSent?: IntFieldUpdateOperationsInput | number
    locationMessagesFailed?: IntFieldUpdateOperationsInput | number
    contactMessagesSent?: IntFieldUpdateOperationsInput | number
    contactMessagesFailed?: IntFieldUpdateOperationsInput | number
    templateMessagesSent?: IntFieldUpdateOperationsInput | number
    templateMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWhatsAppMessageStatsNestedInput
    session?: WhatsAppSessionUpdateOneRequiredWithoutWhatsAppMessageStatsNestedInput
  }

  export type WhatsAppMessageStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    textMessagesSent?: IntFieldUpdateOperationsInput | number
    textMessagesFailed?: IntFieldUpdateOperationsInput | number
    imageMessagesSent?: IntFieldUpdateOperationsInput | number
    imageMessagesFailed?: IntFieldUpdateOperationsInput | number
    documentMessagesSent?: IntFieldUpdateOperationsInput | number
    documentMessagesFailed?: IntFieldUpdateOperationsInput | number
    audioMessagesSent?: IntFieldUpdateOperationsInput | number
    audioMessagesFailed?: IntFieldUpdateOperationsInput | number
    stickerMessagesSent?: IntFieldUpdateOperationsInput | number
    stickerMessagesFailed?: IntFieldUpdateOperationsInput | number
    videoMessagesSent?: IntFieldUpdateOperationsInput | number
    videoMessagesFailed?: IntFieldUpdateOperationsInput | number
    locationMessagesSent?: IntFieldUpdateOperationsInput | number
    locationMessagesFailed?: IntFieldUpdateOperationsInput | number
    contactMessagesSent?: IntFieldUpdateOperationsInput | number
    contactMessagesFailed?: IntFieldUpdateOperationsInput | number
    templateMessagesSent?: IntFieldUpdateOperationsInput | number
    templateMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsCreateManyInput = {
    id?: string
    userId: string
    sessionId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    textMessagesSent?: number
    textMessagesFailed?: number
    imageMessagesSent?: number
    imageMessagesFailed?: number
    documentMessagesSent?: number
    documentMessagesFailed?: number
    audioMessagesSent?: number
    audioMessagesFailed?: number
    stickerMessagesSent?: number
    stickerMessagesFailed?: number
    videoMessagesSent?: number
    videoMessagesFailed?: number
    locationMessagesSent?: number
    locationMessagesFailed?: number
    contactMessagesSent?: number
    contactMessagesFailed?: number
    templateMessagesSent?: number
    templateMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    textMessagesSent?: IntFieldUpdateOperationsInput | number
    textMessagesFailed?: IntFieldUpdateOperationsInput | number
    imageMessagesSent?: IntFieldUpdateOperationsInput | number
    imageMessagesFailed?: IntFieldUpdateOperationsInput | number
    documentMessagesSent?: IntFieldUpdateOperationsInput | number
    documentMessagesFailed?: IntFieldUpdateOperationsInput | number
    audioMessagesSent?: IntFieldUpdateOperationsInput | number
    audioMessagesFailed?: IntFieldUpdateOperationsInput | number
    stickerMessagesSent?: IntFieldUpdateOperationsInput | number
    stickerMessagesFailed?: IntFieldUpdateOperationsInput | number
    videoMessagesSent?: IntFieldUpdateOperationsInput | number
    videoMessagesFailed?: IntFieldUpdateOperationsInput | number
    locationMessagesSent?: IntFieldUpdateOperationsInput | number
    locationMessagesFailed?: IntFieldUpdateOperationsInput | number
    contactMessagesSent?: IntFieldUpdateOperationsInput | number
    contactMessagesFailed?: IntFieldUpdateOperationsInput | number
    templateMessagesSent?: IntFieldUpdateOperationsInput | number
    templateMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    textMessagesSent?: IntFieldUpdateOperationsInput | number
    textMessagesFailed?: IntFieldUpdateOperationsInput | number
    imageMessagesSent?: IntFieldUpdateOperationsInput | number
    imageMessagesFailed?: IntFieldUpdateOperationsInput | number
    documentMessagesSent?: IntFieldUpdateOperationsInput | number
    documentMessagesFailed?: IntFieldUpdateOperationsInput | number
    audioMessagesSent?: IntFieldUpdateOperationsInput | number
    audioMessagesFailed?: IntFieldUpdateOperationsInput | number
    stickerMessagesSent?: IntFieldUpdateOperationsInput | number
    stickerMessagesFailed?: IntFieldUpdateOperationsInput | number
    videoMessagesSent?: IntFieldUpdateOperationsInput | number
    videoMessagesFailed?: IntFieldUpdateOperationsInput | number
    locationMessagesSent?: IntFieldUpdateOperationsInput | number
    locationMessagesFailed?: IntFieldUpdateOperationsInput | number
    contactMessagesSent?: IntFieldUpdateOperationsInput | number
    contactMessagesFailed?: IntFieldUpdateOperationsInput | number
    templateMessagesSent?: IntFieldUpdateOperationsInput | number
    templateMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppAIBotCreateInput = {
    id?: string
    name?: string
    isActive?: boolean
    systemPrompt?: string | null
    fallbackText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWhatsAppAIBotsInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutBotInput
    botKnowledgeBindings?: BotKnowledgeBindingCreateNestedManyWithoutBotInput
  }

  export type WhatsAppAIBotUncheckedCreateInput = {
    id?: string
    userId: string
    name?: string
    isActive?: boolean
    systemPrompt?: string | null
    fallbackText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutBotInput
    botKnowledgeBindings?: BotKnowledgeBindingUncheckedCreateNestedManyWithoutBotInput
  }

  export type WhatsAppAIBotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWhatsAppAIBotsNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutBotNestedInput
    botKnowledgeBindings?: BotKnowledgeBindingUpdateManyWithoutBotNestedInput
  }

  export type WhatsAppAIBotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutBotNestedInput
    botKnowledgeBindings?: BotKnowledgeBindingUncheckedUpdateManyWithoutBotNestedInput
  }

  export type WhatsAppAIBotCreateManyInput = {
    id?: string
    userId: string
    name?: string
    isActive?: boolean
    systemPrompt?: string | null
    fallbackText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppAIBotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppAIBotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDocumentCreateInput = {
    id?: string
    title: string
    kind?: string
    content: string
    embeddingId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAiDocumentsInput
    botKnowledgeBindings?: BotKnowledgeBindingCreateNestedManyWithoutDocumentInput
  }

  export type AIDocumentUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    kind?: string
    content: string
    embeddingId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    botKnowledgeBindings?: BotKnowledgeBindingUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type AIDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiDocumentsNestedInput
    botKnowledgeBindings?: BotKnowledgeBindingUpdateManyWithoutDocumentNestedInput
  }

  export type AIDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    botKnowledgeBindings?: BotKnowledgeBindingUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type AIDocumentCreateManyInput = {
    id?: string
    userId: string
    title: string
    kind?: string
    content: string
    embeddingId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogCreateInput = {
    id?: string
    sessionId?: string | null
    inputTokens?: number
    outputTokens?: number
    totalTokens?: number
    latencyMs?: number
    status?: string
    errorReason?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAiUsageLogsInput
  }

  export type AIUsageLogUncheckedCreateInput = {
    id?: string
    userId: string
    sessionId?: string | null
    inputTokens?: number
    outputTokens?: number
    totalTokens?: number
    latencyMs?: number
    status?: string
    errorReason?: string | null
    createdAt?: Date | string
  }

  export type AIUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiUsageLogsNestedInput
  }

  export type AIUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogCreateManyInput = {
    id?: string
    userId: string
    sessionId?: string | null
    inputTokens?: number
    outputTokens?: number
    totalTokens?: number
    latencyMs?: number
    status?: string
    errorReason?: string | null
    createdAt?: Date | string
  }

  export type AIUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIBotSessionBindingCreateInput = {
    id?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: WhatsAppAIBotCreateNestedOneWithoutAiBotSessionBindingsInput
    user: UserCreateNestedOneWithoutAiBotSessionBindingsInput
    session: WhatsAppSessionCreateNestedOneWithoutAiBotSessionBindingsInput
  }

  export type AIBotSessionBindingUncheckedCreateInput = {
    id?: string
    userId: string
    botId: string
    sessionId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIBotSessionBindingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: WhatsAppAIBotUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput
    user?: UserUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput
    session?: WhatsAppSessionUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput
  }

  export type AIBotSessionBindingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIBotSessionBindingCreateManyInput = {
    id?: string
    userId: string
    botId: string
    sessionId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIBotSessionBindingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIBotSessionBindingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotKnowledgeBindingCreateInput = {
    id?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: WhatsAppAIBotCreateNestedOneWithoutBotKnowledgeBindingsInput
    document: AIDocumentCreateNestedOneWithoutBotKnowledgeBindingsInput
  }

  export type BotKnowledgeBindingUncheckedCreateInput = {
    id?: string
    botId: string
    documentId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotKnowledgeBindingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: WhatsAppAIBotUpdateOneRequiredWithoutBotKnowledgeBindingsNestedInput
    document?: AIDocumentUpdateOneRequiredWithoutBotKnowledgeBindingsNestedInput
  }

  export type BotKnowledgeBindingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotKnowledgeBindingCreateManyInput = {
    id?: string
    botId: string
    documentId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotKnowledgeBindingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotKnowledgeBindingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ServicesWhatsappCustomersListRelationFilter = {
    every?: ServicesWhatsappCustomersWhereInput
    some?: ServicesWhatsappCustomersWhereInput
    none?: ServicesWhatsappCustomersWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type VoucherUsageListRelationFilter = {
    every?: VoucherUsageWhereInput
    some?: VoucherUsageWhereInput
    none?: VoucherUsageWhereInput
  }

  export type WhatsAppBulkCampaignListRelationFilter = {
    every?: WhatsAppBulkCampaignWhereInput
    some?: WhatsAppBulkCampaignWhereInput
    none?: WhatsAppBulkCampaignWhereInput
  }

  export type WhatsAppCampaignListRelationFilter = {
    every?: WhatsAppCampaignWhereInput
    some?: WhatsAppCampaignWhereInput
    none?: WhatsAppCampaignWhereInput
  }

  export type WhatsAppContactListRelationFilter = {
    every?: WhatsAppContactWhereInput
    some?: WhatsAppContactWhereInput
    none?: WhatsAppContactWhereInput
  }

  export type WhatsAppSessionListRelationFilter = {
    every?: WhatsAppSessionWhereInput
    some?: WhatsAppSessionWhereInput
    none?: WhatsAppSessionWhereInput
  }

  export type WhatsAppMessageStatsListRelationFilter = {
    every?: WhatsAppMessageStatsWhereInput
    some?: WhatsAppMessageStatsWhereInput
    none?: WhatsAppMessageStatsWhereInput
  }

  export type WhatsAppAIBotListRelationFilter = {
    every?: WhatsAppAIBotWhereInput
    some?: WhatsAppAIBotWhereInput
    none?: WhatsAppAIBotWhereInput
  }

  export type AIDocumentListRelationFilter = {
    every?: AIDocumentWhereInput
    some?: AIDocumentWhereInput
    none?: AIDocumentWhereInput
  }

  export type AIUsageLogListRelationFilter = {
    every?: AIUsageLogWhereInput
    some?: AIUsageLogWhereInput
    none?: AIUsageLogWhereInput
  }

  export type AIBotSessionBindingListRelationFilter = {
    every?: AIBotSessionBindingWhereInput
    some?: AIBotSessionBindingWhereInput
    none?: AIBotSessionBindingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ServicesWhatsappCustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppBulkCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppMessageStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppAIBotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIBotSessionBindingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    otp?: SortOrder
    otpExpires?: SortOrder
    otpVerificationDeadline?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    image?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationTokenExpires?: SortOrder
    role?: SortOrder
    apiKey?: SortOrder
    updatedAt?: SortOrder
    emailOtp?: SortOrder
    emailOtpExpires?: SortOrder
    resetPasswordOtp?: SortOrder
    resetPasswordOtpExpires?: SortOrder
    resetPasswordLastRequestAt?: SortOrder
    ssoOtp?: SortOrder
    ssoOtpExpires?: SortOrder
    ssoLastRequestAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    otp?: SortOrder
    otpExpires?: SortOrder
    otpVerificationDeadline?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    image?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationTokenExpires?: SortOrder
    role?: SortOrder
    apiKey?: SortOrder
    updatedAt?: SortOrder
    emailOtp?: SortOrder
    emailOtpExpires?: SortOrder
    resetPasswordOtp?: SortOrder
    resetPasswordOtpExpires?: SortOrder
    resetPasswordLastRequestAt?: SortOrder
    ssoOtp?: SortOrder
    ssoOtpExpires?: SortOrder
    ssoLastRequestAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    otp?: SortOrder
    otpExpires?: SortOrder
    otpVerificationDeadline?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    image?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationTokenExpires?: SortOrder
    role?: SortOrder
    apiKey?: SortOrder
    updatedAt?: SortOrder
    emailOtp?: SortOrder
    emailOtpExpires?: SortOrder
    resetPasswordOtp?: SortOrder
    resetPasswordOtpExpires?: SortOrder
    resetPasswordLastRequestAt?: SortOrder
    ssoOtp?: SortOrder
    ssoOtpExpires?: SortOrder
    ssoLastRequestAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type WhatsAppSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    message?: SortOrder
    sessionName?: SortOrder
    connected?: SortOrder
    events?: SortOrder
    expiration?: SortOrder
    isSystemSession?: SortOrder
    jid?: SortOrder
    loggedIn?: SortOrder
    proxyEnabled?: SortOrder
    proxyUrl?: SortOrder
    qrcode?: SortOrder
    s3AccessKey?: SortOrder
    s3Bucket?: SortOrder
    s3Enabled?: SortOrder
    s3Endpoint?: SortOrder
    s3MediaDelivery?: SortOrder
    s3PathStyle?: SortOrder
    s3PublicUrl?: SortOrder
    s3Region?: SortOrder
    s3RetentionDays?: SortOrder
    s3SecretKey?: SortOrder
    token?: SortOrder
    webhook?: SortOrder
    autoReadMessages?: SortOrder
    typingIndicator?: SortOrder
  }

  export type WhatsAppSessionAvgOrderByAggregateInput = {
    expiration?: SortOrder
    s3RetentionDays?: SortOrder
  }

  export type WhatsAppSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    message?: SortOrder
    sessionName?: SortOrder
    connected?: SortOrder
    events?: SortOrder
    expiration?: SortOrder
    isSystemSession?: SortOrder
    jid?: SortOrder
    loggedIn?: SortOrder
    proxyEnabled?: SortOrder
    proxyUrl?: SortOrder
    qrcode?: SortOrder
    s3AccessKey?: SortOrder
    s3Bucket?: SortOrder
    s3Enabled?: SortOrder
    s3Endpoint?: SortOrder
    s3MediaDelivery?: SortOrder
    s3PathStyle?: SortOrder
    s3PublicUrl?: SortOrder
    s3Region?: SortOrder
    s3RetentionDays?: SortOrder
    s3SecretKey?: SortOrder
    token?: SortOrder
    webhook?: SortOrder
    autoReadMessages?: SortOrder
    typingIndicator?: SortOrder
  }

  export type WhatsAppSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    message?: SortOrder
    sessionName?: SortOrder
    connected?: SortOrder
    events?: SortOrder
    expiration?: SortOrder
    isSystemSession?: SortOrder
    jid?: SortOrder
    loggedIn?: SortOrder
    proxyEnabled?: SortOrder
    proxyUrl?: SortOrder
    qrcode?: SortOrder
    s3AccessKey?: SortOrder
    s3Bucket?: SortOrder
    s3Enabled?: SortOrder
    s3Endpoint?: SortOrder
    s3MediaDelivery?: SortOrder
    s3PathStyle?: SortOrder
    s3PublicUrl?: SortOrder
    s3Region?: SortOrder
    s3RetentionDays?: SortOrder
    s3SecretKey?: SortOrder
    token?: SortOrder
    webhook?: SortOrder
    autoReadMessages?: SortOrder
    typingIndicator?: SortOrder
  }

  export type WhatsAppSessionSumOrderByAggregateInput = {
    expiration?: SortOrder
    s3RetentionDays?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VoucherNullableScalarRelationFilter = {
    is?: VoucherWhereInput | null
    isNot?: VoucherWhereInput | null
  }

  export type TransactionWhatsappServiceNullableScalarRelationFilter = {
    is?: TransactionWhatsappServiceWhereInput | null
    isNot?: TransactionWhatsappServiceWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    discountAmount?: SortOrder
    originalAmount?: SortOrder
    voucherId?: SortOrder
    notes?: SortOrder
    currency?: SortOrder
    finalAmount?: SortOrder
    serviceFeeAmount?: SortOrder
    totalAfterDiscount?: SortOrder
    expiresAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    discountAmount?: SortOrder
    originalAmount?: SortOrder
    finalAmount?: SortOrder
    serviceFeeAmount?: SortOrder
    totalAfterDiscount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    discountAmount?: SortOrder
    originalAmount?: SortOrder
    voucherId?: SortOrder
    notes?: SortOrder
    currency?: SortOrder
    finalAmount?: SortOrder
    serviceFeeAmount?: SortOrder
    totalAfterDiscount?: SortOrder
    expiresAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    discountAmount?: SortOrder
    originalAmount?: SortOrder
    voucherId?: SortOrder
    notes?: SortOrder
    currency?: SortOrder
    finalAmount?: SortOrder
    serviceFeeAmount?: SortOrder
    totalAfterDiscount?: SortOrder
    expiresAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    discountAmount?: SortOrder
    originalAmount?: SortOrder
    finalAmount?: SortOrder
    serviceFeeAmount?: SortOrder
    totalAfterDiscount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type WhatsappApiPackageScalarRelationFilter = {
    is?: WhatsappApiPackageWhereInput
    isNot?: WhatsappApiPackageWhereInput
  }

  export type TransactionWhatsappServiceCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    whatsappPackageId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TransactionWhatsappServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    whatsappPackageId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TransactionWhatsappServiceMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    whatsappPackageId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    externalId?: SortOrder
    paymentUrl?: SortOrder
    serviceFee?: SortOrder
    adminNotes?: SortOrder
    adminAction?: SortOrder
    adminUserId?: SortOrder
    actionDate?: SortOrder
    gatewayProvider?: SortOrder
    gatewayResponse?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    serviceFee?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    externalId?: SortOrder
    paymentUrl?: SortOrder
    serviceFee?: SortOrder
    adminNotes?: SortOrder
    adminAction?: SortOrder
    adminUserId?: SortOrder
    actionDate?: SortOrder
    gatewayProvider?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    externalId?: SortOrder
    paymentUrl?: SortOrder
    serviceFee?: SortOrder
    adminNotes?: SortOrder
    adminAction?: SortOrder
    adminUserId?: SortOrder
    actionDate?: SortOrder
    gatewayProvider?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    serviceFee?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type TransactionWhatsappServiceListRelationFilter = {
    every?: TransactionWhatsappServiceWhereInput
    some?: TransactionWhatsappServiceWhereInput
    none?: TransactionWhatsappServiceWhereInput
  }

  export type TransactionWhatsappServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsappApiPackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappApiPackageAvgOrderByAggregateInput = {
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
  }

  export type WhatsappApiPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappApiPackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappApiPackageSumOrderByAggregateInput = {
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
  }

  export type ServicesWhatsappCustomersCustomerIdPackageIdCompoundUniqueInput = {
    customerId: string
    packageId: string
  }

  export type ServicesWhatsappCustomersCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    status?: SortOrder
    expiredAt?: SortOrder
    activatedAt?: SortOrder
    updatedAt?: SortOrder
    lastSubscriptionAt?: SortOrder
  }

  export type ServicesWhatsappCustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    status?: SortOrder
    expiredAt?: SortOrder
    activatedAt?: SortOrder
    updatedAt?: SortOrder
    lastSubscriptionAt?: SortOrder
  }

  export type ServicesWhatsappCustomersMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    status?: SortOrder
    expiredAt?: SortOrder
    activatedAt?: SortOrder
    updatedAt?: SortOrder
    lastSubscriptionAt?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VoucherCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    allowMultipleUsePerUser?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherAvgOrderByAggregateInput = {
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
  }

  export type VoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    allowMultipleUsePerUser?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    allowMultipleUsePerUser?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherSumOrderByAggregateInput = {
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type VoucherScalarRelationFilter = {
    is?: VoucherWhereInput
    isNot?: VoucherWhereInput
  }

  export type VoucherUsageCountOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type VoucherUsageAvgOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type VoucherUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type VoucherUsageMinOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type VoucherUsageSumOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type BankDetailNullableScalarRelationFilter = {
    is?: BankDetailWhereInput | null
    isNot?: BankDetailWhereInput | null
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    gatewayProvider?: SortOrder
    gatewayCode?: SortOrder
    gatewayImageUrl?: SortOrder
    isGatewayMethod?: SortOrder
    bankDetailId?: SortOrder
    feeType?: SortOrder
    feeValue?: SortOrder
    minFee?: SortOrder
    maxFee?: SortOrder
    requiresManualApproval?: SortOrder
    paymentInstructions?: SortOrder
    instructionType?: SortOrder
    instructionImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    feeValue?: SortOrder
    minFee?: SortOrder
    maxFee?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    gatewayProvider?: SortOrder
    gatewayCode?: SortOrder
    gatewayImageUrl?: SortOrder
    isGatewayMethod?: SortOrder
    bankDetailId?: SortOrder
    feeType?: SortOrder
    feeValue?: SortOrder
    minFee?: SortOrder
    maxFee?: SortOrder
    requiresManualApproval?: SortOrder
    paymentInstructions?: SortOrder
    instructionType?: SortOrder
    instructionImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    isSystem?: SortOrder
    gatewayProvider?: SortOrder
    gatewayCode?: SortOrder
    gatewayImageUrl?: SortOrder
    isGatewayMethod?: SortOrder
    bankDetailId?: SortOrder
    feeType?: SortOrder
    feeValue?: SortOrder
    minFee?: SortOrder
    maxFee?: SortOrder
    requiresManualApproval?: SortOrder
    paymentInstructions?: SortOrder
    instructionType?: SortOrder
    instructionImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    feeValue?: SortOrder
    minFee?: SortOrder
    maxFee?: SortOrder
  }

  export type PaymentMethodListRelationFilter = {
    every?: PaymentMethodWhereInput
    some?: PaymentMethodWhereInput
    none?: PaymentMethodWhereInput
  }

  export type PaymentMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankDetailCountOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    swiftCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    swiftCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailMinOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    swiftCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type WhatsAppCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    message_body?: SortOrder
    image_url?: SortOrder
    image_base64?: SortOrder
    caption?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppCampaignAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WhatsAppCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    message_body?: SortOrder
    image_url?: SortOrder
    image_base64?: SortOrder
    caption?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    message_body?: SortOrder
    image_url?: SortOrder
    image_base64?: SortOrder
    caption?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppCampaignSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type WhatsAppBulkCampaignItemListRelationFilter = {
    every?: WhatsAppBulkCampaignItemWhereInput
    some?: WhatsAppBulkCampaignItemWhereInput
    none?: WhatsAppBulkCampaignItemWhereInput
  }

  export type WhatsAppCampaignNullableScalarRelationFilter = {
    is?: WhatsAppCampaignWhereInput | null
    isNot?: WhatsAppCampaignWhereInput | null
  }

  export type WhatsAppBulkCampaignItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppBulkCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    campaign_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    message_body?: SortOrder
    image_url?: SortOrder
    image_base64?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    total_count?: SortOrder
    sent_count?: SortOrder
    failed_count?: SortOrder
    scheduled_at?: SortOrder
    timezone?: SortOrder
    processed_at?: SortOrder
    completed_at?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppBulkCampaignAvgOrderByAggregateInput = {
    id?: SortOrder
    campaign_id?: SortOrder
    total_count?: SortOrder
    sent_count?: SortOrder
    failed_count?: SortOrder
  }

  export type WhatsAppBulkCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    campaign_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    message_body?: SortOrder
    image_url?: SortOrder
    image_base64?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    total_count?: SortOrder
    sent_count?: SortOrder
    failed_count?: SortOrder
    scheduled_at?: SortOrder
    timezone?: SortOrder
    processed_at?: SortOrder
    completed_at?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppBulkCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    campaign_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    message_body?: SortOrder
    image_url?: SortOrder
    image_base64?: SortOrder
    caption?: SortOrder
    status?: SortOrder
    total_count?: SortOrder
    sent_count?: SortOrder
    failed_count?: SortOrder
    scheduled_at?: SortOrder
    timezone?: SortOrder
    processed_at?: SortOrder
    completed_at?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppBulkCampaignSumOrderByAggregateInput = {
    id?: SortOrder
    campaign_id?: SortOrder
    total_count?: SortOrder
    sent_count?: SortOrder
    failed_count?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type WhatsAppBulkCampaignScalarRelationFilter = {
    is?: WhatsAppBulkCampaignWhereInput
    isNot?: WhatsAppBulkCampaignWhereInput
  }

  export type WhatsAppBulkCampaignItemCountOrderByAggregateInput = {
    id?: SortOrder
    bulk_campaign_id?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    message_id?: SortOrder
    error_message?: SortOrder
    sent_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppBulkCampaignItemAvgOrderByAggregateInput = {
    id?: SortOrder
    bulk_campaign_id?: SortOrder
  }

  export type WhatsAppBulkCampaignItemMaxOrderByAggregateInput = {
    id?: SortOrder
    bulk_campaign_id?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    message_id?: SortOrder
    error_message?: SortOrder
    sent_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppBulkCampaignItemMinOrderByAggregateInput = {
    id?: SortOrder
    bulk_campaign_id?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    message_id?: SortOrder
    error_message?: SortOrder
    sent_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppBulkCampaignItemSumOrderByAggregateInput = {
    id?: SortOrder
    bulk_campaign_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type WhatsAppContactCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    full_name?: SortOrder
    push_name?: SortOrder
    short?: SortOrder
    notify?: SortOrder
    business?: SortOrder
    verified?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppContactAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WhatsAppContactMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    full_name?: SortOrder
    push_name?: SortOrder
    short?: SortOrder
    notify?: SortOrder
    business?: SortOrder
    verified?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppContactMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    full_name?: SortOrder
    push_name?: SortOrder
    short?: SortOrder
    notify?: SortOrder
    business?: SortOrder
    verified?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type WhatsAppContactSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type WhatsAppSessionScalarRelationFilter = {
    is?: WhatsAppSessionWhereInput
    isNot?: WhatsAppSessionWhereInput
  }

  export type WhatsAppMessageStatsUserIdSessionIdCompoundUniqueInput = {
    userId: string
    sessionId: string
  }

  export type WhatsAppMessageStatsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    textMessagesSent?: SortOrder
    textMessagesFailed?: SortOrder
    imageMessagesSent?: SortOrder
    imageMessagesFailed?: SortOrder
    documentMessagesSent?: SortOrder
    documentMessagesFailed?: SortOrder
    audioMessagesSent?: SortOrder
    audioMessagesFailed?: SortOrder
    stickerMessagesSent?: SortOrder
    stickerMessagesFailed?: SortOrder
    videoMessagesSent?: SortOrder
    videoMessagesFailed?: SortOrder
    locationMessagesSent?: SortOrder
    locationMessagesFailed?: SortOrder
    contactMessagesSent?: SortOrder
    contactMessagesFailed?: SortOrder
    templateMessagesSent?: SortOrder
    templateMessagesFailed?: SortOrder
    lastMessageSentAt?: SortOrder
    lastMessageFailedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppMessageStatsAvgOrderByAggregateInput = {
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    textMessagesSent?: SortOrder
    textMessagesFailed?: SortOrder
    imageMessagesSent?: SortOrder
    imageMessagesFailed?: SortOrder
    documentMessagesSent?: SortOrder
    documentMessagesFailed?: SortOrder
    audioMessagesSent?: SortOrder
    audioMessagesFailed?: SortOrder
    stickerMessagesSent?: SortOrder
    stickerMessagesFailed?: SortOrder
    videoMessagesSent?: SortOrder
    videoMessagesFailed?: SortOrder
    locationMessagesSent?: SortOrder
    locationMessagesFailed?: SortOrder
    contactMessagesSent?: SortOrder
    contactMessagesFailed?: SortOrder
    templateMessagesSent?: SortOrder
    templateMessagesFailed?: SortOrder
  }

  export type WhatsAppMessageStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    textMessagesSent?: SortOrder
    textMessagesFailed?: SortOrder
    imageMessagesSent?: SortOrder
    imageMessagesFailed?: SortOrder
    documentMessagesSent?: SortOrder
    documentMessagesFailed?: SortOrder
    audioMessagesSent?: SortOrder
    audioMessagesFailed?: SortOrder
    stickerMessagesSent?: SortOrder
    stickerMessagesFailed?: SortOrder
    videoMessagesSent?: SortOrder
    videoMessagesFailed?: SortOrder
    locationMessagesSent?: SortOrder
    locationMessagesFailed?: SortOrder
    contactMessagesSent?: SortOrder
    contactMessagesFailed?: SortOrder
    templateMessagesSent?: SortOrder
    templateMessagesFailed?: SortOrder
    lastMessageSentAt?: SortOrder
    lastMessageFailedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppMessageStatsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    textMessagesSent?: SortOrder
    textMessagesFailed?: SortOrder
    imageMessagesSent?: SortOrder
    imageMessagesFailed?: SortOrder
    documentMessagesSent?: SortOrder
    documentMessagesFailed?: SortOrder
    audioMessagesSent?: SortOrder
    audioMessagesFailed?: SortOrder
    stickerMessagesSent?: SortOrder
    stickerMessagesFailed?: SortOrder
    videoMessagesSent?: SortOrder
    videoMessagesFailed?: SortOrder
    locationMessagesSent?: SortOrder
    locationMessagesFailed?: SortOrder
    contactMessagesSent?: SortOrder
    contactMessagesFailed?: SortOrder
    templateMessagesSent?: SortOrder
    templateMessagesFailed?: SortOrder
    lastMessageSentAt?: SortOrder
    lastMessageFailedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppMessageStatsSumOrderByAggregateInput = {
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    textMessagesSent?: SortOrder
    textMessagesFailed?: SortOrder
    imageMessagesSent?: SortOrder
    imageMessagesFailed?: SortOrder
    documentMessagesSent?: SortOrder
    documentMessagesFailed?: SortOrder
    audioMessagesSent?: SortOrder
    audioMessagesFailed?: SortOrder
    stickerMessagesSent?: SortOrder
    stickerMessagesFailed?: SortOrder
    videoMessagesSent?: SortOrder
    videoMessagesFailed?: SortOrder
    locationMessagesSent?: SortOrder
    locationMessagesFailed?: SortOrder
    contactMessagesSent?: SortOrder
    contactMessagesFailed?: SortOrder
    templateMessagesSent?: SortOrder
    templateMessagesFailed?: SortOrder
  }

  export type BotKnowledgeBindingListRelationFilter = {
    every?: BotKnowledgeBindingWhereInput
    some?: BotKnowledgeBindingWhereInput
    none?: BotKnowledgeBindingWhereInput
  }

  export type BotKnowledgeBindingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppAIBotCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    systemPrompt?: SortOrder
    fallbackText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppAIBotMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    systemPrompt?: SortOrder
    fallbackText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppAIBotMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    systemPrompt?: SortOrder
    fallbackText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    kind?: SortOrder
    content?: SortOrder
    embeddingId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    kind?: SortOrder
    content?: SortOrder
    embeddingId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    kind?: SortOrder
    content?: SortOrder
    embeddingId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
    status?: SortOrder
    errorReason?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageLogAvgOrderByAggregateInput = {
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
  }

  export type AIUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
    status?: SortOrder
    errorReason?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
    status?: SortOrder
    errorReason?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageLogSumOrderByAggregateInput = {
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    latencyMs?: SortOrder
  }

  export type WhatsAppAIBotScalarRelationFilter = {
    is?: WhatsAppAIBotWhereInput
    isNot?: WhatsAppAIBotWhereInput
  }

  export type AIBotSessionBindingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    sessionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIBotSessionBindingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    sessionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIBotSessionBindingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    botId?: SortOrder
    sessionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIDocumentScalarRelationFilter = {
    is?: AIDocumentWhereInput
    isNot?: AIDocumentWhereInput
  }

  export type BotKnowledgeBindingBotIdDocumentIdCompoundUniqueInput = {
    botId: string
    documentId: string
  }

  export type BotKnowledgeBindingCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    documentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotKnowledgeBindingMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    documentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotKnowledgeBindingMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    documentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput> | ServicesWhatsappCustomersCreateWithoutCustomerInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput | ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput[]
    createMany?: ServicesWhatsappCustomersCreateManyCustomerInputEnvelope
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type VoucherUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type WhatsAppBulkCampaignCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppBulkCampaignCreateWithoutUserInput, WhatsAppBulkCampaignUncheckedCreateWithoutUserInput> | WhatsAppBulkCampaignCreateWithoutUserInput[] | WhatsAppBulkCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppBulkCampaignCreateOrConnectWithoutUserInput | WhatsAppBulkCampaignCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppBulkCampaignCreateManyUserInputEnvelope
    connect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
  }

  export type WhatsAppCampaignCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutUserInput, WhatsAppCampaignUncheckedCreateWithoutUserInput> | WhatsAppCampaignCreateWithoutUserInput[] | WhatsAppCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutUserInput | WhatsAppCampaignCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppCampaignCreateManyUserInputEnvelope
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
  }

  export type WhatsAppContactCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppContactCreateWithoutUserInput, WhatsAppContactUncheckedCreateWithoutUserInput> | WhatsAppContactCreateWithoutUserInput[] | WhatsAppContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutUserInput | WhatsAppContactCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppContactCreateManyUserInputEnvelope
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
  }

  export type WhatsAppSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput> | WhatsAppSessionCreateWithoutUserInput[] | WhatsAppSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutUserInput | WhatsAppSessionCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppSessionCreateManyUserInputEnvelope
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
  }

  export type WhatsAppMessageStatsCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput> | WhatsAppMessageStatsCreateWithoutUserInput[] | WhatsAppMessageStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutUserInput | WhatsAppMessageStatsCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppMessageStatsCreateManyUserInputEnvelope
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
  }

  export type WhatsAppAIBotCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppAIBotCreateWithoutUserInput, WhatsAppAIBotUncheckedCreateWithoutUserInput> | WhatsAppAIBotCreateWithoutUserInput[] | WhatsAppAIBotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppAIBotCreateOrConnectWithoutUserInput | WhatsAppAIBotCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppAIBotCreateManyUserInputEnvelope
    connect?: WhatsAppAIBotWhereUniqueInput | WhatsAppAIBotWhereUniqueInput[]
  }

  export type AIDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<AIDocumentCreateWithoutUserInput, AIDocumentUncheckedCreateWithoutUserInput> | AIDocumentCreateWithoutUserInput[] | AIDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIDocumentCreateOrConnectWithoutUserInput | AIDocumentCreateOrConnectWithoutUserInput[]
    createMany?: AIDocumentCreateManyUserInputEnvelope
    connect?: AIDocumentWhereUniqueInput | AIDocumentWhereUniqueInput[]
  }

  export type AIUsageLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput> | AIUsageLogCreateWithoutUserInput[] | AIUsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutUserInput | AIUsageLogCreateOrConnectWithoutUserInput[]
    createMany?: AIUsageLogCreateManyUserInputEnvelope
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
  }

  export type AIBotSessionBindingCreateNestedManyWithoutUserInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutUserInput, AIBotSessionBindingUncheckedCreateWithoutUserInput> | AIBotSessionBindingCreateWithoutUserInput[] | AIBotSessionBindingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutUserInput | AIBotSessionBindingCreateOrConnectWithoutUserInput[]
    createMany?: AIBotSessionBindingCreateManyUserInputEnvelope
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
  }

  export type ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput> | ServicesWhatsappCustomersCreateWithoutCustomerInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput | ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput[]
    createMany?: ServicesWhatsappCustomersCreateManyCustomerInputEnvelope
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type VoucherUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppBulkCampaignCreateWithoutUserInput, WhatsAppBulkCampaignUncheckedCreateWithoutUserInput> | WhatsAppBulkCampaignCreateWithoutUserInput[] | WhatsAppBulkCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppBulkCampaignCreateOrConnectWithoutUserInput | WhatsAppBulkCampaignCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppBulkCampaignCreateManyUserInputEnvelope
    connect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
  }

  export type WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutUserInput, WhatsAppCampaignUncheckedCreateWithoutUserInput> | WhatsAppCampaignCreateWithoutUserInput[] | WhatsAppCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutUserInput | WhatsAppCampaignCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppCampaignCreateManyUserInputEnvelope
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
  }

  export type WhatsAppContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppContactCreateWithoutUserInput, WhatsAppContactUncheckedCreateWithoutUserInput> | WhatsAppContactCreateWithoutUserInput[] | WhatsAppContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutUserInput | WhatsAppContactCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppContactCreateManyUserInputEnvelope
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
  }

  export type WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput> | WhatsAppSessionCreateWithoutUserInput[] | WhatsAppSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutUserInput | WhatsAppSessionCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppSessionCreateManyUserInputEnvelope
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
  }

  export type WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput> | WhatsAppMessageStatsCreateWithoutUserInput[] | WhatsAppMessageStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutUserInput | WhatsAppMessageStatsCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppMessageStatsCreateManyUserInputEnvelope
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
  }

  export type WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppAIBotCreateWithoutUserInput, WhatsAppAIBotUncheckedCreateWithoutUserInput> | WhatsAppAIBotCreateWithoutUserInput[] | WhatsAppAIBotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppAIBotCreateOrConnectWithoutUserInput | WhatsAppAIBotCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppAIBotCreateManyUserInputEnvelope
    connect?: WhatsAppAIBotWhereUniqueInput | WhatsAppAIBotWhereUniqueInput[]
  }

  export type AIDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIDocumentCreateWithoutUserInput, AIDocumentUncheckedCreateWithoutUserInput> | AIDocumentCreateWithoutUserInput[] | AIDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIDocumentCreateOrConnectWithoutUserInput | AIDocumentCreateOrConnectWithoutUserInput[]
    createMany?: AIDocumentCreateManyUserInputEnvelope
    connect?: AIDocumentWhereUniqueInput | AIDocumentWhereUniqueInput[]
  }

  export type AIUsageLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput> | AIUsageLogCreateWithoutUserInput[] | AIUsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutUserInput | AIUsageLogCreateOrConnectWithoutUserInput[]
    createMany?: AIUsageLogCreateManyUserInputEnvelope
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
  }

  export type AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutUserInput, AIBotSessionBindingUncheckedCreateWithoutUserInput> | AIBotSessionBindingCreateWithoutUserInput[] | AIBotSessionBindingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutUserInput | AIBotSessionBindingCreateOrConnectWithoutUserInput[]
    createMany?: AIBotSessionBindingCreateManyUserInputEnvelope
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput> | ServicesWhatsappCustomersCreateWithoutCustomerInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput | ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput[]
    upsert?: ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutCustomerInput | ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServicesWhatsappCustomersCreateManyCustomerInputEnvelope
    set?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    disconnect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    delete?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    update?: ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutCustomerInput | ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServicesWhatsappCustomersUpdateManyWithWhereWithoutCustomerInput | ServicesWhatsappCustomersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type VoucherUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutUserInput | VoucherUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutUserInput | VoucherUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutUserInput | VoucherUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppBulkCampaignCreateWithoutUserInput, WhatsAppBulkCampaignUncheckedCreateWithoutUserInput> | WhatsAppBulkCampaignCreateWithoutUserInput[] | WhatsAppBulkCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppBulkCampaignCreateOrConnectWithoutUserInput | WhatsAppBulkCampaignCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppBulkCampaignUpsertWithWhereUniqueWithoutUserInput | WhatsAppBulkCampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppBulkCampaignCreateManyUserInputEnvelope
    set?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    disconnect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    delete?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    connect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    update?: WhatsAppBulkCampaignUpdateWithWhereUniqueWithoutUserInput | WhatsAppBulkCampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppBulkCampaignUpdateManyWithWhereWithoutUserInput | WhatsAppBulkCampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppBulkCampaignScalarWhereInput | WhatsAppBulkCampaignScalarWhereInput[]
  }

  export type WhatsAppCampaignUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutUserInput, WhatsAppCampaignUncheckedCreateWithoutUserInput> | WhatsAppCampaignCreateWithoutUserInput[] | WhatsAppCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutUserInput | WhatsAppCampaignCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppCampaignUpsertWithWhereUniqueWithoutUserInput | WhatsAppCampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppCampaignCreateManyUserInputEnvelope
    set?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    disconnect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    delete?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    update?: WhatsAppCampaignUpdateWithWhereUniqueWithoutUserInput | WhatsAppCampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppCampaignUpdateManyWithWhereWithoutUserInput | WhatsAppCampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
  }

  export type WhatsAppContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppContactCreateWithoutUserInput, WhatsAppContactUncheckedCreateWithoutUserInput> | WhatsAppContactCreateWithoutUserInput[] | WhatsAppContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutUserInput | WhatsAppContactCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppContactUpsertWithWhereUniqueWithoutUserInput | WhatsAppContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppContactCreateManyUserInputEnvelope
    set?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    disconnect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    delete?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    update?: WhatsAppContactUpdateWithWhereUniqueWithoutUserInput | WhatsAppContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppContactUpdateManyWithWhereWithoutUserInput | WhatsAppContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppContactScalarWhereInput | WhatsAppContactScalarWhereInput[]
  }

  export type WhatsAppSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput> | WhatsAppSessionCreateWithoutUserInput[] | WhatsAppSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutUserInput | WhatsAppSessionCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppSessionUpsertWithWhereUniqueWithoutUserInput | WhatsAppSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppSessionCreateManyUserInputEnvelope
    set?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    disconnect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    delete?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    update?: WhatsAppSessionUpdateWithWhereUniqueWithoutUserInput | WhatsAppSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppSessionUpdateManyWithWhereWithoutUserInput | WhatsAppSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
  }

  export type WhatsAppMessageStatsUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput> | WhatsAppMessageStatsCreateWithoutUserInput[] | WhatsAppMessageStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutUserInput | WhatsAppMessageStatsCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppMessageStatsUpsertWithWhereUniqueWithoutUserInput | WhatsAppMessageStatsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppMessageStatsCreateManyUserInputEnvelope
    set?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    disconnect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    delete?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    update?: WhatsAppMessageStatsUpdateWithWhereUniqueWithoutUserInput | WhatsAppMessageStatsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppMessageStatsUpdateManyWithWhereWithoutUserInput | WhatsAppMessageStatsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
  }

  export type WhatsAppAIBotUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppAIBotCreateWithoutUserInput, WhatsAppAIBotUncheckedCreateWithoutUserInput> | WhatsAppAIBotCreateWithoutUserInput[] | WhatsAppAIBotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppAIBotCreateOrConnectWithoutUserInput | WhatsAppAIBotCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppAIBotUpsertWithWhereUniqueWithoutUserInput | WhatsAppAIBotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppAIBotCreateManyUserInputEnvelope
    set?: WhatsAppAIBotWhereUniqueInput | WhatsAppAIBotWhereUniqueInput[]
    disconnect?: WhatsAppAIBotWhereUniqueInput | WhatsAppAIBotWhereUniqueInput[]
    delete?: WhatsAppAIBotWhereUniqueInput | WhatsAppAIBotWhereUniqueInput[]
    connect?: WhatsAppAIBotWhereUniqueInput | WhatsAppAIBotWhereUniqueInput[]
    update?: WhatsAppAIBotUpdateWithWhereUniqueWithoutUserInput | WhatsAppAIBotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppAIBotUpdateManyWithWhereWithoutUserInput | WhatsAppAIBotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppAIBotScalarWhereInput | WhatsAppAIBotScalarWhereInput[]
  }

  export type AIDocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIDocumentCreateWithoutUserInput, AIDocumentUncheckedCreateWithoutUserInput> | AIDocumentCreateWithoutUserInput[] | AIDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIDocumentCreateOrConnectWithoutUserInput | AIDocumentCreateOrConnectWithoutUserInput[]
    upsert?: AIDocumentUpsertWithWhereUniqueWithoutUserInput | AIDocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIDocumentCreateManyUserInputEnvelope
    set?: AIDocumentWhereUniqueInput | AIDocumentWhereUniqueInput[]
    disconnect?: AIDocumentWhereUniqueInput | AIDocumentWhereUniqueInput[]
    delete?: AIDocumentWhereUniqueInput | AIDocumentWhereUniqueInput[]
    connect?: AIDocumentWhereUniqueInput | AIDocumentWhereUniqueInput[]
    update?: AIDocumentUpdateWithWhereUniqueWithoutUserInput | AIDocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIDocumentUpdateManyWithWhereWithoutUserInput | AIDocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIDocumentScalarWhereInput | AIDocumentScalarWhereInput[]
  }

  export type AIUsageLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput> | AIUsageLogCreateWithoutUserInput[] | AIUsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutUserInput | AIUsageLogCreateOrConnectWithoutUserInput[]
    upsert?: AIUsageLogUpsertWithWhereUniqueWithoutUserInput | AIUsageLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIUsageLogCreateManyUserInputEnvelope
    set?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    disconnect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    delete?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    update?: AIUsageLogUpdateWithWhereUniqueWithoutUserInput | AIUsageLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIUsageLogUpdateManyWithWhereWithoutUserInput | AIUsageLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
  }

  export type AIBotSessionBindingUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutUserInput, AIBotSessionBindingUncheckedCreateWithoutUserInput> | AIBotSessionBindingCreateWithoutUserInput[] | AIBotSessionBindingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutUserInput | AIBotSessionBindingCreateOrConnectWithoutUserInput[]
    upsert?: AIBotSessionBindingUpsertWithWhereUniqueWithoutUserInput | AIBotSessionBindingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIBotSessionBindingCreateManyUserInputEnvelope
    set?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    disconnect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    delete?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    update?: AIBotSessionBindingUpdateWithWhereUniqueWithoutUserInput | AIBotSessionBindingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIBotSessionBindingUpdateManyWithWhereWithoutUserInput | AIBotSessionBindingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIBotSessionBindingScalarWhereInput | AIBotSessionBindingScalarWhereInput[]
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput> | ServicesWhatsappCustomersCreateWithoutCustomerInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput | ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput[]
    upsert?: ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutCustomerInput | ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServicesWhatsappCustomersCreateManyCustomerInputEnvelope
    set?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    disconnect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    delete?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    update?: ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutCustomerInput | ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServicesWhatsappCustomersUpdateManyWithWhereWithoutCustomerInput | ServicesWhatsappCustomersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type VoucherUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutUserInput | VoucherUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutUserInput | VoucherUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutUserInput | VoucherUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppBulkCampaignCreateWithoutUserInput, WhatsAppBulkCampaignUncheckedCreateWithoutUserInput> | WhatsAppBulkCampaignCreateWithoutUserInput[] | WhatsAppBulkCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppBulkCampaignCreateOrConnectWithoutUserInput | WhatsAppBulkCampaignCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppBulkCampaignUpsertWithWhereUniqueWithoutUserInput | WhatsAppBulkCampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppBulkCampaignCreateManyUserInputEnvelope
    set?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    disconnect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    delete?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    connect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    update?: WhatsAppBulkCampaignUpdateWithWhereUniqueWithoutUserInput | WhatsAppBulkCampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppBulkCampaignUpdateManyWithWhereWithoutUserInput | WhatsAppBulkCampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppBulkCampaignScalarWhereInput | WhatsAppBulkCampaignScalarWhereInput[]
  }

  export type WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutUserInput, WhatsAppCampaignUncheckedCreateWithoutUserInput> | WhatsAppCampaignCreateWithoutUserInput[] | WhatsAppCampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutUserInput | WhatsAppCampaignCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppCampaignUpsertWithWhereUniqueWithoutUserInput | WhatsAppCampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppCampaignCreateManyUserInputEnvelope
    set?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    disconnect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    delete?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    connect?: WhatsAppCampaignWhereUniqueInput | WhatsAppCampaignWhereUniqueInput[]
    update?: WhatsAppCampaignUpdateWithWhereUniqueWithoutUserInput | WhatsAppCampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppCampaignUpdateManyWithWhereWithoutUserInput | WhatsAppCampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
  }

  export type WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppContactCreateWithoutUserInput, WhatsAppContactUncheckedCreateWithoutUserInput> | WhatsAppContactCreateWithoutUserInput[] | WhatsAppContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutUserInput | WhatsAppContactCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppContactUpsertWithWhereUniqueWithoutUserInput | WhatsAppContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppContactCreateManyUserInputEnvelope
    set?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    disconnect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    delete?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    update?: WhatsAppContactUpdateWithWhereUniqueWithoutUserInput | WhatsAppContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppContactUpdateManyWithWhereWithoutUserInput | WhatsAppContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppContactScalarWhereInput | WhatsAppContactScalarWhereInput[]
  }

  export type WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput> | WhatsAppSessionCreateWithoutUserInput[] | WhatsAppSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutUserInput | WhatsAppSessionCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppSessionUpsertWithWhereUniqueWithoutUserInput | WhatsAppSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppSessionCreateManyUserInputEnvelope
    set?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    disconnect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    delete?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    update?: WhatsAppSessionUpdateWithWhereUniqueWithoutUserInput | WhatsAppSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppSessionUpdateManyWithWhereWithoutUserInput | WhatsAppSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
  }

  export type WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput> | WhatsAppMessageStatsCreateWithoutUserInput[] | WhatsAppMessageStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutUserInput | WhatsAppMessageStatsCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppMessageStatsUpsertWithWhereUniqueWithoutUserInput | WhatsAppMessageStatsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppMessageStatsCreateManyUserInputEnvelope
    set?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    disconnect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    delete?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    update?: WhatsAppMessageStatsUpdateWithWhereUniqueWithoutUserInput | WhatsAppMessageStatsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppMessageStatsUpdateManyWithWhereWithoutUserInput | WhatsAppMessageStatsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
  }

  export type WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppAIBotCreateWithoutUserInput, WhatsAppAIBotUncheckedCreateWithoutUserInput> | WhatsAppAIBotCreateWithoutUserInput[] | WhatsAppAIBotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppAIBotCreateOrConnectWithoutUserInput | WhatsAppAIBotCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppAIBotUpsertWithWhereUniqueWithoutUserInput | WhatsAppAIBotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppAIBotCreateManyUserInputEnvelope
    set?: WhatsAppAIBotWhereUniqueInput | WhatsAppAIBotWhereUniqueInput[]
    disconnect?: WhatsAppAIBotWhereUniqueInput | WhatsAppAIBotWhereUniqueInput[]
    delete?: WhatsAppAIBotWhereUniqueInput | WhatsAppAIBotWhereUniqueInput[]
    connect?: WhatsAppAIBotWhereUniqueInput | WhatsAppAIBotWhereUniqueInput[]
    update?: WhatsAppAIBotUpdateWithWhereUniqueWithoutUserInput | WhatsAppAIBotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppAIBotUpdateManyWithWhereWithoutUserInput | WhatsAppAIBotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppAIBotScalarWhereInput | WhatsAppAIBotScalarWhereInput[]
  }

  export type AIDocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIDocumentCreateWithoutUserInput, AIDocumentUncheckedCreateWithoutUserInput> | AIDocumentCreateWithoutUserInput[] | AIDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIDocumentCreateOrConnectWithoutUserInput | AIDocumentCreateOrConnectWithoutUserInput[]
    upsert?: AIDocumentUpsertWithWhereUniqueWithoutUserInput | AIDocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIDocumentCreateManyUserInputEnvelope
    set?: AIDocumentWhereUniqueInput | AIDocumentWhereUniqueInput[]
    disconnect?: AIDocumentWhereUniqueInput | AIDocumentWhereUniqueInput[]
    delete?: AIDocumentWhereUniqueInput | AIDocumentWhereUniqueInput[]
    connect?: AIDocumentWhereUniqueInput | AIDocumentWhereUniqueInput[]
    update?: AIDocumentUpdateWithWhereUniqueWithoutUserInput | AIDocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIDocumentUpdateManyWithWhereWithoutUserInput | AIDocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIDocumentScalarWhereInput | AIDocumentScalarWhereInput[]
  }

  export type AIUsageLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput> | AIUsageLogCreateWithoutUserInput[] | AIUsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIUsageLogCreateOrConnectWithoutUserInput | AIUsageLogCreateOrConnectWithoutUserInput[]
    upsert?: AIUsageLogUpsertWithWhereUniqueWithoutUserInput | AIUsageLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIUsageLogCreateManyUserInputEnvelope
    set?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    disconnect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    delete?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    connect?: AIUsageLogWhereUniqueInput | AIUsageLogWhereUniqueInput[]
    update?: AIUsageLogUpdateWithWhereUniqueWithoutUserInput | AIUsageLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIUsageLogUpdateManyWithWhereWithoutUserInput | AIUsageLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
  }

  export type AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutUserInput, AIBotSessionBindingUncheckedCreateWithoutUserInput> | AIBotSessionBindingCreateWithoutUserInput[] | AIBotSessionBindingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutUserInput | AIBotSessionBindingCreateOrConnectWithoutUserInput[]
    upsert?: AIBotSessionBindingUpsertWithWhereUniqueWithoutUserInput | AIBotSessionBindingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AIBotSessionBindingCreateManyUserInputEnvelope
    set?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    disconnect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    delete?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    update?: AIBotSessionBindingUpdateWithWhereUniqueWithoutUserInput | AIBotSessionBindingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AIBotSessionBindingUpdateManyWithWhereWithoutUserInput | AIBotSessionBindingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AIBotSessionBindingScalarWhereInput | AIBotSessionBindingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWhatsAppSessionsInput = {
    create?: XOR<UserCreateWithoutWhatsAppSessionsInput, UserUncheckedCreateWithoutWhatsAppSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppMessageStatsCreateNestedManyWithoutSessionInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput> | WhatsAppMessageStatsCreateWithoutSessionInput[] | WhatsAppMessageStatsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutSessionInput | WhatsAppMessageStatsCreateOrConnectWithoutSessionInput[]
    createMany?: WhatsAppMessageStatsCreateManySessionInputEnvelope
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
  }

  export type AIBotSessionBindingCreateNestedManyWithoutSessionInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutSessionInput, AIBotSessionBindingUncheckedCreateWithoutSessionInput> | AIBotSessionBindingCreateWithoutSessionInput[] | AIBotSessionBindingUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutSessionInput | AIBotSessionBindingCreateOrConnectWithoutSessionInput[]
    createMany?: AIBotSessionBindingCreateManySessionInputEnvelope
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
  }

  export type WhatsAppMessageStatsUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput> | WhatsAppMessageStatsCreateWithoutSessionInput[] | WhatsAppMessageStatsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutSessionInput | WhatsAppMessageStatsCreateOrConnectWithoutSessionInput[]
    createMany?: WhatsAppMessageStatsCreateManySessionInputEnvelope
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
  }

  export type AIBotSessionBindingUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutSessionInput, AIBotSessionBindingUncheckedCreateWithoutSessionInput> | AIBotSessionBindingCreateWithoutSessionInput[] | AIBotSessionBindingUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutSessionInput | AIBotSessionBindingCreateOrConnectWithoutSessionInput[]
    createMany?: AIBotSessionBindingCreateManySessionInputEnvelope
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutWhatsAppSessionsNestedInput = {
    create?: XOR<UserCreateWithoutWhatsAppSessionsInput, UserUncheckedCreateWithoutWhatsAppSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppSessionsInput
    upsert?: UserUpsertWithoutWhatsAppSessionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsAppSessionsInput, UserUpdateWithoutWhatsAppSessionsInput>, UserUncheckedUpdateWithoutWhatsAppSessionsInput>
  }

  export type WhatsAppMessageStatsUpdateManyWithoutSessionNestedInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput> | WhatsAppMessageStatsCreateWithoutSessionInput[] | WhatsAppMessageStatsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutSessionInput | WhatsAppMessageStatsCreateOrConnectWithoutSessionInput[]
    upsert?: WhatsAppMessageStatsUpsertWithWhereUniqueWithoutSessionInput | WhatsAppMessageStatsUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: WhatsAppMessageStatsCreateManySessionInputEnvelope
    set?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    disconnect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    delete?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    update?: WhatsAppMessageStatsUpdateWithWhereUniqueWithoutSessionInput | WhatsAppMessageStatsUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: WhatsAppMessageStatsUpdateManyWithWhereWithoutSessionInput | WhatsAppMessageStatsUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
  }

  export type AIBotSessionBindingUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutSessionInput, AIBotSessionBindingUncheckedCreateWithoutSessionInput> | AIBotSessionBindingCreateWithoutSessionInput[] | AIBotSessionBindingUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutSessionInput | AIBotSessionBindingCreateOrConnectWithoutSessionInput[]
    upsert?: AIBotSessionBindingUpsertWithWhereUniqueWithoutSessionInput | AIBotSessionBindingUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AIBotSessionBindingCreateManySessionInputEnvelope
    set?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    disconnect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    delete?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    update?: AIBotSessionBindingUpdateWithWhereUniqueWithoutSessionInput | AIBotSessionBindingUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AIBotSessionBindingUpdateManyWithWhereWithoutSessionInput | AIBotSessionBindingUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AIBotSessionBindingScalarWhereInput | AIBotSessionBindingScalarWhereInput[]
  }

  export type WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput> | WhatsAppMessageStatsCreateWithoutSessionInput[] | WhatsAppMessageStatsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutSessionInput | WhatsAppMessageStatsCreateOrConnectWithoutSessionInput[]
    upsert?: WhatsAppMessageStatsUpsertWithWhereUniqueWithoutSessionInput | WhatsAppMessageStatsUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: WhatsAppMessageStatsCreateManySessionInputEnvelope
    set?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    disconnect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    delete?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    update?: WhatsAppMessageStatsUpdateWithWhereUniqueWithoutSessionInput | WhatsAppMessageStatsUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: WhatsAppMessageStatsUpdateManyWithWhereWithoutSessionInput | WhatsAppMessageStatsUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
  }

  export type AIBotSessionBindingUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutSessionInput, AIBotSessionBindingUncheckedCreateWithoutSessionInput> | AIBotSessionBindingCreateWithoutSessionInput[] | AIBotSessionBindingUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutSessionInput | AIBotSessionBindingCreateOrConnectWithoutSessionInput[]
    upsert?: AIBotSessionBindingUpsertWithWhereUniqueWithoutSessionInput | AIBotSessionBindingUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AIBotSessionBindingCreateManySessionInputEnvelope
    set?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    disconnect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    delete?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    update?: AIBotSessionBindingUpdateWithWhereUniqueWithoutSessionInput | AIBotSessionBindingUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AIBotSessionBindingUpdateManyWithWhereWithoutSessionInput | AIBotSessionBindingUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AIBotSessionBindingScalarWhereInput | AIBotSessionBindingScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    connect?: PaymentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type VoucherCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<VoucherCreateWithoutTransactionsInput, VoucherUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutTransactionsInput
    connect?: VoucherWhereUniqueInput
  }

  export type TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutTransactionInput
    connect?: TransactionWhatsappServiceWhereUniqueInput
  }

  export type VoucherUsageCreateNestedManyWithoutTransactionInput = {
    create?: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput> | VoucherUsageCreateWithoutTransactionInput[] | VoucherUsageUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutTransactionInput | VoucherUsageCreateOrConnectWithoutTransactionInput[]
    createMany?: VoucherUsageCreateManyTransactionInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    connect?: PaymentWhereUniqueInput
  }

  export type TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutTransactionInput
    connect?: TransactionWhatsappServiceWhereUniqueInput
  }

  export type VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput> | VoucherUsageCreateWithoutTransactionInput[] | VoucherUsageUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutTransactionInput | VoucherUsageCreateOrConnectWithoutTransactionInput[]
    createMany?: VoucherUsageCreateManyTransactionInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    upsert?: PaymentUpsertWithoutTransactionInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransactionInput, PaymentUpdateWithoutTransactionInput>, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type VoucherUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<VoucherCreateWithoutTransactionsInput, VoucherUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutTransactionsInput
    upsert?: VoucherUpsertWithoutTransactionsInput
    disconnect?: VoucherWhereInput | boolean
    delete?: VoucherWhereInput | boolean
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutTransactionsInput, VoucherUpdateWithoutTransactionsInput>, VoucherUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutTransactionInput
    upsert?: TransactionWhatsappServiceUpsertWithoutTransactionInput
    disconnect?: TransactionWhatsappServiceWhereInput | boolean
    delete?: TransactionWhatsappServiceWhereInput | boolean
    connect?: TransactionWhatsappServiceWhereUniqueInput
    update?: XOR<XOR<TransactionWhatsappServiceUpdateToOneWithWhereWithoutTransactionInput, TransactionWhatsappServiceUpdateWithoutTransactionInput>, TransactionWhatsappServiceUncheckedUpdateWithoutTransactionInput>
  }

  export type VoucherUsageUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput> | VoucherUsageCreateWithoutTransactionInput[] | VoucherUsageUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutTransactionInput | VoucherUsageCreateOrConnectWithoutTransactionInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutTransactionInput | VoucherUsageUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: VoucherUsageCreateManyTransactionInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutTransactionInput | VoucherUsageUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutTransactionInput | VoucherUsageUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    upsert?: PaymentUpsertWithoutTransactionInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransactionInput, PaymentUpdateWithoutTransactionInput>, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutTransactionInput
    upsert?: TransactionWhatsappServiceUpsertWithoutTransactionInput
    disconnect?: TransactionWhatsappServiceWhereInput | boolean
    delete?: TransactionWhatsappServiceWhereInput | boolean
    connect?: TransactionWhatsappServiceWhereUniqueInput
    update?: XOR<XOR<TransactionWhatsappServiceUpdateToOneWithWhereWithoutTransactionInput, TransactionWhatsappServiceUpdateWithoutTransactionInput>, TransactionWhatsappServiceUncheckedUpdateWithoutTransactionInput>
  }

  export type VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput> | VoucherUsageCreateWithoutTransactionInput[] | VoucherUsageUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutTransactionInput | VoucherUsageCreateOrConnectWithoutTransactionInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutTransactionInput | VoucherUsageUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: VoucherUsageCreateManyTransactionInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutTransactionInput | VoucherUsageUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutTransactionInput | VoucherUsageUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutWhatsappTransactionInput = {
    create?: XOR<TransactionCreateWithoutWhatsappTransactionInput, TransactionUncheckedCreateWithoutWhatsappTransactionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutWhatsappTransactionInput
    connect?: TransactionWhereUniqueInput
  }

  export type WhatsappApiPackageCreateNestedOneWithoutWhatsappTransactionsInput = {
    create?: XOR<WhatsappApiPackageCreateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappTransactionsInput>
    connectOrCreate?: WhatsappApiPackageCreateOrConnectWithoutWhatsappTransactionsInput
    connect?: WhatsappApiPackageWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutWhatsappTransactionNestedInput = {
    create?: XOR<TransactionCreateWithoutWhatsappTransactionInput, TransactionUncheckedCreateWithoutWhatsappTransactionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutWhatsappTransactionInput
    upsert?: TransactionUpsertWithoutWhatsappTransactionInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutWhatsappTransactionInput, TransactionUpdateWithoutWhatsappTransactionInput>, TransactionUncheckedUpdateWithoutWhatsappTransactionInput>
  }

  export type WhatsappApiPackageUpdateOneRequiredWithoutWhatsappTransactionsNestedInput = {
    create?: XOR<WhatsappApiPackageCreateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappTransactionsInput>
    connectOrCreate?: WhatsappApiPackageCreateOrConnectWithoutWhatsappTransactionsInput
    upsert?: WhatsappApiPackageUpsertWithoutWhatsappTransactionsInput
    connect?: WhatsappApiPackageWhereUniqueInput
    update?: XOR<XOR<WhatsappApiPackageUpdateToOneWithWhereWithoutWhatsappTransactionsInput, WhatsappApiPackageUpdateWithoutWhatsappTransactionsInput>, WhatsappApiPackageUncheckedUpdateWithoutWhatsappTransactionsInput>
  }

  export type TransactionCreateNestedOneWithoutPaymentInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput
    upsert?: TransactionUpsertWithoutPaymentInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPaymentInput, TransactionUpdateWithoutPaymentInput>, TransactionUncheckedUpdateWithoutPaymentInput>
  }

  export type ServicesWhatsappCustomersCreateNestedManyWithoutPackageInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput> | ServicesWhatsappCustomersCreateWithoutPackageInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput | ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput[]
    createMany?: ServicesWhatsappCustomersCreateManyPackageInputEnvelope
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
  }

  export type TransactionWhatsappServiceCreateNestedManyWithoutWhatsappPackageInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput> | TransactionWhatsappServiceCreateWithoutWhatsappPackageInput[] | TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput[]
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput | TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput[]
    createMany?: TransactionWhatsappServiceCreateManyWhatsappPackageInputEnvelope
    connect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
  }

  export type ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput> | ServicesWhatsappCustomersCreateWithoutPackageInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput | ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput[]
    createMany?: ServicesWhatsappCustomersCreateManyPackageInputEnvelope
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
  }

  export type TransactionWhatsappServiceUncheckedCreateNestedManyWithoutWhatsappPackageInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput> | TransactionWhatsappServiceCreateWithoutWhatsappPackageInput[] | TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput[]
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput | TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput[]
    createMany?: TransactionWhatsappServiceCreateManyWhatsappPackageInputEnvelope
    connect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
  }

  export type ServicesWhatsappCustomersUpdateManyWithoutPackageNestedInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput> | ServicesWhatsappCustomersCreateWithoutPackageInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput | ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput[]
    upsert?: ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutPackageInput | ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: ServicesWhatsappCustomersCreateManyPackageInputEnvelope
    set?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    disconnect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    delete?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    update?: ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutPackageInput | ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: ServicesWhatsappCustomersUpdateManyWithWhereWithoutPackageInput | ServicesWhatsappCustomersUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
  }

  export type TransactionWhatsappServiceUpdateManyWithoutWhatsappPackageNestedInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput> | TransactionWhatsappServiceCreateWithoutWhatsappPackageInput[] | TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput[]
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput | TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput[]
    upsert?: TransactionWhatsappServiceUpsertWithWhereUniqueWithoutWhatsappPackageInput | TransactionWhatsappServiceUpsertWithWhereUniqueWithoutWhatsappPackageInput[]
    createMany?: TransactionWhatsappServiceCreateManyWhatsappPackageInputEnvelope
    set?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    disconnect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    delete?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    connect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    update?: TransactionWhatsappServiceUpdateWithWhereUniqueWithoutWhatsappPackageInput | TransactionWhatsappServiceUpdateWithWhereUniqueWithoutWhatsappPackageInput[]
    updateMany?: TransactionWhatsappServiceUpdateManyWithWhereWithoutWhatsappPackageInput | TransactionWhatsappServiceUpdateManyWithWhereWithoutWhatsappPackageInput[]
    deleteMany?: TransactionWhatsappServiceScalarWhereInput | TransactionWhatsappServiceScalarWhereInput[]
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput> | ServicesWhatsappCustomersCreateWithoutPackageInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput | ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput[]
    upsert?: ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutPackageInput | ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: ServicesWhatsappCustomersCreateManyPackageInputEnvelope
    set?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    disconnect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    delete?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    update?: ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutPackageInput | ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: ServicesWhatsappCustomersUpdateManyWithWhereWithoutPackageInput | ServicesWhatsappCustomersUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
  }

  export type TransactionWhatsappServiceUncheckedUpdateManyWithoutWhatsappPackageNestedInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput> | TransactionWhatsappServiceCreateWithoutWhatsappPackageInput[] | TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput[]
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput | TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput[]
    upsert?: TransactionWhatsappServiceUpsertWithWhereUniqueWithoutWhatsappPackageInput | TransactionWhatsappServiceUpsertWithWhereUniqueWithoutWhatsappPackageInput[]
    createMany?: TransactionWhatsappServiceCreateManyWhatsappPackageInputEnvelope
    set?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    disconnect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    delete?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    connect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    update?: TransactionWhatsappServiceUpdateWithWhereUniqueWithoutWhatsappPackageInput | TransactionWhatsappServiceUpdateWithWhereUniqueWithoutWhatsappPackageInput[]
    updateMany?: TransactionWhatsappServiceUpdateManyWithWhereWithoutWhatsappPackageInput | TransactionWhatsappServiceUpdateManyWithWhereWithoutWhatsappPackageInput[]
    deleteMany?: TransactionWhatsappServiceScalarWhereInput | TransactionWhatsappServiceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWhatsappCustomersInput = {
    create?: XOR<UserCreateWithoutWhatsappCustomersInput, UserUncheckedCreateWithoutWhatsappCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappCustomersInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsappApiPackageCreateNestedOneWithoutWhatsappCustomersInput = {
    create?: XOR<WhatsappApiPackageCreateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappCustomersInput>
    connectOrCreate?: WhatsappApiPackageCreateOrConnectWithoutWhatsappCustomersInput
    connect?: WhatsappApiPackageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWhatsappCustomersNestedInput = {
    create?: XOR<UserCreateWithoutWhatsappCustomersInput, UserUncheckedCreateWithoutWhatsappCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappCustomersInput
    upsert?: UserUpsertWithoutWhatsappCustomersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsappCustomersInput, UserUpdateWithoutWhatsappCustomersInput>, UserUncheckedUpdateWithoutWhatsappCustomersInput>
  }

  export type WhatsappApiPackageUpdateOneRequiredWithoutWhatsappCustomersNestedInput = {
    create?: XOR<WhatsappApiPackageCreateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappCustomersInput>
    connectOrCreate?: WhatsappApiPackageCreateOrConnectWithoutWhatsappCustomersInput
    upsert?: WhatsappApiPackageUpsertWithoutWhatsappCustomersInput
    connect?: WhatsappApiPackageWhereUniqueInput
    update?: XOR<XOR<WhatsappApiPackageUpdateToOneWithWhereWithoutWhatsappCustomersInput, WhatsappApiPackageUpdateWithoutWhatsappCustomersInput>, WhatsappApiPackageUncheckedUpdateWithoutWhatsappCustomersInput>
  }

  export type UserCreateNestedOneWithoutUserSessionsInput = {
    create?: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserSessionsNestedInput = {
    create?: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSessionsInput
    upsert?: UserUpsertWithoutUserSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSessionsInput, UserUpdateWithoutUserSessionsInput>, UserUncheckedUpdateWithoutUserSessionsInput>
  }

  export type TransactionCreateNestedManyWithoutVoucherInput = {
    create?: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput> | TransactionCreateWithoutVoucherInput[] | TransactionUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherInput | TransactionCreateOrConnectWithoutVoucherInput[]
    createMany?: TransactionCreateManyVoucherInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type VoucherUsageCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput> | TransactionCreateWithoutVoucherInput[] | TransactionUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherInput | TransactionCreateOrConnectWithoutVoucherInput[]
    createMany?: TransactionCreateManyVoucherInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type VoucherUsageUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TransactionUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput> | TransactionCreateWithoutVoucherInput[] | TransactionUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherInput | TransactionCreateOrConnectWithoutVoucherInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutVoucherInput | TransactionUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: TransactionCreateManyVoucherInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutVoucherInput | TransactionUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutVoucherInput | TransactionUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type VoucherUsageUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput | VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput | VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutVoucherInput | VoucherUsageUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput> | TransactionCreateWithoutVoucherInput[] | TransactionUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherInput | TransactionCreateOrConnectWithoutVoucherInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutVoucherInput | TransactionUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: TransactionCreateManyVoucherInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutVoucherInput | TransactionUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutVoucherInput | TransactionUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type VoucherUsageUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput | VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput | VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutVoucherInput | VoucherUsageUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutVoucherUsageInput = {
    create?: XOR<TransactionCreateWithoutVoucherUsageInput, TransactionUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherUsageInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVoucherUsageInput = {
    create?: XOR<UserCreateWithoutVoucherUsageInput, UserUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherUsageInput
    connect?: UserWhereUniqueInput
  }

  export type VoucherCreateNestedOneWithoutVoucherUsageInput = {
    create?: XOR<VoucherCreateWithoutVoucherUsageInput, VoucherUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutVoucherUsageInput
    connect?: VoucherWhereUniqueInput
  }

  export type TransactionUpdateOneWithoutVoucherUsageNestedInput = {
    create?: XOR<TransactionCreateWithoutVoucherUsageInput, TransactionUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherUsageInput
    upsert?: TransactionUpsertWithoutVoucherUsageInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutVoucherUsageInput, TransactionUpdateWithoutVoucherUsageInput>, TransactionUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type UserUpdateOneRequiredWithoutVoucherUsageNestedInput = {
    create?: XOR<UserCreateWithoutVoucherUsageInput, UserUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherUsageInput
    upsert?: UserUpsertWithoutVoucherUsageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVoucherUsageInput, UserUpdateWithoutVoucherUsageInput>, UserUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type VoucherUpdateOneRequiredWithoutVoucherUsageNestedInput = {
    create?: XOR<VoucherCreateWithoutVoucherUsageInput, VoucherUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutVoucherUsageInput
    upsert?: VoucherUpsertWithoutVoucherUsageInput
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutVoucherUsageInput, VoucherUpdateWithoutVoucherUsageInput>, VoucherUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type BankDetailCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<BankDetailCreateWithoutPaymentMethodsInput, BankDetailUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: BankDetailCreateOrConnectWithoutPaymentMethodsInput
    connect?: BankDetailWhereUniqueInput
  }

  export type BankDetailUpdateOneWithoutPaymentMethodsNestedInput = {
    create?: XOR<BankDetailCreateWithoutPaymentMethodsInput, BankDetailUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: BankDetailCreateOrConnectWithoutPaymentMethodsInput
    upsert?: BankDetailUpsertWithoutPaymentMethodsInput
    disconnect?: BankDetailWhereInput | boolean
    delete?: BankDetailWhereInput | boolean
    connect?: BankDetailWhereUniqueInput
    update?: XOR<XOR<BankDetailUpdateToOneWithWhereWithoutPaymentMethodsInput, BankDetailUpdateWithoutPaymentMethodsInput>, BankDetailUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type PaymentMethodCreateNestedManyWithoutBankDetailInput = {
    create?: XOR<PaymentMethodCreateWithoutBankDetailInput, PaymentMethodUncheckedCreateWithoutBankDetailInput> | PaymentMethodCreateWithoutBankDetailInput[] | PaymentMethodUncheckedCreateWithoutBankDetailInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutBankDetailInput | PaymentMethodCreateOrConnectWithoutBankDetailInput[]
    createMany?: PaymentMethodCreateManyBankDetailInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type PaymentMethodUncheckedCreateNestedManyWithoutBankDetailInput = {
    create?: XOR<PaymentMethodCreateWithoutBankDetailInput, PaymentMethodUncheckedCreateWithoutBankDetailInput> | PaymentMethodCreateWithoutBankDetailInput[] | PaymentMethodUncheckedCreateWithoutBankDetailInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutBankDetailInput | PaymentMethodCreateOrConnectWithoutBankDetailInput[]
    createMany?: PaymentMethodCreateManyBankDetailInputEnvelope
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
  }

  export type PaymentMethodUpdateManyWithoutBankDetailNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutBankDetailInput, PaymentMethodUncheckedCreateWithoutBankDetailInput> | PaymentMethodCreateWithoutBankDetailInput[] | PaymentMethodUncheckedCreateWithoutBankDetailInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutBankDetailInput | PaymentMethodCreateOrConnectWithoutBankDetailInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutBankDetailInput | PaymentMethodUpsertWithWhereUniqueWithoutBankDetailInput[]
    createMany?: PaymentMethodCreateManyBankDetailInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutBankDetailInput | PaymentMethodUpdateWithWhereUniqueWithoutBankDetailInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutBankDetailInput | PaymentMethodUpdateManyWithWhereWithoutBankDetailInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type PaymentMethodUncheckedUpdateManyWithoutBankDetailNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutBankDetailInput, PaymentMethodUncheckedCreateWithoutBankDetailInput> | PaymentMethodCreateWithoutBankDetailInput[] | PaymentMethodUncheckedCreateWithoutBankDetailInput[]
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutBankDetailInput | PaymentMethodCreateOrConnectWithoutBankDetailInput[]
    upsert?: PaymentMethodUpsertWithWhereUniqueWithoutBankDetailInput | PaymentMethodUpsertWithWhereUniqueWithoutBankDetailInput[]
    createMany?: PaymentMethodCreateManyBankDetailInputEnvelope
    set?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    disconnect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    delete?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    connect?: PaymentMethodWhereUniqueInput | PaymentMethodWhereUniqueInput[]
    update?: PaymentMethodUpdateWithWhereUniqueWithoutBankDetailInput | PaymentMethodUpdateWithWhereUniqueWithoutBankDetailInput[]
    updateMany?: PaymentMethodUpdateManyWithWhereWithoutBankDetailInput | PaymentMethodUpdateManyWithWhereWithoutBankDetailInput[]
    deleteMany?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
  }

  export type WhatsAppBulkCampaignCreateNestedManyWithoutWhatsAppCampaignsInput = {
    create?: XOR<WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput, WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput> | WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput[] | WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput[]
    connectOrCreate?: WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppCampaignsInput | WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppCampaignsInput[]
    createMany?: WhatsAppBulkCampaignCreateManyWhatsAppCampaignsInputEnvelope
    connect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutWhatsAppCampaignsInput = {
    create?: XOR<UserCreateWithoutWhatsAppCampaignsInput, UserUncheckedCreateWithoutWhatsAppCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutWhatsAppCampaignsInput = {
    create?: XOR<WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput, WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput> | WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput[] | WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput[]
    connectOrCreate?: WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppCampaignsInput | WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppCampaignsInput[]
    createMany?: WhatsAppBulkCampaignCreateManyWhatsAppCampaignsInputEnvelope
    connect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type WhatsAppBulkCampaignUpdateManyWithoutWhatsAppCampaignsNestedInput = {
    create?: XOR<WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput, WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput> | WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput[] | WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput[]
    connectOrCreate?: WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppCampaignsInput | WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppCampaignsInput[]
    upsert?: WhatsAppBulkCampaignUpsertWithWhereUniqueWithoutWhatsAppCampaignsInput | WhatsAppBulkCampaignUpsertWithWhereUniqueWithoutWhatsAppCampaignsInput[]
    createMany?: WhatsAppBulkCampaignCreateManyWhatsAppCampaignsInputEnvelope
    set?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    disconnect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    delete?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    connect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    update?: WhatsAppBulkCampaignUpdateWithWhereUniqueWithoutWhatsAppCampaignsInput | WhatsAppBulkCampaignUpdateWithWhereUniqueWithoutWhatsAppCampaignsInput[]
    updateMany?: WhatsAppBulkCampaignUpdateManyWithWhereWithoutWhatsAppCampaignsInput | WhatsAppBulkCampaignUpdateManyWithWhereWithoutWhatsAppCampaignsInput[]
    deleteMany?: WhatsAppBulkCampaignScalarWhereInput | WhatsAppBulkCampaignScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutWhatsAppCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutWhatsAppCampaignsInput, UserUncheckedCreateWithoutWhatsAppCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppCampaignsInput
    upsert?: UserUpsertWithoutWhatsAppCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsAppCampaignsInput, UserUpdateWithoutWhatsAppCampaignsInput>, UserUncheckedUpdateWithoutWhatsAppCampaignsInput>
  }

  export type WhatsAppBulkCampaignUncheckedUpdateManyWithoutWhatsAppCampaignsNestedInput = {
    create?: XOR<WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput, WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput> | WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput[] | WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput[]
    connectOrCreate?: WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppCampaignsInput | WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppCampaignsInput[]
    upsert?: WhatsAppBulkCampaignUpsertWithWhereUniqueWithoutWhatsAppCampaignsInput | WhatsAppBulkCampaignUpsertWithWhereUniqueWithoutWhatsAppCampaignsInput[]
    createMany?: WhatsAppBulkCampaignCreateManyWhatsAppCampaignsInputEnvelope
    set?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    disconnect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    delete?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    connect?: WhatsAppBulkCampaignWhereUniqueInput | WhatsAppBulkCampaignWhereUniqueInput[]
    update?: WhatsAppBulkCampaignUpdateWithWhereUniqueWithoutWhatsAppCampaignsInput | WhatsAppBulkCampaignUpdateWithWhereUniqueWithoutWhatsAppCampaignsInput[]
    updateMany?: WhatsAppBulkCampaignUpdateManyWithWhereWithoutWhatsAppCampaignsInput | WhatsAppBulkCampaignUpdateManyWithWhereWithoutWhatsAppCampaignsInput[]
    deleteMany?: WhatsAppBulkCampaignScalarWhereInput | WhatsAppBulkCampaignScalarWhereInput[]
  }

  export type WhatsAppBulkCampaignItemCreateNestedManyWithoutWhatsAppBulkCampaignsInput = {
    create?: XOR<WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput, WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput> | WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput[] | WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput[]
    connectOrCreate?: WhatsAppBulkCampaignItemCreateOrConnectWithoutWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemCreateOrConnectWithoutWhatsAppBulkCampaignsInput[]
    createMany?: WhatsAppBulkCampaignItemCreateManyWhatsAppBulkCampaignsInputEnvelope
    connect?: WhatsAppBulkCampaignItemWhereUniqueInput | WhatsAppBulkCampaignItemWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutWhatsAppBulkCampaignsInput = {
    create?: XOR<UserCreateWithoutWhatsAppBulkCampaignsInput, UserUncheckedCreateWithoutWhatsAppBulkCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppBulkCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppCampaignCreateNestedOneWithoutWhatsAppBulkCampaignsInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutWhatsAppBulkCampaignsInput, WhatsAppCampaignUncheckedCreateWithoutWhatsAppBulkCampaignsInput>
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutWhatsAppBulkCampaignsInput
    connect?: WhatsAppCampaignWhereUniqueInput
  }

  export type WhatsAppBulkCampaignItemUncheckedCreateNestedManyWithoutWhatsAppBulkCampaignsInput = {
    create?: XOR<WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput, WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput> | WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput[] | WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput[]
    connectOrCreate?: WhatsAppBulkCampaignItemCreateOrConnectWithoutWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemCreateOrConnectWithoutWhatsAppBulkCampaignsInput[]
    createMany?: WhatsAppBulkCampaignItemCreateManyWhatsAppBulkCampaignsInputEnvelope
    connect?: WhatsAppBulkCampaignItemWhereUniqueInput | WhatsAppBulkCampaignItemWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type WhatsAppBulkCampaignItemUpdateManyWithoutWhatsAppBulkCampaignsNestedInput = {
    create?: XOR<WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput, WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput> | WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput[] | WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput[]
    connectOrCreate?: WhatsAppBulkCampaignItemCreateOrConnectWithoutWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemCreateOrConnectWithoutWhatsAppBulkCampaignsInput[]
    upsert?: WhatsAppBulkCampaignItemUpsertWithWhereUniqueWithoutWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemUpsertWithWhereUniqueWithoutWhatsAppBulkCampaignsInput[]
    createMany?: WhatsAppBulkCampaignItemCreateManyWhatsAppBulkCampaignsInputEnvelope
    set?: WhatsAppBulkCampaignItemWhereUniqueInput | WhatsAppBulkCampaignItemWhereUniqueInput[]
    disconnect?: WhatsAppBulkCampaignItemWhereUniqueInput | WhatsAppBulkCampaignItemWhereUniqueInput[]
    delete?: WhatsAppBulkCampaignItemWhereUniqueInput | WhatsAppBulkCampaignItemWhereUniqueInput[]
    connect?: WhatsAppBulkCampaignItemWhereUniqueInput | WhatsAppBulkCampaignItemWhereUniqueInput[]
    update?: WhatsAppBulkCampaignItemUpdateWithWhereUniqueWithoutWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemUpdateWithWhereUniqueWithoutWhatsAppBulkCampaignsInput[]
    updateMany?: WhatsAppBulkCampaignItemUpdateManyWithWhereWithoutWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemUpdateManyWithWhereWithoutWhatsAppBulkCampaignsInput[]
    deleteMany?: WhatsAppBulkCampaignItemScalarWhereInput | WhatsAppBulkCampaignItemScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutWhatsAppBulkCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutWhatsAppBulkCampaignsInput, UserUncheckedCreateWithoutWhatsAppBulkCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppBulkCampaignsInput
    upsert?: UserUpsertWithoutWhatsAppBulkCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsAppBulkCampaignsInput, UserUpdateWithoutWhatsAppBulkCampaignsInput>, UserUncheckedUpdateWithoutWhatsAppBulkCampaignsInput>
  }

  export type WhatsAppCampaignUpdateOneWithoutWhatsAppBulkCampaignsNestedInput = {
    create?: XOR<WhatsAppCampaignCreateWithoutWhatsAppBulkCampaignsInput, WhatsAppCampaignUncheckedCreateWithoutWhatsAppBulkCampaignsInput>
    connectOrCreate?: WhatsAppCampaignCreateOrConnectWithoutWhatsAppBulkCampaignsInput
    upsert?: WhatsAppCampaignUpsertWithoutWhatsAppBulkCampaignsInput
    disconnect?: WhatsAppCampaignWhereInput | boolean
    delete?: WhatsAppCampaignWhereInput | boolean
    connect?: WhatsAppCampaignWhereUniqueInput
    update?: XOR<XOR<WhatsAppCampaignUpdateToOneWithWhereWithoutWhatsAppBulkCampaignsInput, WhatsAppCampaignUpdateWithoutWhatsAppBulkCampaignsInput>, WhatsAppCampaignUncheckedUpdateWithoutWhatsAppBulkCampaignsInput>
  }

  export type WhatsAppBulkCampaignItemUncheckedUpdateManyWithoutWhatsAppBulkCampaignsNestedInput = {
    create?: XOR<WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput, WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput> | WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput[] | WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput[]
    connectOrCreate?: WhatsAppBulkCampaignItemCreateOrConnectWithoutWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemCreateOrConnectWithoutWhatsAppBulkCampaignsInput[]
    upsert?: WhatsAppBulkCampaignItemUpsertWithWhereUniqueWithoutWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemUpsertWithWhereUniqueWithoutWhatsAppBulkCampaignsInput[]
    createMany?: WhatsAppBulkCampaignItemCreateManyWhatsAppBulkCampaignsInputEnvelope
    set?: WhatsAppBulkCampaignItemWhereUniqueInput | WhatsAppBulkCampaignItemWhereUniqueInput[]
    disconnect?: WhatsAppBulkCampaignItemWhereUniqueInput | WhatsAppBulkCampaignItemWhereUniqueInput[]
    delete?: WhatsAppBulkCampaignItemWhereUniqueInput | WhatsAppBulkCampaignItemWhereUniqueInput[]
    connect?: WhatsAppBulkCampaignItemWhereUniqueInput | WhatsAppBulkCampaignItemWhereUniqueInput[]
    update?: WhatsAppBulkCampaignItemUpdateWithWhereUniqueWithoutWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemUpdateWithWhereUniqueWithoutWhatsAppBulkCampaignsInput[]
    updateMany?: WhatsAppBulkCampaignItemUpdateManyWithWhereWithoutWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemUpdateManyWithWhereWithoutWhatsAppBulkCampaignsInput[]
    deleteMany?: WhatsAppBulkCampaignItemScalarWhereInput | WhatsAppBulkCampaignItemScalarWhereInput[]
  }

  export type WhatsAppBulkCampaignCreateNestedOneWithoutWhatsAppBulkCampaignItemsInput = {
    create?: XOR<WhatsAppBulkCampaignCreateWithoutWhatsAppBulkCampaignItemsInput, WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppBulkCampaignItemsInput>
    connectOrCreate?: WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppBulkCampaignItemsInput
    connect?: WhatsAppBulkCampaignWhereUniqueInput
  }

  export type WhatsAppBulkCampaignUpdateOneRequiredWithoutWhatsAppBulkCampaignItemsNestedInput = {
    create?: XOR<WhatsAppBulkCampaignCreateWithoutWhatsAppBulkCampaignItemsInput, WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppBulkCampaignItemsInput>
    connectOrCreate?: WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppBulkCampaignItemsInput
    upsert?: WhatsAppBulkCampaignUpsertWithoutWhatsAppBulkCampaignItemsInput
    connect?: WhatsAppBulkCampaignWhereUniqueInput
    update?: XOR<XOR<WhatsAppBulkCampaignUpdateToOneWithWhereWithoutWhatsAppBulkCampaignItemsInput, WhatsAppBulkCampaignUpdateWithoutWhatsAppBulkCampaignItemsInput>, WhatsAppBulkCampaignUncheckedUpdateWithoutWhatsAppBulkCampaignItemsInput>
  }

  export type UserCreateNestedOneWithoutWhatsAppContactInput = {
    create?: XOR<UserCreateWithoutWhatsAppContactInput, UserUncheckedCreateWithoutWhatsAppContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppContactInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutWhatsAppContactNestedInput = {
    create?: XOR<UserCreateWithoutWhatsAppContactInput, UserUncheckedCreateWithoutWhatsAppContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppContactInput
    upsert?: UserUpsertWithoutWhatsAppContactInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsAppContactInput, UserUpdateWithoutWhatsAppContactInput>, UserUncheckedUpdateWithoutWhatsAppContactInput>
  }

  export type UserCreateNestedOneWithoutWhatsAppMessageStatsInput = {
    create?: XOR<UserCreateWithoutWhatsAppMessageStatsInput, UserUncheckedCreateWithoutWhatsAppMessageStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppMessageStatsInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppSessionCreateNestedOneWithoutWhatsAppMessageStatsInput = {
    create?: XOR<WhatsAppSessionCreateWithoutWhatsAppMessageStatsInput, WhatsAppSessionUncheckedCreateWithoutWhatsAppMessageStatsInput>
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutWhatsAppMessageStatsInput
    connect?: WhatsAppSessionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWhatsAppMessageStatsNestedInput = {
    create?: XOR<UserCreateWithoutWhatsAppMessageStatsInput, UserUncheckedCreateWithoutWhatsAppMessageStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppMessageStatsInput
    upsert?: UserUpsertWithoutWhatsAppMessageStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsAppMessageStatsInput, UserUpdateWithoutWhatsAppMessageStatsInput>, UserUncheckedUpdateWithoutWhatsAppMessageStatsInput>
  }

  export type WhatsAppSessionUpdateOneRequiredWithoutWhatsAppMessageStatsNestedInput = {
    create?: XOR<WhatsAppSessionCreateWithoutWhatsAppMessageStatsInput, WhatsAppSessionUncheckedCreateWithoutWhatsAppMessageStatsInput>
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutWhatsAppMessageStatsInput
    upsert?: WhatsAppSessionUpsertWithoutWhatsAppMessageStatsInput
    connect?: WhatsAppSessionWhereUniqueInput
    update?: XOR<XOR<WhatsAppSessionUpdateToOneWithWhereWithoutWhatsAppMessageStatsInput, WhatsAppSessionUpdateWithoutWhatsAppMessageStatsInput>, WhatsAppSessionUncheckedUpdateWithoutWhatsAppMessageStatsInput>
  }

  export type UserCreateNestedOneWithoutWhatsAppAIBotsInput = {
    create?: XOR<UserCreateWithoutWhatsAppAIBotsInput, UserUncheckedCreateWithoutWhatsAppAIBotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppAIBotsInput
    connect?: UserWhereUniqueInput
  }

  export type AIBotSessionBindingCreateNestedManyWithoutBotInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutBotInput, AIBotSessionBindingUncheckedCreateWithoutBotInput> | AIBotSessionBindingCreateWithoutBotInput[] | AIBotSessionBindingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutBotInput | AIBotSessionBindingCreateOrConnectWithoutBotInput[]
    createMany?: AIBotSessionBindingCreateManyBotInputEnvelope
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
  }

  export type BotKnowledgeBindingCreateNestedManyWithoutBotInput = {
    create?: XOR<BotKnowledgeBindingCreateWithoutBotInput, BotKnowledgeBindingUncheckedCreateWithoutBotInput> | BotKnowledgeBindingCreateWithoutBotInput[] | BotKnowledgeBindingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotKnowledgeBindingCreateOrConnectWithoutBotInput | BotKnowledgeBindingCreateOrConnectWithoutBotInput[]
    createMany?: BotKnowledgeBindingCreateManyBotInputEnvelope
    connect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
  }

  export type AIBotSessionBindingUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutBotInput, AIBotSessionBindingUncheckedCreateWithoutBotInput> | AIBotSessionBindingCreateWithoutBotInput[] | AIBotSessionBindingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutBotInput | AIBotSessionBindingCreateOrConnectWithoutBotInput[]
    createMany?: AIBotSessionBindingCreateManyBotInputEnvelope
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
  }

  export type BotKnowledgeBindingUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<BotKnowledgeBindingCreateWithoutBotInput, BotKnowledgeBindingUncheckedCreateWithoutBotInput> | BotKnowledgeBindingCreateWithoutBotInput[] | BotKnowledgeBindingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotKnowledgeBindingCreateOrConnectWithoutBotInput | BotKnowledgeBindingCreateOrConnectWithoutBotInput[]
    createMany?: BotKnowledgeBindingCreateManyBotInputEnvelope
    connect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWhatsAppAIBotsNestedInput = {
    create?: XOR<UserCreateWithoutWhatsAppAIBotsInput, UserUncheckedCreateWithoutWhatsAppAIBotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppAIBotsInput
    upsert?: UserUpsertWithoutWhatsAppAIBotsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsAppAIBotsInput, UserUpdateWithoutWhatsAppAIBotsInput>, UserUncheckedUpdateWithoutWhatsAppAIBotsInput>
  }

  export type AIBotSessionBindingUpdateManyWithoutBotNestedInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutBotInput, AIBotSessionBindingUncheckedCreateWithoutBotInput> | AIBotSessionBindingCreateWithoutBotInput[] | AIBotSessionBindingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutBotInput | AIBotSessionBindingCreateOrConnectWithoutBotInput[]
    upsert?: AIBotSessionBindingUpsertWithWhereUniqueWithoutBotInput | AIBotSessionBindingUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: AIBotSessionBindingCreateManyBotInputEnvelope
    set?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    disconnect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    delete?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    update?: AIBotSessionBindingUpdateWithWhereUniqueWithoutBotInput | AIBotSessionBindingUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: AIBotSessionBindingUpdateManyWithWhereWithoutBotInput | AIBotSessionBindingUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: AIBotSessionBindingScalarWhereInput | AIBotSessionBindingScalarWhereInput[]
  }

  export type BotKnowledgeBindingUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotKnowledgeBindingCreateWithoutBotInput, BotKnowledgeBindingUncheckedCreateWithoutBotInput> | BotKnowledgeBindingCreateWithoutBotInput[] | BotKnowledgeBindingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotKnowledgeBindingCreateOrConnectWithoutBotInput | BotKnowledgeBindingCreateOrConnectWithoutBotInput[]
    upsert?: BotKnowledgeBindingUpsertWithWhereUniqueWithoutBotInput | BotKnowledgeBindingUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotKnowledgeBindingCreateManyBotInputEnvelope
    set?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    disconnect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    delete?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    connect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    update?: BotKnowledgeBindingUpdateWithWhereUniqueWithoutBotInput | BotKnowledgeBindingUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotKnowledgeBindingUpdateManyWithWhereWithoutBotInput | BotKnowledgeBindingUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotKnowledgeBindingScalarWhereInput | BotKnowledgeBindingScalarWhereInput[]
  }

  export type AIBotSessionBindingUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<AIBotSessionBindingCreateWithoutBotInput, AIBotSessionBindingUncheckedCreateWithoutBotInput> | AIBotSessionBindingCreateWithoutBotInput[] | AIBotSessionBindingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: AIBotSessionBindingCreateOrConnectWithoutBotInput | AIBotSessionBindingCreateOrConnectWithoutBotInput[]
    upsert?: AIBotSessionBindingUpsertWithWhereUniqueWithoutBotInput | AIBotSessionBindingUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: AIBotSessionBindingCreateManyBotInputEnvelope
    set?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    disconnect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    delete?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    connect?: AIBotSessionBindingWhereUniqueInput | AIBotSessionBindingWhereUniqueInput[]
    update?: AIBotSessionBindingUpdateWithWhereUniqueWithoutBotInput | AIBotSessionBindingUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: AIBotSessionBindingUpdateManyWithWhereWithoutBotInput | AIBotSessionBindingUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: AIBotSessionBindingScalarWhereInput | AIBotSessionBindingScalarWhereInput[]
  }

  export type BotKnowledgeBindingUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotKnowledgeBindingCreateWithoutBotInput, BotKnowledgeBindingUncheckedCreateWithoutBotInput> | BotKnowledgeBindingCreateWithoutBotInput[] | BotKnowledgeBindingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotKnowledgeBindingCreateOrConnectWithoutBotInput | BotKnowledgeBindingCreateOrConnectWithoutBotInput[]
    upsert?: BotKnowledgeBindingUpsertWithWhereUniqueWithoutBotInput | BotKnowledgeBindingUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotKnowledgeBindingCreateManyBotInputEnvelope
    set?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    disconnect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    delete?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    connect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    update?: BotKnowledgeBindingUpdateWithWhereUniqueWithoutBotInput | BotKnowledgeBindingUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotKnowledgeBindingUpdateManyWithWhereWithoutBotInput | BotKnowledgeBindingUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotKnowledgeBindingScalarWhereInput | BotKnowledgeBindingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAiDocumentsInput = {
    create?: XOR<UserCreateWithoutAiDocumentsInput, UserUncheckedCreateWithoutAiDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type BotKnowledgeBindingCreateNestedManyWithoutDocumentInput = {
    create?: XOR<BotKnowledgeBindingCreateWithoutDocumentInput, BotKnowledgeBindingUncheckedCreateWithoutDocumentInput> | BotKnowledgeBindingCreateWithoutDocumentInput[] | BotKnowledgeBindingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: BotKnowledgeBindingCreateOrConnectWithoutDocumentInput | BotKnowledgeBindingCreateOrConnectWithoutDocumentInput[]
    createMany?: BotKnowledgeBindingCreateManyDocumentInputEnvelope
    connect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
  }

  export type BotKnowledgeBindingUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<BotKnowledgeBindingCreateWithoutDocumentInput, BotKnowledgeBindingUncheckedCreateWithoutDocumentInput> | BotKnowledgeBindingCreateWithoutDocumentInput[] | BotKnowledgeBindingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: BotKnowledgeBindingCreateOrConnectWithoutDocumentInput | BotKnowledgeBindingCreateOrConnectWithoutDocumentInput[]
    createMany?: BotKnowledgeBindingCreateManyDocumentInputEnvelope
    connect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAiDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutAiDocumentsInput, UserUncheckedCreateWithoutAiDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiDocumentsInput
    upsert?: UserUpsertWithoutAiDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiDocumentsInput, UserUpdateWithoutAiDocumentsInput>, UserUncheckedUpdateWithoutAiDocumentsInput>
  }

  export type BotKnowledgeBindingUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<BotKnowledgeBindingCreateWithoutDocumentInput, BotKnowledgeBindingUncheckedCreateWithoutDocumentInput> | BotKnowledgeBindingCreateWithoutDocumentInput[] | BotKnowledgeBindingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: BotKnowledgeBindingCreateOrConnectWithoutDocumentInput | BotKnowledgeBindingCreateOrConnectWithoutDocumentInput[]
    upsert?: BotKnowledgeBindingUpsertWithWhereUniqueWithoutDocumentInput | BotKnowledgeBindingUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: BotKnowledgeBindingCreateManyDocumentInputEnvelope
    set?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    disconnect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    delete?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    connect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    update?: BotKnowledgeBindingUpdateWithWhereUniqueWithoutDocumentInput | BotKnowledgeBindingUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: BotKnowledgeBindingUpdateManyWithWhereWithoutDocumentInput | BotKnowledgeBindingUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: BotKnowledgeBindingScalarWhereInput | BotKnowledgeBindingScalarWhereInput[]
  }

  export type BotKnowledgeBindingUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<BotKnowledgeBindingCreateWithoutDocumentInput, BotKnowledgeBindingUncheckedCreateWithoutDocumentInput> | BotKnowledgeBindingCreateWithoutDocumentInput[] | BotKnowledgeBindingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: BotKnowledgeBindingCreateOrConnectWithoutDocumentInput | BotKnowledgeBindingCreateOrConnectWithoutDocumentInput[]
    upsert?: BotKnowledgeBindingUpsertWithWhereUniqueWithoutDocumentInput | BotKnowledgeBindingUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: BotKnowledgeBindingCreateManyDocumentInputEnvelope
    set?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    disconnect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    delete?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    connect?: BotKnowledgeBindingWhereUniqueInput | BotKnowledgeBindingWhereUniqueInput[]
    update?: BotKnowledgeBindingUpdateWithWhereUniqueWithoutDocumentInput | BotKnowledgeBindingUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: BotKnowledgeBindingUpdateManyWithWhereWithoutDocumentInput | BotKnowledgeBindingUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: BotKnowledgeBindingScalarWhereInput | BotKnowledgeBindingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAiUsageLogsInput = {
    create?: XOR<UserCreateWithoutAiUsageLogsInput, UserUncheckedCreateWithoutAiUsageLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiUsageLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAiUsageLogsNestedInput = {
    create?: XOR<UserCreateWithoutAiUsageLogsInput, UserUncheckedCreateWithoutAiUsageLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiUsageLogsInput
    upsert?: UserUpsertWithoutAiUsageLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiUsageLogsInput, UserUpdateWithoutAiUsageLogsInput>, UserUncheckedUpdateWithoutAiUsageLogsInput>
  }

  export type WhatsAppAIBotCreateNestedOneWithoutAiBotSessionBindingsInput = {
    create?: XOR<WhatsAppAIBotCreateWithoutAiBotSessionBindingsInput, WhatsAppAIBotUncheckedCreateWithoutAiBotSessionBindingsInput>
    connectOrCreate?: WhatsAppAIBotCreateOrConnectWithoutAiBotSessionBindingsInput
    connect?: WhatsAppAIBotWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAiBotSessionBindingsInput = {
    create?: XOR<UserCreateWithoutAiBotSessionBindingsInput, UserUncheckedCreateWithoutAiBotSessionBindingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiBotSessionBindingsInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppSessionCreateNestedOneWithoutAiBotSessionBindingsInput = {
    create?: XOR<WhatsAppSessionCreateWithoutAiBotSessionBindingsInput, WhatsAppSessionUncheckedCreateWithoutAiBotSessionBindingsInput>
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutAiBotSessionBindingsInput
    connect?: WhatsAppSessionWhereUniqueInput
  }

  export type WhatsAppAIBotUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput = {
    create?: XOR<WhatsAppAIBotCreateWithoutAiBotSessionBindingsInput, WhatsAppAIBotUncheckedCreateWithoutAiBotSessionBindingsInput>
    connectOrCreate?: WhatsAppAIBotCreateOrConnectWithoutAiBotSessionBindingsInput
    upsert?: WhatsAppAIBotUpsertWithoutAiBotSessionBindingsInput
    connect?: WhatsAppAIBotWhereUniqueInput
    update?: XOR<XOR<WhatsAppAIBotUpdateToOneWithWhereWithoutAiBotSessionBindingsInput, WhatsAppAIBotUpdateWithoutAiBotSessionBindingsInput>, WhatsAppAIBotUncheckedUpdateWithoutAiBotSessionBindingsInput>
  }

  export type UserUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput = {
    create?: XOR<UserCreateWithoutAiBotSessionBindingsInput, UserUncheckedCreateWithoutAiBotSessionBindingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiBotSessionBindingsInput
    upsert?: UserUpsertWithoutAiBotSessionBindingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiBotSessionBindingsInput, UserUpdateWithoutAiBotSessionBindingsInput>, UserUncheckedUpdateWithoutAiBotSessionBindingsInput>
  }

  export type WhatsAppSessionUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput = {
    create?: XOR<WhatsAppSessionCreateWithoutAiBotSessionBindingsInput, WhatsAppSessionUncheckedCreateWithoutAiBotSessionBindingsInput>
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutAiBotSessionBindingsInput
    upsert?: WhatsAppSessionUpsertWithoutAiBotSessionBindingsInput
    connect?: WhatsAppSessionWhereUniqueInput
    update?: XOR<XOR<WhatsAppSessionUpdateToOneWithWhereWithoutAiBotSessionBindingsInput, WhatsAppSessionUpdateWithoutAiBotSessionBindingsInput>, WhatsAppSessionUncheckedUpdateWithoutAiBotSessionBindingsInput>
  }

  export type WhatsAppAIBotCreateNestedOneWithoutBotKnowledgeBindingsInput = {
    create?: XOR<WhatsAppAIBotCreateWithoutBotKnowledgeBindingsInput, WhatsAppAIBotUncheckedCreateWithoutBotKnowledgeBindingsInput>
    connectOrCreate?: WhatsAppAIBotCreateOrConnectWithoutBotKnowledgeBindingsInput
    connect?: WhatsAppAIBotWhereUniqueInput
  }

  export type AIDocumentCreateNestedOneWithoutBotKnowledgeBindingsInput = {
    create?: XOR<AIDocumentCreateWithoutBotKnowledgeBindingsInput, AIDocumentUncheckedCreateWithoutBotKnowledgeBindingsInput>
    connectOrCreate?: AIDocumentCreateOrConnectWithoutBotKnowledgeBindingsInput
    connect?: AIDocumentWhereUniqueInput
  }

  export type WhatsAppAIBotUpdateOneRequiredWithoutBotKnowledgeBindingsNestedInput = {
    create?: XOR<WhatsAppAIBotCreateWithoutBotKnowledgeBindingsInput, WhatsAppAIBotUncheckedCreateWithoutBotKnowledgeBindingsInput>
    connectOrCreate?: WhatsAppAIBotCreateOrConnectWithoutBotKnowledgeBindingsInput
    upsert?: WhatsAppAIBotUpsertWithoutBotKnowledgeBindingsInput
    connect?: WhatsAppAIBotWhereUniqueInput
    update?: XOR<XOR<WhatsAppAIBotUpdateToOneWithWhereWithoutBotKnowledgeBindingsInput, WhatsAppAIBotUpdateWithoutBotKnowledgeBindingsInput>, WhatsAppAIBotUncheckedUpdateWithoutBotKnowledgeBindingsInput>
  }

  export type AIDocumentUpdateOneRequiredWithoutBotKnowledgeBindingsNestedInput = {
    create?: XOR<AIDocumentCreateWithoutBotKnowledgeBindingsInput, AIDocumentUncheckedCreateWithoutBotKnowledgeBindingsInput>
    connectOrCreate?: AIDocumentCreateOrConnectWithoutBotKnowledgeBindingsInput
    upsert?: AIDocumentUpsertWithoutBotKnowledgeBindingsInput
    connect?: AIDocumentWhereUniqueInput
    update?: XOR<XOR<AIDocumentUpdateToOneWithWhereWithoutBotKnowledgeBindingsInput, AIDocumentUpdateWithoutBotKnowledgeBindingsInput>, AIDocumentUncheckedUpdateWithoutBotKnowledgeBindingsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ServicesWhatsappCustomersCreateWithoutCustomerInput = {
    id?: string
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string
    updatedAt?: Date | string
    lastSubscriptionAt?: Date | string
    package: WhatsappApiPackageCreateNestedOneWithoutWhatsappCustomersInput
  }

  export type ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput = {
    id?: string
    packageId: string
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string
    updatedAt?: Date | string
    lastSubscriptionAt?: Date | string
  }

  export type ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    create: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput>
  }

  export type ServicesWhatsappCustomersCreateManyCustomerInputEnvelope = {
    data: ServicesWhatsappCustomersCreateManyCustomerInput | ServicesWhatsappCustomersCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VoucherUsageCreateWithoutUserInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    transaction?: TransactionCreateNestedOneWithoutVoucherUsageInput
    voucher: VoucherCreateNestedOneWithoutVoucherUsageInput
  }

  export type VoucherUsageUncheckedCreateWithoutUserInput = {
    id?: string
    voucherId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageCreateOrConnectWithoutUserInput = {
    where: VoucherUsageWhereUniqueInput
    create: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput>
  }

  export type VoucherUsageCreateManyUserInputEnvelope = {
    data: VoucherUsageCreateManyUserInput | VoucherUsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppBulkCampaignCreateWithoutUserInput = {
    id?: bigint | number
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemCreateNestedManyWithoutWhatsAppBulkCampaignsInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedOneWithoutWhatsAppBulkCampaignsInput
  }

  export type WhatsAppBulkCampaignUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    campaign_id?: bigint | number | null
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemUncheckedCreateNestedManyWithoutWhatsAppBulkCampaignsInput
  }

  export type WhatsAppBulkCampaignCreateOrConnectWithoutUserInput = {
    where: WhatsAppBulkCampaignWhereUniqueInput
    create: XOR<WhatsAppBulkCampaignCreateWithoutUserInput, WhatsAppBulkCampaignUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppBulkCampaignCreateManyUserInputEnvelope = {
    data: WhatsAppBulkCampaignCreateManyUserInput | WhatsAppBulkCampaignCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppCampaignCreateWithoutUserInput = {
    id?: bigint | number
    name: string
    type: string
    status?: string | null
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutWhatsAppCampaignsInput
  }

  export type WhatsAppCampaignUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    name: string
    type: string
    status?: string | null
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutWhatsAppCampaignsInput
  }

  export type WhatsAppCampaignCreateOrConnectWithoutUserInput = {
    where: WhatsAppCampaignWhereUniqueInput
    create: XOR<WhatsAppCampaignCreateWithoutUserInput, WhatsAppCampaignUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppCampaignCreateManyUserInputEnvelope = {
    data: WhatsAppCampaignCreateManyUserInput | WhatsAppCampaignCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppContactCreateWithoutUserInput = {
    id?: bigint | number
    phone: string
    name?: string | null
    full_name?: string | null
    push_name?: string | null
    short?: string | null
    notify?: string | null
    business?: boolean | null
    verified?: boolean | null
    source?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppContactUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    phone: string
    name?: string | null
    full_name?: string | null
    push_name?: string | null
    short?: string | null
    notify?: string | null
    business?: boolean | null
    verified?: boolean | null
    source?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppContactCreateOrConnectWithoutUserInput = {
    where: WhatsAppContactWhereUniqueInput
    create: XOR<WhatsAppContactCreateWithoutUserInput, WhatsAppContactUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppContactCreateManyUserInputEnvelope = {
    data: WhatsAppContactCreateManyUserInput | WhatsAppContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppSessionCreateWithoutUserInput = {
    id?: string
    sessionId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    sessionName: string
    connected?: boolean
    events?: string | null
    expiration?: number
    isSystemSession?: boolean
    jid?: string | null
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: string | null
    qrcode?: string | null
    s3AccessKey?: string | null
    s3Bucket?: string | null
    s3Enabled?: boolean
    s3Endpoint?: string | null
    s3MediaDelivery?: string | null
    s3PathStyle?: boolean
    s3PublicUrl?: string | null
    s3Region?: string | null
    s3RetentionDays?: number
    s3SecretKey?: string | null
    token: string
    webhook?: string | null
    autoReadMessages?: boolean
    typingIndicator?: boolean
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutSessionInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    sessionName: string
    connected?: boolean
    events?: string | null
    expiration?: number
    isSystemSession?: boolean
    jid?: string | null
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: string | null
    qrcode?: string | null
    s3AccessKey?: string | null
    s3Bucket?: string | null
    s3Enabled?: boolean
    s3Endpoint?: string | null
    s3MediaDelivery?: string | null
    s3PathStyle?: boolean
    s3PublicUrl?: string | null
    s3Region?: string | null
    s3RetentionDays?: number
    s3SecretKey?: string | null
    token: string
    webhook?: string | null
    autoReadMessages?: boolean
    typingIndicator?: boolean
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutSessionInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionCreateOrConnectWithoutUserInput = {
    where: WhatsAppSessionWhereUniqueInput
    create: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppSessionCreateManyUserInputEnvelope = {
    data: WhatsAppSessionCreateManyUserInput | WhatsAppSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppMessageStatsCreateWithoutUserInput = {
    id?: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    textMessagesSent?: number
    textMessagesFailed?: number
    imageMessagesSent?: number
    imageMessagesFailed?: number
    documentMessagesSent?: number
    documentMessagesFailed?: number
    audioMessagesSent?: number
    audioMessagesFailed?: number
    stickerMessagesSent?: number
    stickerMessagesFailed?: number
    videoMessagesSent?: number
    videoMessagesFailed?: number
    locationMessagesSent?: number
    locationMessagesFailed?: number
    contactMessagesSent?: number
    contactMessagesFailed?: number
    templateMessagesSent?: number
    templateMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: WhatsAppSessionCreateNestedOneWithoutWhatsAppMessageStatsInput
  }

  export type WhatsAppMessageStatsUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    textMessagesSent?: number
    textMessagesFailed?: number
    imageMessagesSent?: number
    imageMessagesFailed?: number
    documentMessagesSent?: number
    documentMessagesFailed?: number
    audioMessagesSent?: number
    audioMessagesFailed?: number
    stickerMessagesSent?: number
    stickerMessagesFailed?: number
    videoMessagesSent?: number
    videoMessagesFailed?: number
    locationMessagesSent?: number
    locationMessagesFailed?: number
    contactMessagesSent?: number
    contactMessagesFailed?: number
    templateMessagesSent?: number
    templateMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsCreateOrConnectWithoutUserInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    create: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppMessageStatsCreateManyUserInputEnvelope = {
    data: WhatsAppMessageStatsCreateManyUserInput | WhatsAppMessageStatsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppAIBotCreateWithoutUserInput = {
    id?: string
    name?: string
    isActive?: boolean
    systemPrompt?: string | null
    fallbackText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutBotInput
    botKnowledgeBindings?: BotKnowledgeBindingCreateNestedManyWithoutBotInput
  }

  export type WhatsAppAIBotUncheckedCreateWithoutUserInput = {
    id?: string
    name?: string
    isActive?: boolean
    systemPrompt?: string | null
    fallbackText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutBotInput
    botKnowledgeBindings?: BotKnowledgeBindingUncheckedCreateNestedManyWithoutBotInput
  }

  export type WhatsAppAIBotCreateOrConnectWithoutUserInput = {
    where: WhatsAppAIBotWhereUniqueInput
    create: XOR<WhatsAppAIBotCreateWithoutUserInput, WhatsAppAIBotUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppAIBotCreateManyUserInputEnvelope = {
    data: WhatsAppAIBotCreateManyUserInput | WhatsAppAIBotCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIDocumentCreateWithoutUserInput = {
    id?: string
    title: string
    kind?: string
    content: string
    embeddingId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    botKnowledgeBindings?: BotKnowledgeBindingCreateNestedManyWithoutDocumentInput
  }

  export type AIDocumentUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    kind?: string
    content: string
    embeddingId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    botKnowledgeBindings?: BotKnowledgeBindingUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type AIDocumentCreateOrConnectWithoutUserInput = {
    where: AIDocumentWhereUniqueInput
    create: XOR<AIDocumentCreateWithoutUserInput, AIDocumentUncheckedCreateWithoutUserInput>
  }

  export type AIDocumentCreateManyUserInputEnvelope = {
    data: AIDocumentCreateManyUserInput | AIDocumentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIUsageLogCreateWithoutUserInput = {
    id?: string
    sessionId?: string | null
    inputTokens?: number
    outputTokens?: number
    totalTokens?: number
    latencyMs?: number
    status?: string
    errorReason?: string | null
    createdAt?: Date | string
  }

  export type AIUsageLogUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId?: string | null
    inputTokens?: number
    outputTokens?: number
    totalTokens?: number
    latencyMs?: number
    status?: string
    errorReason?: string | null
    createdAt?: Date | string
  }

  export type AIUsageLogCreateOrConnectWithoutUserInput = {
    where: AIUsageLogWhereUniqueInput
    create: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput>
  }

  export type AIUsageLogCreateManyUserInputEnvelope = {
    data: AIUsageLogCreateManyUserInput | AIUsageLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AIBotSessionBindingCreateWithoutUserInput = {
    id?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: WhatsAppAIBotCreateNestedOneWithoutAiBotSessionBindingsInput
    session: WhatsAppSessionCreateNestedOneWithoutAiBotSessionBindingsInput
  }

  export type AIBotSessionBindingUncheckedCreateWithoutUserInput = {
    id?: string
    botId: string
    sessionId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIBotSessionBindingCreateOrConnectWithoutUserInput = {
    where: AIBotSessionBindingWhereUniqueInput
    create: XOR<AIBotSessionBindingCreateWithoutUserInput, AIBotSessionBindingUncheckedCreateWithoutUserInput>
  }

  export type AIBotSessionBindingCreateManyUserInputEnvelope = {
    data: AIBotSessionBindingCreateManyUserInput | AIBotSessionBindingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    update: XOR<ServicesWhatsappCustomersUpdateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedUpdateWithoutCustomerInput>
    create: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput>
  }

  export type ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    data: XOR<ServicesWhatsappCustomersUpdateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedUpdateWithoutCustomerInput>
  }

  export type ServicesWhatsappCustomersUpdateManyWithWhereWithoutCustomerInput = {
    where: ServicesWhatsappCustomersScalarWhereInput
    data: XOR<ServicesWhatsappCustomersUpdateManyMutationInput, ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ServicesWhatsappCustomersScalarWhereInput = {
    AND?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
    OR?: ServicesWhatsappCustomersScalarWhereInput[]
    NOT?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
    id?: StringFilter<"ServicesWhatsappCustomers"> | string
    customerId?: StringFilter<"ServicesWhatsappCustomers"> | string
    packageId?: StringFilter<"ServicesWhatsappCustomers"> | string
    status?: StringFilter<"ServicesWhatsappCustomers"> | string
    expiredAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    activatedAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    lastSubscriptionAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    status?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    discountAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    originalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    voucherId?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    currency?: StringFilter<"Transaction"> | string
    finalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    lastUsed?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    id?: StringFilter<"UserSession"> | string
  }

  export type VoucherUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: VoucherUsageWhereUniqueInput
    update: XOR<VoucherUsageUpdateWithoutUserInput, VoucherUsageUncheckedUpdateWithoutUserInput>
    create: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput>
  }

  export type VoucherUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: VoucherUsageWhereUniqueInput
    data: XOR<VoucherUsageUpdateWithoutUserInput, VoucherUsageUncheckedUpdateWithoutUserInput>
  }

  export type VoucherUsageUpdateManyWithWhereWithoutUserInput = {
    where: VoucherUsageScalarWhereInput
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type VoucherUsageScalarWhereInput = {
    AND?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
    OR?: VoucherUsageScalarWhereInput[]
    NOT?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
    id?: StringFilter<"VoucherUsage"> | string
    voucherId?: StringFilter<"VoucherUsage"> | string
    userId?: StringFilter<"VoucherUsage"> | string
    transactionId?: StringNullableFilter<"VoucherUsage"> | string | null
    usedAt?: DateTimeFilter<"VoucherUsage"> | Date | string
    discountAmount?: DecimalFilter<"VoucherUsage"> | Decimal | DecimalJsLike | number | string
  }

  export type WhatsAppBulkCampaignUpsertWithWhereUniqueWithoutUserInput = {
    where: WhatsAppBulkCampaignWhereUniqueInput
    update: XOR<WhatsAppBulkCampaignUpdateWithoutUserInput, WhatsAppBulkCampaignUncheckedUpdateWithoutUserInput>
    create: XOR<WhatsAppBulkCampaignCreateWithoutUserInput, WhatsAppBulkCampaignUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppBulkCampaignUpdateWithWhereUniqueWithoutUserInput = {
    where: WhatsAppBulkCampaignWhereUniqueInput
    data: XOR<WhatsAppBulkCampaignUpdateWithoutUserInput, WhatsAppBulkCampaignUncheckedUpdateWithoutUserInput>
  }

  export type WhatsAppBulkCampaignUpdateManyWithWhereWithoutUserInput = {
    where: WhatsAppBulkCampaignScalarWhereInput
    data: XOR<WhatsAppBulkCampaignUpdateManyMutationInput, WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserInput>
  }

  export type WhatsAppBulkCampaignScalarWhereInput = {
    AND?: WhatsAppBulkCampaignScalarWhereInput | WhatsAppBulkCampaignScalarWhereInput[]
    OR?: WhatsAppBulkCampaignScalarWhereInput[]
    NOT?: WhatsAppBulkCampaignScalarWhereInput | WhatsAppBulkCampaignScalarWhereInput[]
    id?: BigIntFilter<"WhatsAppBulkCampaign"> | bigint | number
    user_id?: StringFilter<"WhatsAppBulkCampaign"> | string
    campaign_id?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    name?: StringFilter<"WhatsAppBulkCampaign"> | string
    type?: StringFilter<"WhatsAppBulkCampaign"> | string
    message_body?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    image_url?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    image_base64?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    caption?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    status?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    total_count?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    sent_count?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    failed_count?: BigIntNullableFilter<"WhatsAppBulkCampaign"> | bigint | number | null
    scheduled_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    timezone?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    processed_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    error_message?: StringNullableFilter<"WhatsAppBulkCampaign"> | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppBulkCampaign"> | Date | string | null
  }

  export type WhatsAppCampaignUpsertWithWhereUniqueWithoutUserInput = {
    where: WhatsAppCampaignWhereUniqueInput
    update: XOR<WhatsAppCampaignUpdateWithoutUserInput, WhatsAppCampaignUncheckedUpdateWithoutUserInput>
    create: XOR<WhatsAppCampaignCreateWithoutUserInput, WhatsAppCampaignUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppCampaignUpdateWithWhereUniqueWithoutUserInput = {
    where: WhatsAppCampaignWhereUniqueInput
    data: XOR<WhatsAppCampaignUpdateWithoutUserInput, WhatsAppCampaignUncheckedUpdateWithoutUserInput>
  }

  export type WhatsAppCampaignUpdateManyWithWhereWithoutUserInput = {
    where: WhatsAppCampaignScalarWhereInput
    data: XOR<WhatsAppCampaignUpdateManyMutationInput, WhatsAppCampaignUncheckedUpdateManyWithoutUserInput>
  }

  export type WhatsAppCampaignScalarWhereInput = {
    AND?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
    OR?: WhatsAppCampaignScalarWhereInput[]
    NOT?: WhatsAppCampaignScalarWhereInput | WhatsAppCampaignScalarWhereInput[]
    id?: BigIntFilter<"WhatsAppCampaign"> | bigint | number
    user_id?: StringFilter<"WhatsAppCampaign"> | string
    name?: StringFilter<"WhatsAppCampaign"> | string
    type?: StringFilter<"WhatsAppCampaign"> | string
    status?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    message_body?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    image_url?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    image_base64?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    caption?: StringNullableFilter<"WhatsAppCampaign"> | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppCampaign"> | Date | string | null
  }

  export type WhatsAppContactUpsertWithWhereUniqueWithoutUserInput = {
    where: WhatsAppContactWhereUniqueInput
    update: XOR<WhatsAppContactUpdateWithoutUserInput, WhatsAppContactUncheckedUpdateWithoutUserInput>
    create: XOR<WhatsAppContactCreateWithoutUserInput, WhatsAppContactUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppContactUpdateWithWhereUniqueWithoutUserInput = {
    where: WhatsAppContactWhereUniqueInput
    data: XOR<WhatsAppContactUpdateWithoutUserInput, WhatsAppContactUncheckedUpdateWithoutUserInput>
  }

  export type WhatsAppContactUpdateManyWithWhereWithoutUserInput = {
    where: WhatsAppContactScalarWhereInput
    data: XOR<WhatsAppContactUpdateManyMutationInput, WhatsAppContactUncheckedUpdateManyWithoutUserInput>
  }

  export type WhatsAppContactScalarWhereInput = {
    AND?: WhatsAppContactScalarWhereInput | WhatsAppContactScalarWhereInput[]
    OR?: WhatsAppContactScalarWhereInput[]
    NOT?: WhatsAppContactScalarWhereInput | WhatsAppContactScalarWhereInput[]
    id?: BigIntFilter<"WhatsAppContact"> | bigint | number
    user_id?: StringFilter<"WhatsAppContact"> | string
    phone?: StringFilter<"WhatsAppContact"> | string
    name?: StringNullableFilter<"WhatsAppContact"> | string | null
    full_name?: StringNullableFilter<"WhatsAppContact"> | string | null
    push_name?: StringNullableFilter<"WhatsAppContact"> | string | null
    short?: StringNullableFilter<"WhatsAppContact"> | string | null
    notify?: StringNullableFilter<"WhatsAppContact"> | string | null
    business?: BoolNullableFilter<"WhatsAppContact"> | boolean | null
    verified?: BoolNullableFilter<"WhatsAppContact"> | boolean | null
    source?: StringNullableFilter<"WhatsAppContact"> | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
  }

  export type WhatsAppSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: WhatsAppSessionWhereUniqueInput
    update: XOR<WhatsAppSessionUpdateWithoutUserInput, WhatsAppSessionUncheckedUpdateWithoutUserInput>
    create: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: WhatsAppSessionWhereUniqueInput
    data: XOR<WhatsAppSessionUpdateWithoutUserInput, WhatsAppSessionUncheckedUpdateWithoutUserInput>
  }

  export type WhatsAppSessionUpdateManyWithWhereWithoutUserInput = {
    where: WhatsAppSessionScalarWhereInput
    data: XOR<WhatsAppSessionUpdateManyMutationInput, WhatsAppSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type WhatsAppSessionScalarWhereInput = {
    AND?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
    OR?: WhatsAppSessionScalarWhereInput[]
    NOT?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
    id?: StringFilter<"WhatsAppSession"> | string
    sessionId?: StringFilter<"WhatsAppSession"> | string
    userId?: StringNullableFilter<"WhatsAppSession"> | string | null
    status?: StringFilter<"WhatsAppSession"> | string
    createdAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    message?: StringNullableFilter<"WhatsAppSession"> | string | null
    sessionName?: StringFilter<"WhatsAppSession"> | string
    connected?: BoolFilter<"WhatsAppSession"> | boolean
    events?: StringNullableFilter<"WhatsAppSession"> | string | null
    expiration?: IntFilter<"WhatsAppSession"> | number
    isSystemSession?: BoolFilter<"WhatsAppSession"> | boolean
    jid?: StringNullableFilter<"WhatsAppSession"> | string | null
    loggedIn?: BoolFilter<"WhatsAppSession"> | boolean
    proxyEnabled?: BoolFilter<"WhatsAppSession"> | boolean
    proxyUrl?: StringNullableFilter<"WhatsAppSession"> | string | null
    qrcode?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3AccessKey?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3Bucket?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3Enabled?: BoolFilter<"WhatsAppSession"> | boolean
    s3Endpoint?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3MediaDelivery?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3PathStyle?: BoolFilter<"WhatsAppSession"> | boolean
    s3PublicUrl?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3Region?: StringNullableFilter<"WhatsAppSession"> | string | null
    s3RetentionDays?: IntFilter<"WhatsAppSession"> | number
    s3SecretKey?: StringNullableFilter<"WhatsAppSession"> | string | null
    token?: StringFilter<"WhatsAppSession"> | string
    webhook?: StringNullableFilter<"WhatsAppSession"> | string | null
    autoReadMessages?: BoolFilter<"WhatsAppSession"> | boolean
    typingIndicator?: BoolFilter<"WhatsAppSession"> | boolean
  }

  export type WhatsAppMessageStatsUpsertWithWhereUniqueWithoutUserInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    update: XOR<WhatsAppMessageStatsUpdateWithoutUserInput, WhatsAppMessageStatsUncheckedUpdateWithoutUserInput>
    create: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppMessageStatsUpdateWithWhereUniqueWithoutUserInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    data: XOR<WhatsAppMessageStatsUpdateWithoutUserInput, WhatsAppMessageStatsUncheckedUpdateWithoutUserInput>
  }

  export type WhatsAppMessageStatsUpdateManyWithWhereWithoutUserInput = {
    where: WhatsAppMessageStatsScalarWhereInput
    data: XOR<WhatsAppMessageStatsUpdateManyMutationInput, WhatsAppMessageStatsUncheckedUpdateManyWithoutUserInput>
  }

  export type WhatsAppMessageStatsScalarWhereInput = {
    AND?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
    OR?: WhatsAppMessageStatsScalarWhereInput[]
    NOT?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
    id?: StringFilter<"WhatsAppMessageStats"> | string
    userId?: StringFilter<"WhatsAppMessageStats"> | string
    sessionId?: StringFilter<"WhatsAppMessageStats"> | string
    totalMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    totalMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    textMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    textMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    imageMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    imageMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    documentMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    documentMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    audioMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    audioMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    stickerMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    stickerMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    videoMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    videoMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    locationMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    locationMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    contactMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    contactMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    templateMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    templateMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    lastMessageSentAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    lastMessageFailedAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
  }

  export type WhatsAppAIBotUpsertWithWhereUniqueWithoutUserInput = {
    where: WhatsAppAIBotWhereUniqueInput
    update: XOR<WhatsAppAIBotUpdateWithoutUserInput, WhatsAppAIBotUncheckedUpdateWithoutUserInput>
    create: XOR<WhatsAppAIBotCreateWithoutUserInput, WhatsAppAIBotUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppAIBotUpdateWithWhereUniqueWithoutUserInput = {
    where: WhatsAppAIBotWhereUniqueInput
    data: XOR<WhatsAppAIBotUpdateWithoutUserInput, WhatsAppAIBotUncheckedUpdateWithoutUserInput>
  }

  export type WhatsAppAIBotUpdateManyWithWhereWithoutUserInput = {
    where: WhatsAppAIBotScalarWhereInput
    data: XOR<WhatsAppAIBotUpdateManyMutationInput, WhatsAppAIBotUncheckedUpdateManyWithoutUserInput>
  }

  export type WhatsAppAIBotScalarWhereInput = {
    AND?: WhatsAppAIBotScalarWhereInput | WhatsAppAIBotScalarWhereInput[]
    OR?: WhatsAppAIBotScalarWhereInput[]
    NOT?: WhatsAppAIBotScalarWhereInput | WhatsAppAIBotScalarWhereInput[]
    id?: StringFilter<"WhatsAppAIBot"> | string
    userId?: StringFilter<"WhatsAppAIBot"> | string
    name?: StringFilter<"WhatsAppAIBot"> | string
    isActive?: BoolFilter<"WhatsAppAIBot"> | boolean
    systemPrompt?: StringNullableFilter<"WhatsAppAIBot"> | string | null
    fallbackText?: StringNullableFilter<"WhatsAppAIBot"> | string | null
    createdAt?: DateTimeFilter<"WhatsAppAIBot"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppAIBot"> | Date | string
  }

  export type AIDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: AIDocumentWhereUniqueInput
    update: XOR<AIDocumentUpdateWithoutUserInput, AIDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<AIDocumentCreateWithoutUserInput, AIDocumentUncheckedCreateWithoutUserInput>
  }

  export type AIDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: AIDocumentWhereUniqueInput
    data: XOR<AIDocumentUpdateWithoutUserInput, AIDocumentUncheckedUpdateWithoutUserInput>
  }

  export type AIDocumentUpdateManyWithWhereWithoutUserInput = {
    where: AIDocumentScalarWhereInput
    data: XOR<AIDocumentUpdateManyMutationInput, AIDocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type AIDocumentScalarWhereInput = {
    AND?: AIDocumentScalarWhereInput | AIDocumentScalarWhereInput[]
    OR?: AIDocumentScalarWhereInput[]
    NOT?: AIDocumentScalarWhereInput | AIDocumentScalarWhereInput[]
    id?: StringFilter<"AIDocument"> | string
    userId?: StringFilter<"AIDocument"> | string
    title?: StringFilter<"AIDocument"> | string
    kind?: StringFilter<"AIDocument"> | string
    content?: StringFilter<"AIDocument"> | string
    embeddingId?: StringNullableFilter<"AIDocument"> | string | null
    isActive?: BoolFilter<"AIDocument"> | boolean
    createdAt?: DateTimeFilter<"AIDocument"> | Date | string
    updatedAt?: DateTimeFilter<"AIDocument"> | Date | string
  }

  export type AIUsageLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AIUsageLogWhereUniqueInput
    update: XOR<AIUsageLogUpdateWithoutUserInput, AIUsageLogUncheckedUpdateWithoutUserInput>
    create: XOR<AIUsageLogCreateWithoutUserInput, AIUsageLogUncheckedCreateWithoutUserInput>
  }

  export type AIUsageLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AIUsageLogWhereUniqueInput
    data: XOR<AIUsageLogUpdateWithoutUserInput, AIUsageLogUncheckedUpdateWithoutUserInput>
  }

  export type AIUsageLogUpdateManyWithWhereWithoutUserInput = {
    where: AIUsageLogScalarWhereInput
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AIUsageLogScalarWhereInput = {
    AND?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
    OR?: AIUsageLogScalarWhereInput[]
    NOT?: AIUsageLogScalarWhereInput | AIUsageLogScalarWhereInput[]
    id?: StringFilter<"AIUsageLog"> | string
    userId?: StringFilter<"AIUsageLog"> | string
    sessionId?: StringNullableFilter<"AIUsageLog"> | string | null
    inputTokens?: IntFilter<"AIUsageLog"> | number
    outputTokens?: IntFilter<"AIUsageLog"> | number
    totalTokens?: IntFilter<"AIUsageLog"> | number
    latencyMs?: IntFilter<"AIUsageLog"> | number
    status?: StringFilter<"AIUsageLog"> | string
    errorReason?: StringNullableFilter<"AIUsageLog"> | string | null
    createdAt?: DateTimeFilter<"AIUsageLog"> | Date | string
  }

  export type AIBotSessionBindingUpsertWithWhereUniqueWithoutUserInput = {
    where: AIBotSessionBindingWhereUniqueInput
    update: XOR<AIBotSessionBindingUpdateWithoutUserInput, AIBotSessionBindingUncheckedUpdateWithoutUserInput>
    create: XOR<AIBotSessionBindingCreateWithoutUserInput, AIBotSessionBindingUncheckedCreateWithoutUserInput>
  }

  export type AIBotSessionBindingUpdateWithWhereUniqueWithoutUserInput = {
    where: AIBotSessionBindingWhereUniqueInput
    data: XOR<AIBotSessionBindingUpdateWithoutUserInput, AIBotSessionBindingUncheckedUpdateWithoutUserInput>
  }

  export type AIBotSessionBindingUpdateManyWithWhereWithoutUserInput = {
    where: AIBotSessionBindingScalarWhereInput
    data: XOR<AIBotSessionBindingUpdateManyMutationInput, AIBotSessionBindingUncheckedUpdateManyWithoutUserInput>
  }

  export type AIBotSessionBindingScalarWhereInput = {
    AND?: AIBotSessionBindingScalarWhereInput | AIBotSessionBindingScalarWhereInput[]
    OR?: AIBotSessionBindingScalarWhereInput[]
    NOT?: AIBotSessionBindingScalarWhereInput | AIBotSessionBindingScalarWhereInput[]
    id?: StringFilter<"AIBotSessionBinding"> | string
    userId?: StringFilter<"AIBotSessionBinding"> | string
    botId?: StringFilter<"AIBotSessionBinding"> | string
    sessionId?: StringFilter<"AIBotSessionBinding"> | string
    isActive?: BoolFilter<"AIBotSessionBinding"> | boolean
    createdAt?: DateTimeFilter<"AIBotSessionBinding"> | Date | string
    updatedAt?: DateTimeFilter<"AIBotSessionBinding"> | Date | string
  }

  export type UserCreateWithoutWhatsAppSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhatsAppSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhatsAppSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsAppSessionsInput, UserUncheckedCreateWithoutWhatsAppSessionsInput>
  }

  export type WhatsAppMessageStatsCreateWithoutSessionInput = {
    id?: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    textMessagesSent?: number
    textMessagesFailed?: number
    imageMessagesSent?: number
    imageMessagesFailed?: number
    documentMessagesSent?: number
    documentMessagesFailed?: number
    audioMessagesSent?: number
    audioMessagesFailed?: number
    stickerMessagesSent?: number
    stickerMessagesFailed?: number
    videoMessagesSent?: number
    videoMessagesFailed?: number
    locationMessagesSent?: number
    locationMessagesFailed?: number
    contactMessagesSent?: number
    contactMessagesFailed?: number
    templateMessagesSent?: number
    templateMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWhatsAppMessageStatsInput
  }

  export type WhatsAppMessageStatsUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    textMessagesSent?: number
    textMessagesFailed?: number
    imageMessagesSent?: number
    imageMessagesFailed?: number
    documentMessagesSent?: number
    documentMessagesFailed?: number
    audioMessagesSent?: number
    audioMessagesFailed?: number
    stickerMessagesSent?: number
    stickerMessagesFailed?: number
    videoMessagesSent?: number
    videoMessagesFailed?: number
    locationMessagesSent?: number
    locationMessagesFailed?: number
    contactMessagesSent?: number
    contactMessagesFailed?: number
    templateMessagesSent?: number
    templateMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsCreateOrConnectWithoutSessionInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    create: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput>
  }

  export type WhatsAppMessageStatsCreateManySessionInputEnvelope = {
    data: WhatsAppMessageStatsCreateManySessionInput | WhatsAppMessageStatsCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type AIBotSessionBindingCreateWithoutSessionInput = {
    id?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: WhatsAppAIBotCreateNestedOneWithoutAiBotSessionBindingsInput
    user: UserCreateNestedOneWithoutAiBotSessionBindingsInput
  }

  export type AIBotSessionBindingUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    botId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIBotSessionBindingCreateOrConnectWithoutSessionInput = {
    where: AIBotSessionBindingWhereUniqueInput
    create: XOR<AIBotSessionBindingCreateWithoutSessionInput, AIBotSessionBindingUncheckedCreateWithoutSessionInput>
  }

  export type AIBotSessionBindingCreateManySessionInputEnvelope = {
    data: AIBotSessionBindingCreateManySessionInput | AIBotSessionBindingCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWhatsAppSessionsInput = {
    update: XOR<UserUpdateWithoutWhatsAppSessionsInput, UserUncheckedUpdateWithoutWhatsAppSessionsInput>
    create: XOR<UserCreateWithoutWhatsAppSessionsInput, UserUncheckedCreateWithoutWhatsAppSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsAppSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsAppSessionsInput, UserUncheckedUpdateWithoutWhatsAppSessionsInput>
  }

  export type UserUpdateWithoutWhatsAppSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsAppSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WhatsAppMessageStatsUpsertWithWhereUniqueWithoutSessionInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    update: XOR<WhatsAppMessageStatsUpdateWithoutSessionInput, WhatsAppMessageStatsUncheckedUpdateWithoutSessionInput>
    create: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput>
  }

  export type WhatsAppMessageStatsUpdateWithWhereUniqueWithoutSessionInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    data: XOR<WhatsAppMessageStatsUpdateWithoutSessionInput, WhatsAppMessageStatsUncheckedUpdateWithoutSessionInput>
  }

  export type WhatsAppMessageStatsUpdateManyWithWhereWithoutSessionInput = {
    where: WhatsAppMessageStatsScalarWhereInput
    data: XOR<WhatsAppMessageStatsUpdateManyMutationInput, WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionInput>
  }

  export type AIBotSessionBindingUpsertWithWhereUniqueWithoutSessionInput = {
    where: AIBotSessionBindingWhereUniqueInput
    update: XOR<AIBotSessionBindingUpdateWithoutSessionInput, AIBotSessionBindingUncheckedUpdateWithoutSessionInput>
    create: XOR<AIBotSessionBindingCreateWithoutSessionInput, AIBotSessionBindingUncheckedCreateWithoutSessionInput>
  }

  export type AIBotSessionBindingUpdateWithWhereUniqueWithoutSessionInput = {
    where: AIBotSessionBindingWhereUniqueInput
    data: XOR<AIBotSessionBindingUpdateWithoutSessionInput, AIBotSessionBindingUncheckedUpdateWithoutSessionInput>
  }

  export type AIBotSessionBindingUpdateManyWithWhereWithoutSessionInput = {
    where: AIBotSessionBindingScalarWhereInput
    data: XOR<AIBotSessionBindingUpdateManyMutationInput, AIBotSessionBindingUncheckedUpdateManyWithoutSessionInput>
  }

  export type PaymentCreateWithoutTransactionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    status?: string
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    externalId?: string | null
    paymentUrl?: string | null
    serviceFee?: Decimal | DecimalJsLike | number | string | null
    adminNotes?: string | null
    adminAction?: string | null
    adminUserId?: string | null
    actionDate?: Date | string | null
    gatewayProvider?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentUncheckedCreateWithoutTransactionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    status?: string
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    externalId?: string | null
    paymentUrl?: string | null
    serviceFee?: Decimal | DecimalJsLike | number | string | null
    adminNotes?: string | null
    adminAction?: string | null
    adminUserId?: string | null
    actionDate?: Date | string | null
    gatewayProvider?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateOrConnectWithoutTransactionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type VoucherCreateWithoutTransactionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voucherUsage?: VoucherUsageCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutTransactionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutTransactionsInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutTransactionsInput, VoucherUncheckedCreateWithoutTransactionsInput>
  }

  export type TransactionWhatsappServiceCreateWithoutTransactionInput = {
    id?: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    whatsappPackage: WhatsappApiPackageCreateNestedOneWithoutWhatsappTransactionsInput
  }

  export type TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput = {
    id?: string
    whatsappPackageId: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionWhatsappServiceCreateOrConnectWithoutTransactionInput = {
    where: TransactionWhatsappServiceWhereUniqueInput
    create: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
  }

  export type VoucherUsageCreateWithoutTransactionInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    user: UserCreateNestedOneWithoutVoucherUsageInput
    voucher: VoucherCreateNestedOneWithoutVoucherUsageInput
  }

  export type VoucherUsageUncheckedCreateWithoutTransactionInput = {
    id?: string
    voucherId: string
    userId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageCreateOrConnectWithoutTransactionInput = {
    where: VoucherUsageWhereUniqueInput
    create: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput>
  }

  export type VoucherUsageCreateManyTransactionInputEnvelope = {
    data: VoucherUsageCreateManyTransactionInput | VoucherUsageCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithoutTransactionInput = {
    update: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutTransactionInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoucherUpsertWithoutTransactionsInput = {
    update: XOR<VoucherUpdateWithoutTransactionsInput, VoucherUncheckedUpdateWithoutTransactionsInput>
    create: XOR<VoucherCreateWithoutTransactionsInput, VoucherUncheckedCreateWithoutTransactionsInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutTransactionsInput, VoucherUncheckedUpdateWithoutTransactionsInput>
  }

  export type VoucherUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherUsage?: VoucherUsageUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type TransactionWhatsappServiceUpsertWithoutTransactionInput = {
    update: XOR<TransactionWhatsappServiceUpdateWithoutTransactionInput, TransactionWhatsappServiceUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
    where?: TransactionWhatsappServiceWhereInput
  }

  export type TransactionWhatsappServiceUpdateToOneWithWhereWithoutTransactionInput = {
    where?: TransactionWhatsappServiceWhereInput
    data: XOR<TransactionWhatsappServiceUpdateWithoutTransactionInput, TransactionWhatsappServiceUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionWhatsappServiceUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappPackage?: WhatsappApiPackageUpdateOneRequiredWithoutWhatsappTransactionsNestedInput
  }

  export type TransactionWhatsappServiceUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsappPackageId?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUsageUpsertWithWhereUniqueWithoutTransactionInput = {
    where: VoucherUsageWhereUniqueInput
    update: XOR<VoucherUsageUpdateWithoutTransactionInput, VoucherUsageUncheckedUpdateWithoutTransactionInput>
    create: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput>
  }

  export type VoucherUsageUpdateWithWhereUniqueWithoutTransactionInput = {
    where: VoucherUsageWhereUniqueInput
    data: XOR<VoucherUsageUpdateWithoutTransactionInput, VoucherUsageUncheckedUpdateWithoutTransactionInput>
  }

  export type VoucherUsageUpdateManyWithWhereWithoutTransactionInput = {
    where: VoucherUsageScalarWhereInput
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionCreateWithoutWhatsappTransactionInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutWhatsappTransactionInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutWhatsappTransactionInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutWhatsappTransactionInput, TransactionUncheckedCreateWithoutWhatsappTransactionInput>
  }

  export type WhatsappApiPackageCreateWithoutWhatsappTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutPackageInput
  }

  export type WhatsappApiPackageUncheckedCreateWithoutWhatsappTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutPackageInput
  }

  export type WhatsappApiPackageCreateOrConnectWithoutWhatsappTransactionsInput = {
    where: WhatsappApiPackageWhereUniqueInput
    create: XOR<WhatsappApiPackageCreateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappTransactionsInput>
  }

  export type TransactionUpsertWithoutWhatsappTransactionInput = {
    update: XOR<TransactionUpdateWithoutWhatsappTransactionInput, TransactionUncheckedUpdateWithoutWhatsappTransactionInput>
    create: XOR<TransactionCreateWithoutWhatsappTransactionInput, TransactionUncheckedCreateWithoutWhatsappTransactionInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutWhatsappTransactionInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutWhatsappTransactionInput, TransactionUncheckedUpdateWithoutWhatsappTransactionInput>
  }

  export type TransactionUpdateWithoutWhatsappTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutWhatsappTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type WhatsappApiPackageUpsertWithoutWhatsappTransactionsInput = {
    update: XOR<WhatsappApiPackageUpdateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedUpdateWithoutWhatsappTransactionsInput>
    create: XOR<WhatsappApiPackageCreateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappTransactionsInput>
    where?: WhatsappApiPackageWhereInput
  }

  export type WhatsappApiPackageUpdateToOneWithWhereWithoutWhatsappTransactionsInput = {
    where?: WhatsappApiPackageWhereInput
    data: XOR<WhatsappApiPackageUpdateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedUpdateWithoutWhatsappTransactionsInput>
  }

  export type WhatsappApiPackageUpdateWithoutWhatsappTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutPackageNestedInput
  }

  export type WhatsappApiPackageUncheckedUpdateWithoutWhatsappTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type TransactionCreateWithoutPaymentInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPaymentInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPaymentInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
  }

  export type TransactionUpsertWithoutPaymentInput = {
    update: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutPaymentInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
  }

  export type TransactionUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type ServicesWhatsappCustomersCreateWithoutPackageInput = {
    id?: string
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string
    updatedAt?: Date | string
    lastSubscriptionAt?: Date | string
    customer: UserCreateNestedOneWithoutWhatsappCustomersInput
  }

  export type ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput = {
    id?: string
    customerId: string
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string
    updatedAt?: Date | string
    lastSubscriptionAt?: Date | string
  }

  export type ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    create: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput>
  }

  export type ServicesWhatsappCustomersCreateManyPackageInputEnvelope = {
    data: ServicesWhatsappCustomersCreateManyPackageInput | ServicesWhatsappCustomersCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type TransactionWhatsappServiceCreateWithoutWhatsappPackageInput = {
    id?: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    transaction: TransactionCreateNestedOneWithoutWhatsappTransactionInput
  }

  export type TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput = {
    id?: string
    transactionId: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput = {
    where: TransactionWhatsappServiceWhereUniqueInput
    create: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput>
  }

  export type TransactionWhatsappServiceCreateManyWhatsappPackageInputEnvelope = {
    data: TransactionWhatsappServiceCreateManyWhatsappPackageInput | TransactionWhatsappServiceCreateManyWhatsappPackageInput[]
    skipDuplicates?: boolean
  }

  export type ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutPackageInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    update: XOR<ServicesWhatsappCustomersUpdateWithoutPackageInput, ServicesWhatsappCustomersUncheckedUpdateWithoutPackageInput>
    create: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput>
  }

  export type ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutPackageInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    data: XOR<ServicesWhatsappCustomersUpdateWithoutPackageInput, ServicesWhatsappCustomersUncheckedUpdateWithoutPackageInput>
  }

  export type ServicesWhatsappCustomersUpdateManyWithWhereWithoutPackageInput = {
    where: ServicesWhatsappCustomersScalarWhereInput
    data: XOR<ServicesWhatsappCustomersUpdateManyMutationInput, ServicesWhatsappCustomersUncheckedUpdateManyWithoutPackageInput>
  }

  export type TransactionWhatsappServiceUpsertWithWhereUniqueWithoutWhatsappPackageInput = {
    where: TransactionWhatsappServiceWhereUniqueInput
    update: XOR<TransactionWhatsappServiceUpdateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedUpdateWithoutWhatsappPackageInput>
    create: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput>
  }

  export type TransactionWhatsappServiceUpdateWithWhereUniqueWithoutWhatsappPackageInput = {
    where: TransactionWhatsappServiceWhereUniqueInput
    data: XOR<TransactionWhatsappServiceUpdateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedUpdateWithoutWhatsappPackageInput>
  }

  export type TransactionWhatsappServiceUpdateManyWithWhereWithoutWhatsappPackageInput = {
    where: TransactionWhatsappServiceScalarWhereInput
    data: XOR<TransactionWhatsappServiceUpdateManyMutationInput, TransactionWhatsappServiceUncheckedUpdateManyWithoutWhatsappPackageInput>
  }

  export type TransactionWhatsappServiceScalarWhereInput = {
    AND?: TransactionWhatsappServiceScalarWhereInput | TransactionWhatsappServiceScalarWhereInput[]
    OR?: TransactionWhatsappServiceScalarWhereInput[]
    NOT?: TransactionWhatsappServiceScalarWhereInput | TransactionWhatsappServiceScalarWhereInput[]
    id?: StringFilter<"TransactionWhatsappService"> | string
    transactionId?: StringFilter<"TransactionWhatsappService"> | string
    whatsappPackageId?: StringFilter<"TransactionWhatsappService"> | string
    duration?: StringFilter<"TransactionWhatsappService"> | string
    status?: StringFilter<"TransactionWhatsappService"> | string
    startDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
  }

  export type UserCreateWithoutWhatsappCustomersInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhatsappCustomersInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhatsappCustomersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsappCustomersInput, UserUncheckedCreateWithoutWhatsappCustomersInput>
  }

  export type WhatsappApiPackageCreateWithoutWhatsappCustomersInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappTransactions?: TransactionWhatsappServiceCreateNestedManyWithoutWhatsappPackageInput
  }

  export type WhatsappApiPackageUncheckedCreateWithoutWhatsappCustomersInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappTransactions?: TransactionWhatsappServiceUncheckedCreateNestedManyWithoutWhatsappPackageInput
  }

  export type WhatsappApiPackageCreateOrConnectWithoutWhatsappCustomersInput = {
    where: WhatsappApiPackageWhereUniqueInput
    create: XOR<WhatsappApiPackageCreateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappCustomersInput>
  }

  export type UserUpsertWithoutWhatsappCustomersInput = {
    update: XOR<UserUpdateWithoutWhatsappCustomersInput, UserUncheckedUpdateWithoutWhatsappCustomersInput>
    create: XOR<UserCreateWithoutWhatsappCustomersInput, UserUncheckedCreateWithoutWhatsappCustomersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsappCustomersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsappCustomersInput, UserUncheckedUpdateWithoutWhatsappCustomersInput>
  }

  export type UserUpdateWithoutWhatsappCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsappCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WhatsappApiPackageUpsertWithoutWhatsappCustomersInput = {
    update: XOR<WhatsappApiPackageUpdateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedUpdateWithoutWhatsappCustomersInput>
    create: XOR<WhatsappApiPackageCreateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappCustomersInput>
    where?: WhatsappApiPackageWhereInput
  }

  export type WhatsappApiPackageUpdateToOneWithWhereWithoutWhatsappCustomersInput = {
    where?: WhatsappApiPackageWhereInput
    data: XOR<WhatsappApiPackageUpdateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedUpdateWithoutWhatsappCustomersInput>
  }

  export type WhatsappApiPackageUpdateWithoutWhatsappCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappTransactions?: TransactionWhatsappServiceUpdateManyWithoutWhatsappPackageNestedInput
  }

  export type WhatsappApiPackageUncheckedUpdateWithoutWhatsappCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappTransactions?: TransactionWhatsappServiceUncheckedUpdateManyWithoutWhatsappPackageNestedInput
  }

  export type UserCreateWithoutUserSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
  }

  export type UserUpsertWithoutUserSessionsInput = {
    update: XOR<UserUpdateWithoutUserSessionsInput, UserUncheckedUpdateWithoutUserSessionsInput>
    create: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSessionsInput, UserUncheckedUpdateWithoutUserSessionsInput>
  }

  export type UserUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionCreateWithoutVoucherInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutVoucherInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutVoucherInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput>
  }

  export type TransactionCreateManyVoucherInputEnvelope = {
    data: TransactionCreateManyVoucherInput | TransactionCreateManyVoucherInput[]
    skipDuplicates?: boolean
  }

  export type VoucherUsageCreateWithoutVoucherInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    transaction?: TransactionCreateNestedOneWithoutVoucherUsageInput
    user: UserCreateNestedOneWithoutVoucherUsageInput
  }

  export type VoucherUsageUncheckedCreateWithoutVoucherInput = {
    id?: string
    userId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageCreateOrConnectWithoutVoucherInput = {
    where: VoucherUsageWhereUniqueInput
    create: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherUsageCreateManyVoucherInputEnvelope = {
    data: VoucherUsageCreateManyVoucherInput | VoucherUsageCreateManyVoucherInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutVoucherInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutVoucherInput, TransactionUncheckedUpdateWithoutVoucherInput>
    create: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutVoucherInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutVoucherInput, TransactionUncheckedUpdateWithoutVoucherInput>
  }

  export type TransactionUpdateManyWithWhereWithoutVoucherInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutVoucherInput>
  }

  export type VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput = {
    where: VoucherUsageWhereUniqueInput
    update: XOR<VoucherUsageUpdateWithoutVoucherInput, VoucherUsageUncheckedUpdateWithoutVoucherInput>
    create: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput = {
    where: VoucherUsageWhereUniqueInput
    data: XOR<VoucherUsageUpdateWithoutVoucherInput, VoucherUsageUncheckedUpdateWithoutVoucherInput>
  }

  export type VoucherUsageUpdateManyWithWhereWithoutVoucherInput = {
    where: VoucherUsageScalarWhereInput
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyWithoutVoucherInput>
  }

  export type TransactionCreateWithoutVoucherUsageInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutVoucherUsageInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutVoucherUsageInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutVoucherUsageInput, TransactionUncheckedCreateWithoutVoucherUsageInput>
  }

  export type UserCreateWithoutVoucherUsageInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVoucherUsageInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVoucherUsageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVoucherUsageInput, UserUncheckedCreateWithoutVoucherUsageInput>
  }

  export type VoucherCreateWithoutVoucherUsageInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutVoucherUsageInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutVoucherUsageInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutVoucherUsageInput, VoucherUncheckedCreateWithoutVoucherUsageInput>
  }

  export type TransactionUpsertWithoutVoucherUsageInput = {
    update: XOR<TransactionUpdateWithoutVoucherUsageInput, TransactionUncheckedUpdateWithoutVoucherUsageInput>
    create: XOR<TransactionCreateWithoutVoucherUsageInput, TransactionUncheckedCreateWithoutVoucherUsageInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutVoucherUsageInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutVoucherUsageInput, TransactionUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type TransactionUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type UserUpsertWithoutVoucherUsageInput = {
    update: XOR<UserUpdateWithoutVoucherUsageInput, UserUncheckedUpdateWithoutVoucherUsageInput>
    create: XOR<UserCreateWithoutVoucherUsageInput, UserUncheckedCreateWithoutVoucherUsageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVoucherUsageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVoucherUsageInput, UserUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type UserUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoucherUpsertWithoutVoucherUsageInput = {
    update: XOR<VoucherUpdateWithoutVoucherUsageInput, VoucherUncheckedUpdateWithoutVoucherUsageInput>
    create: XOR<VoucherCreateWithoutVoucherUsageInput, VoucherUncheckedCreateWithoutVoucherUsageInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutVoucherUsageInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutVoucherUsageInput, VoucherUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type VoucherUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type BankDetailCreateWithoutPaymentMethodsInput = {
    id?: string
    bankName: string
    accountNumber: string
    accountName: string
    swiftCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUncheckedCreateWithoutPaymentMethodsInput = {
    id?: string
    bankName: string
    accountNumber: string
    accountName: string
    swiftCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailCreateOrConnectWithoutPaymentMethodsInput = {
    where: BankDetailWhereUniqueInput
    create: XOR<BankDetailCreateWithoutPaymentMethodsInput, BankDetailUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type BankDetailUpsertWithoutPaymentMethodsInput = {
    update: XOR<BankDetailUpdateWithoutPaymentMethodsInput, BankDetailUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<BankDetailCreateWithoutPaymentMethodsInput, BankDetailUncheckedCreateWithoutPaymentMethodsInput>
    where?: BankDetailWhereInput
  }

  export type BankDetailUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: BankDetailWhereInput
    data: XOR<BankDetailUpdateWithoutPaymentMethodsInput, BankDetailUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type BankDetailUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailUncheckedUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateWithoutBankDetailInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    isActive?: boolean
    isSystem?: boolean
    gatewayProvider?: string | null
    gatewayCode?: string | null
    gatewayImageUrl?: string | null
    isGatewayMethod?: boolean
    feeType?: string | null
    feeValue?: Decimal | DecimalJsLike | number | string | null
    minFee?: Decimal | DecimalJsLike | number | string | null
    maxFee?: Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: boolean
    paymentInstructions?: string | null
    instructionType?: string | null
    instructionImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateWithoutBankDetailInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    isActive?: boolean
    isSystem?: boolean
    gatewayProvider?: string | null
    gatewayCode?: string | null
    gatewayImageUrl?: string | null
    isGatewayMethod?: boolean
    feeType?: string | null
    feeValue?: Decimal | DecimalJsLike | number | string | null
    minFee?: Decimal | DecimalJsLike | number | string | null
    maxFee?: Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: boolean
    paymentInstructions?: string | null
    instructionType?: string | null
    instructionImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodCreateOrConnectWithoutBankDetailInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutBankDetailInput, PaymentMethodUncheckedCreateWithoutBankDetailInput>
  }

  export type PaymentMethodCreateManyBankDetailInputEnvelope = {
    data: PaymentMethodCreateManyBankDetailInput | PaymentMethodCreateManyBankDetailInput[]
    skipDuplicates?: boolean
  }

  export type PaymentMethodUpsertWithWhereUniqueWithoutBankDetailInput = {
    where: PaymentMethodWhereUniqueInput
    update: XOR<PaymentMethodUpdateWithoutBankDetailInput, PaymentMethodUncheckedUpdateWithoutBankDetailInput>
    create: XOR<PaymentMethodCreateWithoutBankDetailInput, PaymentMethodUncheckedCreateWithoutBankDetailInput>
  }

  export type PaymentMethodUpdateWithWhereUniqueWithoutBankDetailInput = {
    where: PaymentMethodWhereUniqueInput
    data: XOR<PaymentMethodUpdateWithoutBankDetailInput, PaymentMethodUncheckedUpdateWithoutBankDetailInput>
  }

  export type PaymentMethodUpdateManyWithWhereWithoutBankDetailInput = {
    where: PaymentMethodScalarWhereInput
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyWithoutBankDetailInput>
  }

  export type PaymentMethodScalarWhereInput = {
    AND?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    OR?: PaymentMethodScalarWhereInput[]
    NOT?: PaymentMethodScalarWhereInput | PaymentMethodScalarWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    code?: StringFilter<"PaymentMethod"> | string
    name?: StringFilter<"PaymentMethod"> | string
    description?: StringNullableFilter<"PaymentMethod"> | string | null
    type?: StringFilter<"PaymentMethod"> | string
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    isSystem?: BoolFilter<"PaymentMethod"> | boolean
    gatewayProvider?: StringNullableFilter<"PaymentMethod"> | string | null
    gatewayCode?: StringNullableFilter<"PaymentMethod"> | string | null
    gatewayImageUrl?: StringNullableFilter<"PaymentMethod"> | string | null
    isGatewayMethod?: BoolFilter<"PaymentMethod"> | boolean
    bankDetailId?: StringNullableFilter<"PaymentMethod"> | string | null
    feeType?: StringNullableFilter<"PaymentMethod"> | string | null
    feeValue?: DecimalNullableFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    minFee?: DecimalNullableFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    maxFee?: DecimalNullableFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolFilter<"PaymentMethod"> | boolean
    paymentInstructions?: StringNullableFilter<"PaymentMethod"> | string | null
    instructionType?: StringNullableFilter<"PaymentMethod"> | string | null
    instructionImageUrl?: StringNullableFilter<"PaymentMethod"> | string | null
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput = {
    id?: bigint | number
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemCreateNestedManyWithoutWhatsAppBulkCampaignsInput
    User: UserCreateNestedOneWithoutWhatsAppBulkCampaignsInput
  }

  export type WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput = {
    id?: bigint | number
    user_id: string
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemUncheckedCreateNestedManyWithoutWhatsAppBulkCampaignsInput
  }

  export type WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppCampaignsInput = {
    where: WhatsAppBulkCampaignWhereUniqueInput
    create: XOR<WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput, WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput>
  }

  export type WhatsAppBulkCampaignCreateManyWhatsAppCampaignsInputEnvelope = {
    data: WhatsAppBulkCampaignCreateManyWhatsAppCampaignsInput | WhatsAppBulkCampaignCreateManyWhatsAppCampaignsInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutWhatsAppCampaignsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhatsAppCampaignsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhatsAppCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsAppCampaignsInput, UserUncheckedCreateWithoutWhatsAppCampaignsInput>
  }

  export type WhatsAppBulkCampaignUpsertWithWhereUniqueWithoutWhatsAppCampaignsInput = {
    where: WhatsAppBulkCampaignWhereUniqueInput
    update: XOR<WhatsAppBulkCampaignUpdateWithoutWhatsAppCampaignsInput, WhatsAppBulkCampaignUncheckedUpdateWithoutWhatsAppCampaignsInput>
    create: XOR<WhatsAppBulkCampaignCreateWithoutWhatsAppCampaignsInput, WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppCampaignsInput>
  }

  export type WhatsAppBulkCampaignUpdateWithWhereUniqueWithoutWhatsAppCampaignsInput = {
    where: WhatsAppBulkCampaignWhereUniqueInput
    data: XOR<WhatsAppBulkCampaignUpdateWithoutWhatsAppCampaignsInput, WhatsAppBulkCampaignUncheckedUpdateWithoutWhatsAppCampaignsInput>
  }

  export type WhatsAppBulkCampaignUpdateManyWithWhereWithoutWhatsAppCampaignsInput = {
    where: WhatsAppBulkCampaignScalarWhereInput
    data: XOR<WhatsAppBulkCampaignUpdateManyMutationInput, WhatsAppBulkCampaignUncheckedUpdateManyWithoutWhatsAppCampaignsInput>
  }

  export type UserUpsertWithoutWhatsAppCampaignsInput = {
    update: XOR<UserUpdateWithoutWhatsAppCampaignsInput, UserUncheckedUpdateWithoutWhatsAppCampaignsInput>
    create: XOR<UserCreateWithoutWhatsAppCampaignsInput, UserUncheckedCreateWithoutWhatsAppCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsAppCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsAppCampaignsInput, UserUncheckedUpdateWithoutWhatsAppCampaignsInput>
  }

  export type UserUpdateWithoutWhatsAppCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsAppCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput = {
    id?: bigint | number
    phone: string
    status?: string | null
    message_id?: string | null
    error_message?: string | null
    sent_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput = {
    id?: bigint | number
    phone: string
    status?: string | null
    message_id?: string | null
    error_message?: string | null
    sent_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppBulkCampaignItemCreateOrConnectWithoutWhatsAppBulkCampaignsInput = {
    where: WhatsAppBulkCampaignItemWhereUniqueInput
    create: XOR<WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput, WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput>
  }

  export type WhatsAppBulkCampaignItemCreateManyWhatsAppBulkCampaignsInputEnvelope = {
    data: WhatsAppBulkCampaignItemCreateManyWhatsAppBulkCampaignsInput | WhatsAppBulkCampaignItemCreateManyWhatsAppBulkCampaignsInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutWhatsAppBulkCampaignsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhatsAppBulkCampaignsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhatsAppBulkCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsAppBulkCampaignsInput, UserUncheckedCreateWithoutWhatsAppBulkCampaignsInput>
  }

  export type WhatsAppCampaignCreateWithoutWhatsAppBulkCampaignsInput = {
    id?: bigint | number
    name: string
    type: string
    status?: string | null
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    User: UserCreateNestedOneWithoutWhatsAppCampaignsInput
  }

  export type WhatsAppCampaignUncheckedCreateWithoutWhatsAppBulkCampaignsInput = {
    id?: bigint | number
    user_id: string
    name: string
    type: string
    status?: string | null
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppCampaignCreateOrConnectWithoutWhatsAppBulkCampaignsInput = {
    where: WhatsAppCampaignWhereUniqueInput
    create: XOR<WhatsAppCampaignCreateWithoutWhatsAppBulkCampaignsInput, WhatsAppCampaignUncheckedCreateWithoutWhatsAppBulkCampaignsInput>
  }

  export type WhatsAppBulkCampaignItemUpsertWithWhereUniqueWithoutWhatsAppBulkCampaignsInput = {
    where: WhatsAppBulkCampaignItemWhereUniqueInput
    update: XOR<WhatsAppBulkCampaignItemUpdateWithoutWhatsAppBulkCampaignsInput, WhatsAppBulkCampaignItemUncheckedUpdateWithoutWhatsAppBulkCampaignsInput>
    create: XOR<WhatsAppBulkCampaignItemCreateWithoutWhatsAppBulkCampaignsInput, WhatsAppBulkCampaignItemUncheckedCreateWithoutWhatsAppBulkCampaignsInput>
  }

  export type WhatsAppBulkCampaignItemUpdateWithWhereUniqueWithoutWhatsAppBulkCampaignsInput = {
    where: WhatsAppBulkCampaignItemWhereUniqueInput
    data: XOR<WhatsAppBulkCampaignItemUpdateWithoutWhatsAppBulkCampaignsInput, WhatsAppBulkCampaignItemUncheckedUpdateWithoutWhatsAppBulkCampaignsInput>
  }

  export type WhatsAppBulkCampaignItemUpdateManyWithWhereWithoutWhatsAppBulkCampaignsInput = {
    where: WhatsAppBulkCampaignItemScalarWhereInput
    data: XOR<WhatsAppBulkCampaignItemUpdateManyMutationInput, WhatsAppBulkCampaignItemUncheckedUpdateManyWithoutWhatsAppBulkCampaignsInput>
  }

  export type WhatsAppBulkCampaignItemScalarWhereInput = {
    AND?: WhatsAppBulkCampaignItemScalarWhereInput | WhatsAppBulkCampaignItemScalarWhereInput[]
    OR?: WhatsAppBulkCampaignItemScalarWhereInput[]
    NOT?: WhatsAppBulkCampaignItemScalarWhereInput | WhatsAppBulkCampaignItemScalarWhereInput[]
    id?: BigIntFilter<"WhatsAppBulkCampaignItem"> | bigint | number
    bulk_campaign_id?: BigIntFilter<"WhatsAppBulkCampaignItem"> | bigint | number
    phone?: StringFilter<"WhatsAppBulkCampaignItem"> | string
    status?: StringNullableFilter<"WhatsAppBulkCampaignItem"> | string | null
    message_id?: StringNullableFilter<"WhatsAppBulkCampaignItem"> | string | null
    error_message?: StringNullableFilter<"WhatsAppBulkCampaignItem"> | string | null
    sent_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    created_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"WhatsAppBulkCampaignItem"> | Date | string | null
  }

  export type UserUpsertWithoutWhatsAppBulkCampaignsInput = {
    update: XOR<UserUpdateWithoutWhatsAppBulkCampaignsInput, UserUncheckedUpdateWithoutWhatsAppBulkCampaignsInput>
    create: XOR<UserCreateWithoutWhatsAppBulkCampaignsInput, UserUncheckedCreateWithoutWhatsAppBulkCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsAppBulkCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsAppBulkCampaignsInput, UserUncheckedUpdateWithoutWhatsAppBulkCampaignsInput>
  }

  export type UserUpdateWithoutWhatsAppBulkCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsAppBulkCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WhatsAppCampaignUpsertWithoutWhatsAppBulkCampaignsInput = {
    update: XOR<WhatsAppCampaignUpdateWithoutWhatsAppBulkCampaignsInput, WhatsAppCampaignUncheckedUpdateWithoutWhatsAppBulkCampaignsInput>
    create: XOR<WhatsAppCampaignCreateWithoutWhatsAppBulkCampaignsInput, WhatsAppCampaignUncheckedCreateWithoutWhatsAppBulkCampaignsInput>
    where?: WhatsAppCampaignWhereInput
  }

  export type WhatsAppCampaignUpdateToOneWithWhereWithoutWhatsAppBulkCampaignsInput = {
    where?: WhatsAppCampaignWhereInput
    data: XOR<WhatsAppCampaignUpdateWithoutWhatsAppBulkCampaignsInput, WhatsAppCampaignUncheckedUpdateWithoutWhatsAppBulkCampaignsInput>
  }

  export type WhatsAppCampaignUpdateWithoutWhatsAppBulkCampaignsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutWhatsAppCampaignsNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateWithoutWhatsAppBulkCampaignsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppBulkCampaignCreateWithoutWhatsAppBulkCampaignItemsInput = {
    id?: bigint | number
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    User: UserCreateNestedOneWithoutWhatsAppBulkCampaignsInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedOneWithoutWhatsAppBulkCampaignsInput
  }

  export type WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppBulkCampaignItemsInput = {
    id?: bigint | number
    user_id: string
    campaign_id?: bigint | number | null
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppBulkCampaignCreateOrConnectWithoutWhatsAppBulkCampaignItemsInput = {
    where: WhatsAppBulkCampaignWhereUniqueInput
    create: XOR<WhatsAppBulkCampaignCreateWithoutWhatsAppBulkCampaignItemsInput, WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppBulkCampaignItemsInput>
  }

  export type WhatsAppBulkCampaignUpsertWithoutWhatsAppBulkCampaignItemsInput = {
    update: XOR<WhatsAppBulkCampaignUpdateWithoutWhatsAppBulkCampaignItemsInput, WhatsAppBulkCampaignUncheckedUpdateWithoutWhatsAppBulkCampaignItemsInput>
    create: XOR<WhatsAppBulkCampaignCreateWithoutWhatsAppBulkCampaignItemsInput, WhatsAppBulkCampaignUncheckedCreateWithoutWhatsAppBulkCampaignItemsInput>
    where?: WhatsAppBulkCampaignWhereInput
  }

  export type WhatsAppBulkCampaignUpdateToOneWithWhereWithoutWhatsAppBulkCampaignItemsInput = {
    where?: WhatsAppBulkCampaignWhereInput
    data: XOR<WhatsAppBulkCampaignUpdateWithoutWhatsAppBulkCampaignItemsInput, WhatsAppBulkCampaignUncheckedUpdateWithoutWhatsAppBulkCampaignItemsInput>
  }

  export type WhatsAppBulkCampaignUpdateWithoutWhatsAppBulkCampaignItemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutWhatsAppBulkCampaignsNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateOneWithoutWhatsAppBulkCampaignsNestedInput
  }

  export type WhatsAppBulkCampaignUncheckedUpdateWithoutWhatsAppBulkCampaignItemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: StringFieldUpdateOperationsInput | string
    campaign_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutWhatsAppContactInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhatsAppContactInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhatsAppContactInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsAppContactInput, UserUncheckedCreateWithoutWhatsAppContactInput>
  }

  export type UserUpsertWithoutWhatsAppContactInput = {
    update: XOR<UserUpdateWithoutWhatsAppContactInput, UserUncheckedUpdateWithoutWhatsAppContactInput>
    create: XOR<UserCreateWithoutWhatsAppContactInput, UserUncheckedCreateWithoutWhatsAppContactInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsAppContactInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsAppContactInput, UserUncheckedUpdateWithoutWhatsAppContactInput>
  }

  export type UserUpdateWithoutWhatsAppContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsAppContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWhatsAppMessageStatsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhatsAppMessageStatsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhatsAppMessageStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsAppMessageStatsInput, UserUncheckedCreateWithoutWhatsAppMessageStatsInput>
  }

  export type WhatsAppSessionCreateWithoutWhatsAppMessageStatsInput = {
    id?: string
    sessionId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    sessionName: string
    connected?: boolean
    events?: string | null
    expiration?: number
    isSystemSession?: boolean
    jid?: string | null
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: string | null
    qrcode?: string | null
    s3AccessKey?: string | null
    s3Bucket?: string | null
    s3Enabled?: boolean
    s3Endpoint?: string | null
    s3MediaDelivery?: string | null
    s3PathStyle?: boolean
    s3PublicUrl?: string | null
    s3Region?: string | null
    s3RetentionDays?: number
    s3SecretKey?: string | null
    token: string
    webhook?: string | null
    autoReadMessages?: boolean
    typingIndicator?: boolean
    user?: UserCreateNestedOneWithoutWhatsAppSessionsInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionUncheckedCreateWithoutWhatsAppMessageStatsInput = {
    id?: string
    sessionId: string
    userId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    sessionName: string
    connected?: boolean
    events?: string | null
    expiration?: number
    isSystemSession?: boolean
    jid?: string | null
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: string | null
    qrcode?: string | null
    s3AccessKey?: string | null
    s3Bucket?: string | null
    s3Enabled?: boolean
    s3Endpoint?: string | null
    s3MediaDelivery?: string | null
    s3PathStyle?: boolean
    s3PublicUrl?: string | null
    s3Region?: string | null
    s3RetentionDays?: number
    s3SecretKey?: string | null
    token: string
    webhook?: string | null
    autoReadMessages?: boolean
    typingIndicator?: boolean
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionCreateOrConnectWithoutWhatsAppMessageStatsInput = {
    where: WhatsAppSessionWhereUniqueInput
    create: XOR<WhatsAppSessionCreateWithoutWhatsAppMessageStatsInput, WhatsAppSessionUncheckedCreateWithoutWhatsAppMessageStatsInput>
  }

  export type UserUpsertWithoutWhatsAppMessageStatsInput = {
    update: XOR<UserUpdateWithoutWhatsAppMessageStatsInput, UserUncheckedUpdateWithoutWhatsAppMessageStatsInput>
    create: XOR<UserCreateWithoutWhatsAppMessageStatsInput, UserUncheckedCreateWithoutWhatsAppMessageStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsAppMessageStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsAppMessageStatsInput, UserUncheckedUpdateWithoutWhatsAppMessageStatsInput>
  }

  export type UserUpdateWithoutWhatsAppMessageStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsAppMessageStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WhatsAppSessionUpsertWithoutWhatsAppMessageStatsInput = {
    update: XOR<WhatsAppSessionUpdateWithoutWhatsAppMessageStatsInput, WhatsAppSessionUncheckedUpdateWithoutWhatsAppMessageStatsInput>
    create: XOR<WhatsAppSessionCreateWithoutWhatsAppMessageStatsInput, WhatsAppSessionUncheckedCreateWithoutWhatsAppMessageStatsInput>
    where?: WhatsAppSessionWhereInput
  }

  export type WhatsAppSessionUpdateToOneWithWhereWithoutWhatsAppMessageStatsInput = {
    where?: WhatsAppSessionWhereInput
    data: XOR<WhatsAppSessionUpdateWithoutWhatsAppMessageStatsInput, WhatsAppSessionUncheckedUpdateWithoutWhatsAppMessageStatsInput>
  }

  export type WhatsAppSessionUpdateWithoutWhatsAppMessageStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutWhatsAppSessionsNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateWithoutWhatsAppMessageStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserCreateWithoutWhatsAppAIBotsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhatsAppAIBotsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhatsAppAIBotsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsAppAIBotsInput, UserUncheckedCreateWithoutWhatsAppAIBotsInput>
  }

  export type AIBotSessionBindingCreateWithoutBotInput = {
    id?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAiBotSessionBindingsInput
    session: WhatsAppSessionCreateNestedOneWithoutAiBotSessionBindingsInput
  }

  export type AIBotSessionBindingUncheckedCreateWithoutBotInput = {
    id?: string
    userId: string
    sessionId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIBotSessionBindingCreateOrConnectWithoutBotInput = {
    where: AIBotSessionBindingWhereUniqueInput
    create: XOR<AIBotSessionBindingCreateWithoutBotInput, AIBotSessionBindingUncheckedCreateWithoutBotInput>
  }

  export type AIBotSessionBindingCreateManyBotInputEnvelope = {
    data: AIBotSessionBindingCreateManyBotInput | AIBotSessionBindingCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type BotKnowledgeBindingCreateWithoutBotInput = {
    id?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    document: AIDocumentCreateNestedOneWithoutBotKnowledgeBindingsInput
  }

  export type BotKnowledgeBindingUncheckedCreateWithoutBotInput = {
    id?: string
    documentId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotKnowledgeBindingCreateOrConnectWithoutBotInput = {
    where: BotKnowledgeBindingWhereUniqueInput
    create: XOR<BotKnowledgeBindingCreateWithoutBotInput, BotKnowledgeBindingUncheckedCreateWithoutBotInput>
  }

  export type BotKnowledgeBindingCreateManyBotInputEnvelope = {
    data: BotKnowledgeBindingCreateManyBotInput | BotKnowledgeBindingCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWhatsAppAIBotsInput = {
    update: XOR<UserUpdateWithoutWhatsAppAIBotsInput, UserUncheckedUpdateWithoutWhatsAppAIBotsInput>
    create: XOR<UserCreateWithoutWhatsAppAIBotsInput, UserUncheckedCreateWithoutWhatsAppAIBotsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsAppAIBotsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsAppAIBotsInput, UserUncheckedUpdateWithoutWhatsAppAIBotsInput>
  }

  export type UserUpdateWithoutWhatsAppAIBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsAppAIBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AIBotSessionBindingUpsertWithWhereUniqueWithoutBotInput = {
    where: AIBotSessionBindingWhereUniqueInput
    update: XOR<AIBotSessionBindingUpdateWithoutBotInput, AIBotSessionBindingUncheckedUpdateWithoutBotInput>
    create: XOR<AIBotSessionBindingCreateWithoutBotInput, AIBotSessionBindingUncheckedCreateWithoutBotInput>
  }

  export type AIBotSessionBindingUpdateWithWhereUniqueWithoutBotInput = {
    where: AIBotSessionBindingWhereUniqueInput
    data: XOR<AIBotSessionBindingUpdateWithoutBotInput, AIBotSessionBindingUncheckedUpdateWithoutBotInput>
  }

  export type AIBotSessionBindingUpdateManyWithWhereWithoutBotInput = {
    where: AIBotSessionBindingScalarWhereInput
    data: XOR<AIBotSessionBindingUpdateManyMutationInput, AIBotSessionBindingUncheckedUpdateManyWithoutBotInput>
  }

  export type BotKnowledgeBindingUpsertWithWhereUniqueWithoutBotInput = {
    where: BotKnowledgeBindingWhereUniqueInput
    update: XOR<BotKnowledgeBindingUpdateWithoutBotInput, BotKnowledgeBindingUncheckedUpdateWithoutBotInput>
    create: XOR<BotKnowledgeBindingCreateWithoutBotInput, BotKnowledgeBindingUncheckedCreateWithoutBotInput>
  }

  export type BotKnowledgeBindingUpdateWithWhereUniqueWithoutBotInput = {
    where: BotKnowledgeBindingWhereUniqueInput
    data: XOR<BotKnowledgeBindingUpdateWithoutBotInput, BotKnowledgeBindingUncheckedUpdateWithoutBotInput>
  }

  export type BotKnowledgeBindingUpdateManyWithWhereWithoutBotInput = {
    where: BotKnowledgeBindingScalarWhereInput
    data: XOR<BotKnowledgeBindingUpdateManyMutationInput, BotKnowledgeBindingUncheckedUpdateManyWithoutBotInput>
  }

  export type BotKnowledgeBindingScalarWhereInput = {
    AND?: BotKnowledgeBindingScalarWhereInput | BotKnowledgeBindingScalarWhereInput[]
    OR?: BotKnowledgeBindingScalarWhereInput[]
    NOT?: BotKnowledgeBindingScalarWhereInput | BotKnowledgeBindingScalarWhereInput[]
    id?: StringFilter<"BotKnowledgeBinding"> | string
    botId?: StringFilter<"BotKnowledgeBinding"> | string
    documentId?: StringFilter<"BotKnowledgeBinding"> | string
    isActive?: BoolFilter<"BotKnowledgeBinding"> | boolean
    createdAt?: DateTimeFilter<"BotKnowledgeBinding"> | Date | string
    updatedAt?: DateTimeFilter<"BotKnowledgeBinding"> | Date | string
  }

  export type UserCreateWithoutAiDocumentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiDocumentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiDocumentsInput, UserUncheckedCreateWithoutAiDocumentsInput>
  }

  export type BotKnowledgeBindingCreateWithoutDocumentInput = {
    id?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: WhatsAppAIBotCreateNestedOneWithoutBotKnowledgeBindingsInput
  }

  export type BotKnowledgeBindingUncheckedCreateWithoutDocumentInput = {
    id?: string
    botId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotKnowledgeBindingCreateOrConnectWithoutDocumentInput = {
    where: BotKnowledgeBindingWhereUniqueInput
    create: XOR<BotKnowledgeBindingCreateWithoutDocumentInput, BotKnowledgeBindingUncheckedCreateWithoutDocumentInput>
  }

  export type BotKnowledgeBindingCreateManyDocumentInputEnvelope = {
    data: BotKnowledgeBindingCreateManyDocumentInput | BotKnowledgeBindingCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAiDocumentsInput = {
    update: XOR<UserUpdateWithoutAiDocumentsInput, UserUncheckedUpdateWithoutAiDocumentsInput>
    create: XOR<UserCreateWithoutAiDocumentsInput, UserUncheckedCreateWithoutAiDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiDocumentsInput, UserUncheckedUpdateWithoutAiDocumentsInput>
  }

  export type UserUpdateWithoutAiDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BotKnowledgeBindingUpsertWithWhereUniqueWithoutDocumentInput = {
    where: BotKnowledgeBindingWhereUniqueInput
    update: XOR<BotKnowledgeBindingUpdateWithoutDocumentInput, BotKnowledgeBindingUncheckedUpdateWithoutDocumentInput>
    create: XOR<BotKnowledgeBindingCreateWithoutDocumentInput, BotKnowledgeBindingUncheckedCreateWithoutDocumentInput>
  }

  export type BotKnowledgeBindingUpdateWithWhereUniqueWithoutDocumentInput = {
    where: BotKnowledgeBindingWhereUniqueInput
    data: XOR<BotKnowledgeBindingUpdateWithoutDocumentInput, BotKnowledgeBindingUncheckedUpdateWithoutDocumentInput>
  }

  export type BotKnowledgeBindingUpdateManyWithWhereWithoutDocumentInput = {
    where: BotKnowledgeBindingScalarWhereInput
    data: XOR<BotKnowledgeBindingUpdateManyMutationInput, BotKnowledgeBindingUncheckedUpdateManyWithoutDocumentInput>
  }

  export type UserCreateWithoutAiUsageLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiUsageLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiUsageLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiUsageLogsInput, UserUncheckedCreateWithoutAiUsageLogsInput>
  }

  export type UserUpsertWithoutAiUsageLogsInput = {
    update: XOR<UserUpdateWithoutAiUsageLogsInput, UserUncheckedUpdateWithoutAiUsageLogsInput>
    create: XOR<UserCreateWithoutAiUsageLogsInput, UserUncheckedCreateWithoutAiUsageLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiUsageLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiUsageLogsInput, UserUncheckedUpdateWithoutAiUsageLogsInput>
  }

  export type UserUpdateWithoutAiUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WhatsAppAIBotCreateWithoutAiBotSessionBindingsInput = {
    id?: string
    name?: string
    isActive?: boolean
    systemPrompt?: string | null
    fallbackText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWhatsAppAIBotsInput
    botKnowledgeBindings?: BotKnowledgeBindingCreateNestedManyWithoutBotInput
  }

  export type WhatsAppAIBotUncheckedCreateWithoutAiBotSessionBindingsInput = {
    id?: string
    userId: string
    name?: string
    isActive?: boolean
    systemPrompt?: string | null
    fallbackText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    botKnowledgeBindings?: BotKnowledgeBindingUncheckedCreateNestedManyWithoutBotInput
  }

  export type WhatsAppAIBotCreateOrConnectWithoutAiBotSessionBindingsInput = {
    where: WhatsAppAIBotWhereUniqueInput
    create: XOR<WhatsAppAIBotCreateWithoutAiBotSessionBindingsInput, WhatsAppAIBotUncheckedCreateWithoutAiBotSessionBindingsInput>
  }

  export type UserCreateWithoutAiBotSessionBindingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiBotSessionBindingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string | null
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedCreateNestedManyWithoutUserInput
    WhatsAppContact?: WhatsAppContactUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedCreateNestedManyWithoutUserInput
    aiDocuments?: AIDocumentUncheckedCreateNestedManyWithoutUserInput
    aiUsageLogs?: AIUsageLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiBotSessionBindingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiBotSessionBindingsInput, UserUncheckedCreateWithoutAiBotSessionBindingsInput>
  }

  export type WhatsAppSessionCreateWithoutAiBotSessionBindingsInput = {
    id?: string
    sessionId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    sessionName: string
    connected?: boolean
    events?: string | null
    expiration?: number
    isSystemSession?: boolean
    jid?: string | null
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: string | null
    qrcode?: string | null
    s3AccessKey?: string | null
    s3Bucket?: string | null
    s3Enabled?: boolean
    s3Endpoint?: string | null
    s3MediaDelivery?: string | null
    s3PathStyle?: boolean
    s3PublicUrl?: string | null
    s3Region?: string | null
    s3RetentionDays?: number
    s3SecretKey?: string | null
    token: string
    webhook?: string | null
    autoReadMessages?: boolean
    typingIndicator?: boolean
    user?: UserCreateNestedOneWithoutWhatsAppSessionsInput
    whatsAppMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionUncheckedCreateWithoutAiBotSessionBindingsInput = {
    id?: string
    sessionId: string
    userId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    sessionName: string
    connected?: boolean
    events?: string | null
    expiration?: number
    isSystemSession?: boolean
    jid?: string | null
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: string | null
    qrcode?: string | null
    s3AccessKey?: string | null
    s3Bucket?: string | null
    s3Enabled?: boolean
    s3Endpoint?: string | null
    s3MediaDelivery?: string | null
    s3PathStyle?: boolean
    s3PublicUrl?: string | null
    s3Region?: string | null
    s3RetentionDays?: number
    s3SecretKey?: string | null
    token: string
    webhook?: string | null
    autoReadMessages?: boolean
    typingIndicator?: boolean
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionCreateOrConnectWithoutAiBotSessionBindingsInput = {
    where: WhatsAppSessionWhereUniqueInput
    create: XOR<WhatsAppSessionCreateWithoutAiBotSessionBindingsInput, WhatsAppSessionUncheckedCreateWithoutAiBotSessionBindingsInput>
  }

  export type WhatsAppAIBotUpsertWithoutAiBotSessionBindingsInput = {
    update: XOR<WhatsAppAIBotUpdateWithoutAiBotSessionBindingsInput, WhatsAppAIBotUncheckedUpdateWithoutAiBotSessionBindingsInput>
    create: XOR<WhatsAppAIBotCreateWithoutAiBotSessionBindingsInput, WhatsAppAIBotUncheckedCreateWithoutAiBotSessionBindingsInput>
    where?: WhatsAppAIBotWhereInput
  }

  export type WhatsAppAIBotUpdateToOneWithWhereWithoutAiBotSessionBindingsInput = {
    where?: WhatsAppAIBotWhereInput
    data: XOR<WhatsAppAIBotUpdateWithoutAiBotSessionBindingsInput, WhatsAppAIBotUncheckedUpdateWithoutAiBotSessionBindingsInput>
  }

  export type WhatsAppAIBotUpdateWithoutAiBotSessionBindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWhatsAppAIBotsNestedInput
    botKnowledgeBindings?: BotKnowledgeBindingUpdateManyWithoutBotNestedInput
  }

  export type WhatsAppAIBotUncheckedUpdateWithoutAiBotSessionBindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    botKnowledgeBindings?: BotKnowledgeBindingUncheckedUpdateManyWithoutBotNestedInput
  }

  export type UserUpsertWithoutAiBotSessionBindingsInput = {
    update: XOR<UserUpdateWithoutAiBotSessionBindingsInput, UserUncheckedUpdateWithoutAiBotSessionBindingsInput>
    create: XOR<UserCreateWithoutAiBotSessionBindingsInput, UserUncheckedCreateWithoutAiBotSessionBindingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiBotSessionBindingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiBotSessionBindingsInput, UserUncheckedUpdateWithoutAiBotSessionBindingsInput>
  }

  export type UserUpdateWithoutAiBotSessionBindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiBotSessionBindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUncheckedUpdateManyWithoutUserNestedInput
    WhatsAppContact?: WhatsAppContactUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
    whatsAppAIBots?: WhatsAppAIBotUncheckedUpdateManyWithoutUserNestedInput
    aiDocuments?: AIDocumentUncheckedUpdateManyWithoutUserNestedInput
    aiUsageLogs?: AIUsageLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WhatsAppSessionUpsertWithoutAiBotSessionBindingsInput = {
    update: XOR<WhatsAppSessionUpdateWithoutAiBotSessionBindingsInput, WhatsAppSessionUncheckedUpdateWithoutAiBotSessionBindingsInput>
    create: XOR<WhatsAppSessionCreateWithoutAiBotSessionBindingsInput, WhatsAppSessionUncheckedCreateWithoutAiBotSessionBindingsInput>
    where?: WhatsAppSessionWhereInput
  }

  export type WhatsAppSessionUpdateToOneWithWhereWithoutAiBotSessionBindingsInput = {
    where?: WhatsAppSessionWhereInput
    data: XOR<WhatsAppSessionUpdateWithoutAiBotSessionBindingsInput, WhatsAppSessionUncheckedUpdateWithoutAiBotSessionBindingsInput>
  }

  export type WhatsAppSessionUpdateWithoutAiBotSessionBindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutWhatsAppSessionsNestedInput
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateWithoutAiBotSessionBindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppAIBotCreateWithoutBotKnowledgeBindingsInput = {
    id?: string
    name?: string
    isActive?: boolean
    systemPrompt?: string | null
    fallbackText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWhatsAppAIBotsInput
    aiBotSessionBindings?: AIBotSessionBindingCreateNestedManyWithoutBotInput
  }

  export type WhatsAppAIBotUncheckedCreateWithoutBotKnowledgeBindingsInput = {
    id?: string
    userId: string
    name?: string
    isActive?: boolean
    systemPrompt?: string | null
    fallbackText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiBotSessionBindings?: AIBotSessionBindingUncheckedCreateNestedManyWithoutBotInput
  }

  export type WhatsAppAIBotCreateOrConnectWithoutBotKnowledgeBindingsInput = {
    where: WhatsAppAIBotWhereUniqueInput
    create: XOR<WhatsAppAIBotCreateWithoutBotKnowledgeBindingsInput, WhatsAppAIBotUncheckedCreateWithoutBotKnowledgeBindingsInput>
  }

  export type AIDocumentCreateWithoutBotKnowledgeBindingsInput = {
    id?: string
    title: string
    kind?: string
    content: string
    embeddingId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAiDocumentsInput
  }

  export type AIDocumentUncheckedCreateWithoutBotKnowledgeBindingsInput = {
    id?: string
    userId: string
    title: string
    kind?: string
    content: string
    embeddingId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIDocumentCreateOrConnectWithoutBotKnowledgeBindingsInput = {
    where: AIDocumentWhereUniqueInput
    create: XOR<AIDocumentCreateWithoutBotKnowledgeBindingsInput, AIDocumentUncheckedCreateWithoutBotKnowledgeBindingsInput>
  }

  export type WhatsAppAIBotUpsertWithoutBotKnowledgeBindingsInput = {
    update: XOR<WhatsAppAIBotUpdateWithoutBotKnowledgeBindingsInput, WhatsAppAIBotUncheckedUpdateWithoutBotKnowledgeBindingsInput>
    create: XOR<WhatsAppAIBotCreateWithoutBotKnowledgeBindingsInput, WhatsAppAIBotUncheckedCreateWithoutBotKnowledgeBindingsInput>
    where?: WhatsAppAIBotWhereInput
  }

  export type WhatsAppAIBotUpdateToOneWithWhereWithoutBotKnowledgeBindingsInput = {
    where?: WhatsAppAIBotWhereInput
    data: XOR<WhatsAppAIBotUpdateWithoutBotKnowledgeBindingsInput, WhatsAppAIBotUncheckedUpdateWithoutBotKnowledgeBindingsInput>
  }

  export type WhatsAppAIBotUpdateWithoutBotKnowledgeBindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWhatsAppAIBotsNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutBotNestedInput
  }

  export type WhatsAppAIBotUncheckedUpdateWithoutBotKnowledgeBindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutBotNestedInput
  }

  export type AIDocumentUpsertWithoutBotKnowledgeBindingsInput = {
    update: XOR<AIDocumentUpdateWithoutBotKnowledgeBindingsInput, AIDocumentUncheckedUpdateWithoutBotKnowledgeBindingsInput>
    create: XOR<AIDocumentCreateWithoutBotKnowledgeBindingsInput, AIDocumentUncheckedCreateWithoutBotKnowledgeBindingsInput>
    where?: AIDocumentWhereInput
  }

  export type AIDocumentUpdateToOneWithWhereWithoutBotKnowledgeBindingsInput = {
    where?: AIDocumentWhereInput
    data: XOR<AIDocumentUpdateWithoutBotKnowledgeBindingsInput, AIDocumentUncheckedUpdateWithoutBotKnowledgeBindingsInput>
  }

  export type AIDocumentUpdateWithoutBotKnowledgeBindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiDocumentsNestedInput
  }

  export type AIDocumentUncheckedUpdateWithoutBotKnowledgeBindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersCreateManyCustomerInput = {
    id?: string
    packageId: string
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string
    updatedAt?: Date | string
    lastSubscriptionAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
  }

  export type UserSessionCreateManyUserInput = {
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type VoucherUsageCreateManyUserInput = {
    id?: string
    voucherId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type WhatsAppBulkCampaignCreateManyUserInput = {
    id?: bigint | number
    campaign_id?: bigint | number | null
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppCampaignCreateManyUserInput = {
    id?: bigint | number
    name: string
    type: string
    status?: string | null
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppContactCreateManyUserInput = {
    id?: bigint | number
    phone: string
    name?: string | null
    full_name?: string | null
    push_name?: string | null
    short?: string | null
    notify?: string | null
    business?: boolean | null
    verified?: boolean | null
    source?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppSessionCreateManyUserInput = {
    id?: string
    sessionId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    message?: string | null
    sessionName: string
    connected?: boolean
    events?: string | null
    expiration?: number
    isSystemSession?: boolean
    jid?: string | null
    loggedIn?: boolean
    proxyEnabled?: boolean
    proxyUrl?: string | null
    qrcode?: string | null
    s3AccessKey?: string | null
    s3Bucket?: string | null
    s3Enabled?: boolean
    s3Endpoint?: string | null
    s3MediaDelivery?: string | null
    s3PathStyle?: boolean
    s3PublicUrl?: string | null
    s3Region?: string | null
    s3RetentionDays?: number
    s3SecretKey?: string | null
    token: string
    webhook?: string | null
    autoReadMessages?: boolean
    typingIndicator?: boolean
  }

  export type WhatsAppMessageStatsCreateManyUserInput = {
    id?: string
    sessionId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    textMessagesSent?: number
    textMessagesFailed?: number
    imageMessagesSent?: number
    imageMessagesFailed?: number
    documentMessagesSent?: number
    documentMessagesFailed?: number
    audioMessagesSent?: number
    audioMessagesFailed?: number
    stickerMessagesSent?: number
    stickerMessagesFailed?: number
    videoMessagesSent?: number
    videoMessagesFailed?: number
    locationMessagesSent?: number
    locationMessagesFailed?: number
    contactMessagesSent?: number
    contactMessagesFailed?: number
    templateMessagesSent?: number
    templateMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppAIBotCreateManyUserInput = {
    id?: string
    name?: string
    isActive?: boolean
    systemPrompt?: string | null
    fallbackText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIDocumentCreateManyUserInput = {
    id?: string
    title: string
    kind?: string
    content: string
    embeddingId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIUsageLogCreateManyUserInput = {
    id?: string
    sessionId?: string | null
    inputTokens?: number
    outputTokens?: number
    totalTokens?: number
    latencyMs?: number
    status?: string
    errorReason?: string | null
    createdAt?: Date | string
  }

  export type AIBotSessionBindingCreateManyUserInput = {
    id?: string
    botId: string
    sessionId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesWhatsappCustomersUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSubscriptionAt?: DateTimeFieldUpdateOperationsInput | Date | string
    package?: WhatsappApiPackageUpdateOneRequiredWithoutWhatsappCustomersNestedInput
  }

  export type ServicesWhatsappCustomersUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSubscriptionAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSubscriptionAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: TransactionUpdateOneWithoutVoucherUsageNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutVoucherUsageNestedInput
  }

  export type VoucherUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WhatsAppBulkCampaignUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemUpdateManyWithoutWhatsAppBulkCampaignsNestedInput
    WhatsAppCampaigns?: WhatsAppCampaignUpdateOneWithoutWhatsAppBulkCampaignsNestedInput
  }

  export type WhatsAppBulkCampaignUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    campaign_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemUncheckedUpdateManyWithoutWhatsAppBulkCampaignsNestedInput
  }

  export type WhatsAppBulkCampaignUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    campaign_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppCampaignUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUpdateManyWithoutWhatsAppCampaignsNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaigns?: WhatsAppBulkCampaignUncheckedUpdateManyWithoutWhatsAppCampaignsNestedInput
  }

  export type WhatsAppCampaignUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppContactUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    notify?: NullableStringFieldUpdateOperationsInput | string | null
    business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppContactUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    notify?: NullableStringFieldUpdateOperationsInput | string | null
    business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppContactUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    notify?: NullableStringFieldUpdateOperationsInput | string | null
    business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
    whatsAppMessageStats?: WhatsAppMessageStatsUpdateManyWithoutSessionNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
    whatsAppMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionNestedInput
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: StringFieldUpdateOperationsInput | string
    connected?: BoolFieldUpdateOperationsInput | boolean
    events?: NullableStringFieldUpdateOperationsInput | string | null
    expiration?: IntFieldUpdateOperationsInput | number
    isSystemSession?: BoolFieldUpdateOperationsInput | boolean
    jid?: NullableStringFieldUpdateOperationsInput | string | null
    loggedIn?: BoolFieldUpdateOperationsInput | boolean
    proxyEnabled?: BoolFieldUpdateOperationsInput | boolean
    proxyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    s3AccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    s3Bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3Enabled?: BoolFieldUpdateOperationsInput | boolean
    s3Endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3MediaDelivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3PathStyle?: BoolFieldUpdateOperationsInput | boolean
    s3PublicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    s3Region?: NullableStringFieldUpdateOperationsInput | string | null
    s3RetentionDays?: IntFieldUpdateOperationsInput | number
    s3SecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    autoReadMessages?: BoolFieldUpdateOperationsInput | boolean
    typingIndicator?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WhatsAppMessageStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    textMessagesSent?: IntFieldUpdateOperationsInput | number
    textMessagesFailed?: IntFieldUpdateOperationsInput | number
    imageMessagesSent?: IntFieldUpdateOperationsInput | number
    imageMessagesFailed?: IntFieldUpdateOperationsInput | number
    documentMessagesSent?: IntFieldUpdateOperationsInput | number
    documentMessagesFailed?: IntFieldUpdateOperationsInput | number
    audioMessagesSent?: IntFieldUpdateOperationsInput | number
    audioMessagesFailed?: IntFieldUpdateOperationsInput | number
    stickerMessagesSent?: IntFieldUpdateOperationsInput | number
    stickerMessagesFailed?: IntFieldUpdateOperationsInput | number
    videoMessagesSent?: IntFieldUpdateOperationsInput | number
    videoMessagesFailed?: IntFieldUpdateOperationsInput | number
    locationMessagesSent?: IntFieldUpdateOperationsInput | number
    locationMessagesFailed?: IntFieldUpdateOperationsInput | number
    contactMessagesSent?: IntFieldUpdateOperationsInput | number
    contactMessagesFailed?: IntFieldUpdateOperationsInput | number
    templateMessagesSent?: IntFieldUpdateOperationsInput | number
    templateMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: WhatsAppSessionUpdateOneRequiredWithoutWhatsAppMessageStatsNestedInput
  }

  export type WhatsAppMessageStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    textMessagesSent?: IntFieldUpdateOperationsInput | number
    textMessagesFailed?: IntFieldUpdateOperationsInput | number
    imageMessagesSent?: IntFieldUpdateOperationsInput | number
    imageMessagesFailed?: IntFieldUpdateOperationsInput | number
    documentMessagesSent?: IntFieldUpdateOperationsInput | number
    documentMessagesFailed?: IntFieldUpdateOperationsInput | number
    audioMessagesSent?: IntFieldUpdateOperationsInput | number
    audioMessagesFailed?: IntFieldUpdateOperationsInput | number
    stickerMessagesSent?: IntFieldUpdateOperationsInput | number
    stickerMessagesFailed?: IntFieldUpdateOperationsInput | number
    videoMessagesSent?: IntFieldUpdateOperationsInput | number
    videoMessagesFailed?: IntFieldUpdateOperationsInput | number
    locationMessagesSent?: IntFieldUpdateOperationsInput | number
    locationMessagesFailed?: IntFieldUpdateOperationsInput | number
    contactMessagesSent?: IntFieldUpdateOperationsInput | number
    contactMessagesFailed?: IntFieldUpdateOperationsInput | number
    templateMessagesSent?: IntFieldUpdateOperationsInput | number
    templateMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    textMessagesSent?: IntFieldUpdateOperationsInput | number
    textMessagesFailed?: IntFieldUpdateOperationsInput | number
    imageMessagesSent?: IntFieldUpdateOperationsInput | number
    imageMessagesFailed?: IntFieldUpdateOperationsInput | number
    documentMessagesSent?: IntFieldUpdateOperationsInput | number
    documentMessagesFailed?: IntFieldUpdateOperationsInput | number
    audioMessagesSent?: IntFieldUpdateOperationsInput | number
    audioMessagesFailed?: IntFieldUpdateOperationsInput | number
    stickerMessagesSent?: IntFieldUpdateOperationsInput | number
    stickerMessagesFailed?: IntFieldUpdateOperationsInput | number
    videoMessagesSent?: IntFieldUpdateOperationsInput | number
    videoMessagesFailed?: IntFieldUpdateOperationsInput | number
    locationMessagesSent?: IntFieldUpdateOperationsInput | number
    locationMessagesFailed?: IntFieldUpdateOperationsInput | number
    contactMessagesSent?: IntFieldUpdateOperationsInput | number
    contactMessagesFailed?: IntFieldUpdateOperationsInput | number
    templateMessagesSent?: IntFieldUpdateOperationsInput | number
    templateMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppAIBotUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiBotSessionBindings?: AIBotSessionBindingUpdateManyWithoutBotNestedInput
    botKnowledgeBindings?: BotKnowledgeBindingUpdateManyWithoutBotNestedInput
  }

  export type WhatsAppAIBotUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiBotSessionBindings?: AIBotSessionBindingUncheckedUpdateManyWithoutBotNestedInput
    botKnowledgeBindings?: BotKnowledgeBindingUncheckedUpdateManyWithoutBotNestedInput
  }

  export type WhatsAppAIBotUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    fallbackText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    botKnowledgeBindings?: BotKnowledgeBindingUpdateManyWithoutDocumentNestedInput
  }

  export type AIDocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    botKnowledgeBindings?: BotKnowledgeBindingUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type AIDocumentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    latencyMs?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    errorReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIBotSessionBindingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: WhatsAppAIBotUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput
    session?: WhatsAppSessionUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput
  }

  export type AIBotSessionBindingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIBotSessionBindingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsCreateManySessionInput = {
    id?: string
    userId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    textMessagesSent?: number
    textMessagesFailed?: number
    imageMessagesSent?: number
    imageMessagesFailed?: number
    documentMessagesSent?: number
    documentMessagesFailed?: number
    audioMessagesSent?: number
    audioMessagesFailed?: number
    stickerMessagesSent?: number
    stickerMessagesFailed?: number
    videoMessagesSent?: number
    videoMessagesFailed?: number
    locationMessagesSent?: number
    locationMessagesFailed?: number
    contactMessagesSent?: number
    contactMessagesFailed?: number
    templateMessagesSent?: number
    templateMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIBotSessionBindingCreateManySessionInput = {
    id?: string
    userId: string
    botId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    textMessagesSent?: IntFieldUpdateOperationsInput | number
    textMessagesFailed?: IntFieldUpdateOperationsInput | number
    imageMessagesSent?: IntFieldUpdateOperationsInput | number
    imageMessagesFailed?: IntFieldUpdateOperationsInput | number
    documentMessagesSent?: IntFieldUpdateOperationsInput | number
    documentMessagesFailed?: IntFieldUpdateOperationsInput | number
    audioMessagesSent?: IntFieldUpdateOperationsInput | number
    audioMessagesFailed?: IntFieldUpdateOperationsInput | number
    stickerMessagesSent?: IntFieldUpdateOperationsInput | number
    stickerMessagesFailed?: IntFieldUpdateOperationsInput | number
    videoMessagesSent?: IntFieldUpdateOperationsInput | number
    videoMessagesFailed?: IntFieldUpdateOperationsInput | number
    locationMessagesSent?: IntFieldUpdateOperationsInput | number
    locationMessagesFailed?: IntFieldUpdateOperationsInput | number
    contactMessagesSent?: IntFieldUpdateOperationsInput | number
    contactMessagesFailed?: IntFieldUpdateOperationsInput | number
    templateMessagesSent?: IntFieldUpdateOperationsInput | number
    templateMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWhatsAppMessageStatsNestedInput
  }

  export type WhatsAppMessageStatsUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    textMessagesSent?: IntFieldUpdateOperationsInput | number
    textMessagesFailed?: IntFieldUpdateOperationsInput | number
    imageMessagesSent?: IntFieldUpdateOperationsInput | number
    imageMessagesFailed?: IntFieldUpdateOperationsInput | number
    documentMessagesSent?: IntFieldUpdateOperationsInput | number
    documentMessagesFailed?: IntFieldUpdateOperationsInput | number
    audioMessagesSent?: IntFieldUpdateOperationsInput | number
    audioMessagesFailed?: IntFieldUpdateOperationsInput | number
    stickerMessagesSent?: IntFieldUpdateOperationsInput | number
    stickerMessagesFailed?: IntFieldUpdateOperationsInput | number
    videoMessagesSent?: IntFieldUpdateOperationsInput | number
    videoMessagesFailed?: IntFieldUpdateOperationsInput | number
    locationMessagesSent?: IntFieldUpdateOperationsInput | number
    locationMessagesFailed?: IntFieldUpdateOperationsInput | number
    contactMessagesSent?: IntFieldUpdateOperationsInput | number
    contactMessagesFailed?: IntFieldUpdateOperationsInput | number
    templateMessagesSent?: IntFieldUpdateOperationsInput | number
    templateMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    textMessagesSent?: IntFieldUpdateOperationsInput | number
    textMessagesFailed?: IntFieldUpdateOperationsInput | number
    imageMessagesSent?: IntFieldUpdateOperationsInput | number
    imageMessagesFailed?: IntFieldUpdateOperationsInput | number
    documentMessagesSent?: IntFieldUpdateOperationsInput | number
    documentMessagesFailed?: IntFieldUpdateOperationsInput | number
    audioMessagesSent?: IntFieldUpdateOperationsInput | number
    audioMessagesFailed?: IntFieldUpdateOperationsInput | number
    stickerMessagesSent?: IntFieldUpdateOperationsInput | number
    stickerMessagesFailed?: IntFieldUpdateOperationsInput | number
    videoMessagesSent?: IntFieldUpdateOperationsInput | number
    videoMessagesFailed?: IntFieldUpdateOperationsInput | number
    locationMessagesSent?: IntFieldUpdateOperationsInput | number
    locationMessagesFailed?: IntFieldUpdateOperationsInput | number
    contactMessagesSent?: IntFieldUpdateOperationsInput | number
    contactMessagesFailed?: IntFieldUpdateOperationsInput | number
    templateMessagesSent?: IntFieldUpdateOperationsInput | number
    templateMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIBotSessionBindingUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: WhatsAppAIBotUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput
    user?: UserUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput
  }

  export type AIBotSessionBindingUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIBotSessionBindingUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageCreateManyTransactionInput = {
    id?: string
    voucherId: string
    userId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user?: UserUpdateOneRequiredWithoutVoucherUsageNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutVoucherUsageNestedInput
  }

  export type VoucherUsageUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServicesWhatsappCustomersCreateManyPackageInput = {
    id?: string
    customerId: string
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string
    updatedAt?: Date | string
    lastSubscriptionAt?: Date | string
  }

  export type TransactionWhatsappServiceCreateManyWhatsappPackageInput = {
    id?: string
    transactionId: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type ServicesWhatsappCustomersUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSubscriptionAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutWhatsappCustomersNestedInput
  }

  export type ServicesWhatsappCustomersUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSubscriptionAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSubscriptionAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionWhatsappServiceUpdateWithoutWhatsappPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUpdateOneRequiredWithoutWhatsappTransactionNestedInput
  }

  export type TransactionWhatsappServiceUncheckedUpdateWithoutWhatsappPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionWhatsappServiceUncheckedUpdateManyWithoutWhatsappPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyVoucherInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
  }

  export type VoucherUsageCreateManyVoucherInput = {
    id?: string
    userId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type TransactionUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUsageUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: TransactionUpdateOneWithoutVoucherUsageNestedInput
    user?: UserUpdateOneRequiredWithoutVoucherUsageNestedInput
  }

  export type VoucherUsageUncheckedUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUncheckedUpdateManyWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentMethodCreateManyBankDetailInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    isActive?: boolean
    isSystem?: boolean
    gatewayProvider?: string | null
    gatewayCode?: string | null
    gatewayImageUrl?: string | null
    isGatewayMethod?: boolean
    feeType?: string | null
    feeValue?: Decimal | DecimalJsLike | number | string | null
    minFee?: Decimal | DecimalJsLike | number | string | null
    maxFee?: Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: boolean
    paymentInstructions?: string | null
    instructionType?: string | null
    instructionImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateWithoutBankDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayCode?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGatewayMethod?: BoolFieldUpdateOperationsInput | boolean
    feeType?: NullableStringFieldUpdateOperationsInput | string | null
    feeValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateWithoutBankDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayCode?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGatewayMethod?: BoolFieldUpdateOperationsInput | boolean
    feeType?: NullableStringFieldUpdateOperationsInput | string | null
    feeValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyWithoutBankDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayCode?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGatewayMethod?: BoolFieldUpdateOperationsInput | boolean
    feeType?: NullableStringFieldUpdateOperationsInput | string | null
    feeValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppBulkCampaignCreateManyWhatsAppCampaignsInput = {
    id?: bigint | number
    user_id: string
    name: string
    type: string
    message_body?: string | null
    image_url?: string | null
    image_base64?: string | null
    caption?: string | null
    status?: string | null
    total_count?: bigint | number | null
    sent_count?: bigint | number | null
    failed_count?: bigint | number | null
    scheduled_at?: Date | string | null
    timezone?: string | null
    processed_at?: Date | string | null
    completed_at?: Date | string | null
    error_message?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppBulkCampaignUpdateWithoutWhatsAppCampaignsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemUpdateManyWithoutWhatsAppBulkCampaignsNestedInput
    User?: UserUpdateOneRequiredWithoutWhatsAppBulkCampaignsNestedInput
  }

  export type WhatsAppBulkCampaignUncheckedUpdateWithoutWhatsAppCampaignsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WhatsAppBulkCampaignItems?: WhatsAppBulkCampaignItemUncheckedUpdateManyWithoutWhatsAppBulkCampaignsNestedInput
  }

  export type WhatsAppBulkCampaignUncheckedUpdateManyWithoutWhatsAppCampaignsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message_body?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_base64?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sent_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    failed_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppBulkCampaignItemCreateManyWhatsAppBulkCampaignsInput = {
    id?: bigint | number
    phone: string
    status?: string | null
    message_id?: string | null
    error_message?: string | null
    sent_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type WhatsAppBulkCampaignItemUpdateWithoutWhatsAppBulkCampaignsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppBulkCampaignItemUncheckedUpdateWithoutWhatsAppBulkCampaignsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsAppBulkCampaignItemUncheckedUpdateManyWithoutWhatsAppBulkCampaignsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AIBotSessionBindingCreateManyBotInput = {
    id?: string
    userId: string
    sessionId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotKnowledgeBindingCreateManyBotInput = {
    id?: string
    documentId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIBotSessionBindingUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput
    session?: WhatsAppSessionUpdateOneRequiredWithoutAiBotSessionBindingsNestedInput
  }

  export type AIBotSessionBindingUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIBotSessionBindingUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotKnowledgeBindingUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: AIDocumentUpdateOneRequiredWithoutBotKnowledgeBindingsNestedInput
  }

  export type BotKnowledgeBindingUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotKnowledgeBindingUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotKnowledgeBindingCreateManyDocumentInput = {
    id?: string
    botId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotKnowledgeBindingUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: WhatsAppAIBotUpdateOneRequiredWithoutBotKnowledgeBindingsNestedInput
  }

  export type BotKnowledgeBindingUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotKnowledgeBindingUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}